<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Database Systems - 标签 - Jungle&#39;s Blog</title>
        <link>https://Jungle430.github.io/tags/database-systems/</link>
        <description>Database Systems - 标签 - Jungle&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>junglece430@gmail.com (Jungle)</managingEditor>
            <webMaster>junglece430@gmail.com (Jungle)</webMaster><lastBuildDate>Fri, 12 Apr 2024 14:56:21 &#43;0800</lastBuildDate><atom:link href="https://Jungle430.github.io/tags/database-systems/" rel="self" type="application/rss+xml" /><item>
    <title>CMU 15-445 Lecture #13: Query Processing I</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter13/</link>
    <pubDate>Fri, 12 Apr 2024 14:56:21 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter13/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-13-query-processing-i">Lecture #13: Query Processing I</h2>
<h3 id="query-plan">Query Plan</h3>
<ul>
<li>就是前面提到的执行树</li>
<li>同一个SQL可以有很多执行计划</li>
</ul>
<h3 id="processing-models">Processing Models</h3>
<ul>
<li>Approach #1: <strong>Iterator Model</strong></li>
<li>Approach #2: <strong>Materialization Model</strong></li>
<li>Approach #3: <strong>Vectorized / Batch Model</strong></li>
</ul>
<hr>
<ul>
<li>
<p><strong>Iterator Model</strong></p>
<ul>
<li>
<p>每一个算子需要提供一个Next()的方法，父算子调用一次就吐出来一些数据，如果返回null说明数据都吐出来了（很像Python的yield），我也可以调用我的子算子的Next()方法</p>
</li>
<li>
<p>也叫“<strong>Volcano/Pipeline Model</strong>”</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter12-1.jpg" title="/img/CMU 15-445 Database Systems/chapter12-1.jpg" data-thumbnail="/img/CMU 15-445 Database Systems/chapter12-1.jpg" data-sub-html="<h2>Volcano Model计算的模型</h2>">
        
    </a><figcaption class="image-caption">Volcano Model计算的模型</figcaption>
    </figure>
</li>
<li>
<p>这个模型几乎在所有DBMS中都有使用</p>
</li>
<li>
<p>这个模型会有Block的现象，比如Join的时候左边在hash，这个时候上层会被Block</p>
</li>
<li>
<p>部分操作不适合这个模型，比如Sort，只能Block之后全吐出来</p>
</li>
<li>
<p>优点：便于操作，比如LIMIT 100的话我Next() 100次就OK</p>
</li>
<li>
<p>缺点：过多的函数调用（一次返回一个，要调用好多次）会影响性能</p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p><strong>Materialization Model</strong></p>
<ul>
<li>
<p>符合直觉的模型，一把算出来给上面</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter12-2.png" title="/img/CMU 15-445 Database Systems/chapter12-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter12-2.png" data-sub-html="<h2>这里的返回值就是数组，是下面算子的最终结果</h2>">
        
    </a><figcaption class="image-caption">这里的返回值就是数组，是下面算子的最终结果</figcaption>
    </figure>
</li>
<li>
<p>OLTP的数据库喜欢这个模型(点查询)</p>
</li>
<li>
<p>OLAP容易给表吐爆</p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Vectorized / Batch Model</strong>
<ul>
<li>前两个模型折中，Next()每次吐出来一批</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter12-3.png" title="/img/CMU 15-445 Database Systems/chapter12-3.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter12-3.png" data-sub-html="<h2>每次吐出来一批数据</h2>">
        
    </a><figcaption class="image-caption">每次吐出来一批数据</figcaption>
    </figure></li>
<li>OLAP友好，函数调用不会过多，又不会像<strong>Materialization Model</strong>那样一次返回的东西太大</li>
<li>还有个好处就是匹配硬件，现在部分CPU支持小规模并行处理事务（类似残废版CUDA），这种模型非常符合CPU的并行批处理指令</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>函数调用的方向可以根到叶子，也可以叶子到根</li>
</ul>
<h3 id="access-methods">Access Methods</h3>
<ul>
<li><strong>Sequential Scan</strong>
<ul>
<li>顺序扫描</li>
<li>顺序把页读进来，然后顺序扫描叶中的元组</li>
<li>优化
<ul>
<li>预加载</li>
<li>不再读的东西扫完就扔</li>
<li>并行化</li>
<li>Zone Maps
<ul>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter12-4.png" title="/img/CMU 15-445 Database Systems/chapter12-4.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter12-4.png" data-sub-html="<h2>给每个页做统计信息，这样算子可以不用加载到缓存池就对页做一次判断和过滤</h2>">
        
    </a><figcaption class="image-caption">给每个页做统计信息，这样算子可以不用加载到缓存池就对页做一次判断和过滤</figcaption>
    </figure></li>
<li>问题:数据冗余，而且不能存到页里面（那又该加载到缓存池了），要转门找地方存，还要同步数据</li>
</ul>
</li>
<li>晚物化：只要需要的数据，不要整个Tuple，或者只存Record ID，利用回表拿数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Index Scan</strong>
<ul>
<li>考虑的条件后面会讲</li>
<li>用什么索引要靠优化器分析</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Multi-Index Scan</strong>
<ul>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter12-5.png" title="/img/CMU 15-445 Database Systems/chapter12-5.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter12-5.png" data-sub-html="<h2>多索引扫描每一个条件取集合，根据谓词做交/并的操作</h2>">
        
    </a><figcaption class="image-caption">多索引扫描每一个条件取集合，根据谓词做交/并的操作</figcaption>
    </figure></li>
</ul>
</li>
</ul>
<h3 id="modification-queries">Modification Queries</h3>
<ul>
<li>
<p>更改的操作，逻辑会不一样</p>
<ul>
<li>不能无脑修改，要检查当前表的约束</li>
<li>索引等其他数据要同步进行维护</li>
<li>HALLOWEEN PROBLEM
<ul>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter12-6.png" title="/img/CMU 15-445 Database Systems/chapter12-6.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter12-6.png" data-sub-html="<h2>不记录之前操作过什么数据会导致部分数据被多次更新（更新完了之后没有达到预定条件被扫到再次被更新）</h2>">
        
    </a><figcaption class="image-caption">不记录之前操作过什么数据会导致部分数据被多次更新（更新完了之后没有达到预定条件被扫到再次被更新）</figcaption>
    </figure></li>
</ul>
</li>
</ul>
</li>
<li>
<p>expression tree</p>
<ul>
<li>给谓词表达式也用树的结构处理
<ul>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter12-7.png" title="/img/CMU 15-445 Database Systems/chapter12-7.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter12-7.png" data-sub-html="<h2>expression tree</h2>">
        
    </a><figcaption class="image-caption">expression tree</figcaption>
    </figure></li>
</ul>
</li>
<li>缺点：可能会重复计算浪费时间</li>
<li>解决方案：能先算出来的全算出来，像Java的JIT（比如经常跑的一段Java字节码，我直接转成二进制CPU指令，然后跑的时候直接跑CPU指令，省去JVM解析的过程）</li>
</ul>
</li>
</ul>
<h3 id="conclusion">CONCLUSION</h3>
<ul>
<li>The same query plan can be executed in multiple different ways.</li>
<li>(Most) DBMSs will want to use index scans as much as possible.</li>
<li>Expression trees are flexible but slow.JIT compilation can (sometimes) speed them up.</li>
</ul>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #11: Joins Algorithms</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter11/</link>
    <pubDate>Fri, 12 Apr 2024 00:56:12 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter11/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-11-joins-algorithms">Lecture #11: Joins Algorithms</h2>
<h3 id="introduction">Introduction</h3>
<ul>
<li>
<p>根据数据库的范式理论，设计数据库表的一个原则是不让数据冗余，所以在查找的时候JOIN的操作是少不了的</p>
</li>
<li>
<p>For binary joins, we often prefer the left table (the ”outer table” ) to be the smaller one of the two.优化SQL的一个方法，左表尽量小(<strong>这个小指的是文件页数少</strong>)，后面会说明原因</p>
</li>
</ul>
<h3 id="join-operators">Join Operators</h3>
<ul>
<li><strong>Operator Output</strong>
<ul>
<li>两个表满足JOIN条件的attributes可以组合成一个新的tuple</li>
<li>输出取决于以下几个方面
<ul>
<li>processing model</li>
<li>storage model</li>
<li>data requirements in query</li>
</ul>
</li>
<li><strong>Data</strong>
<ul>
<li><strong>Early materialization</strong>
<ul>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter11-1.png" title="/img/CMU 15-445 Database Systems/chapter11-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter11-1.png" data-sub-html="<h2>JOIN的时候需要什么属性都加上，最后直接输出</h2>">
        
    </a><figcaption class="image-caption">JOIN的时候需要什么属性都加上，最后直接输出</figcaption>
    </figure></li>
<li>可以避免子操作回表</li>
</ul>
</li>
<li><strong>Record Id</strong>
<ul>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter11-2.png" title="/img/CMU 15-445 Database Systems/chapter11-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter11-2.png" data-sub-html="<h2>属性里面放的是行id或者地址，后面需要回表拿数据</h2>">
        
    </a><figcaption class="image-caption">属性里面放的是行id或者地址，后面需要回表拿数据</figcaption>
    </figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p><strong>Cost Analysis</strong></p>
<ul>
<li>
<p>不同JOIN算法的开销</p>
</li>
<li>
<p>Assume</p>
<ul>
<li>
<p>M pages in table R, m tuples in R</p>
</li>
<li>
<p>N pages in table S, n tuples in S</p>
</li>
<li>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="n">R</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">S</span><span class="p">.</span><span class="n">cdate</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">S</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">ON</span><span class="w"> </span><span class="n">R</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">S</span><span class="p">.</span><span class="n">id</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">S</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>
<p>Cost Metric: <strong>number of IOs</strong> to compute join</p>
</li>
<li>
<p><strong>JOIN Algorithms</strong></p>
<ul>
<li>Next Loop Join</li>
<li>Sort-Merge Join</li>
<li>Hash Join</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="nested-loop-join">Nested Loop Join</h3>
<ul>
<li><strong>Native Nested Loop Join</strong></li>
<li>伪代码</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="line"><span class="cl"><span class="k">foreach</span> <span class="n">tuple</span> <span class="n">r</span> <span class="k">in</span> <span class="n">R</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">foreach</span> <span class="n">tuple</span> <span class="n">s</span> <span class="k">in</span> <span class="n">S</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">r</span> <span class="n">and</span> <span class="n">s</span> <span class="n">match</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">emit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>“stupid nested loop join”</p>
<ul>
<li><strong>一个R中的tuple需要扫S表的所有数据，对于缓存池的利用率过低，这种方法开销太大</strong></li>
<li>S每次都是先灌满缓存池，然后前面的页淘汰，如此反复</li>
</ul>
</li>
<li>
<p>Assume</p>
<ul>
<li>
<p>M pages in table R, m tuples in R</p>
</li>
<li>
<p>N pages in table S, n tuples in S</p>
</li>
</ul>
</li>
<li>
<p>Cost: $M+(m \times N)$</p>
</li>
<li>
<p>优化：高效利用缓存池，一次多加载一些页，不要一页一页加载</p>
</li>
<li>
<p><strong>Block Nested Loop Join</strong></p>
</li>
<li>
<p>伪代码</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="line"><span class="cl"><span class="k">foreach</span> <span class="n">block</span> <span class="n">B_R</span> <span class="k">in</span> <span class="n">R</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">foreach</span> <span class="n">block</span> <span class="n">B_S</span> <span class="k">in</span> <span class="n">S</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">foreach</span> <span class="n">tuple</span> <span class="n">r</span> <span class="k">in</span> <span class="n">B_R</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">foreach</span> <span class="n">tuple</span> <span class="n">s</span> <span class="k">in</span> <span class="n">B_S</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="n">r</span> <span class="n">and</span> <span class="n">s</span> <span class="n">match</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">emit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>每次不只读一页，每次R和S都读好多页进行匹配</p>
</li>
<li>
<p>Cost: $M+(\frac{M}{M\ Block\ Size} \times N)$</p>
</li>
<li>
<p>讨论block size</p>
</li>
<li>
<p>B个页的内存，一个页做输出缓存，一个页给右表，多缓存左表(给B-2个)</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="line"><span class="cl"><span class="k">foreach</span> <span class="n">B</span><span class="p">-</span><span class="m">2</span> <span class="n">blocks</span> <span class="n">B_R</span> <span class="k">in</span> <span class="n">R</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">foreach</span> <span class="n">block</span> <span class="n">B_S</span> <span class="k">in</span> <span class="n">S</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">foreach</span> <span class="n">tuple</span> <span class="n">r</span> <span class="k">in</span> <span class="n">B</span><span class="p">-</span><span class="m">2</span> <span class="n">blocks</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">foreach</span> <span class="n">tuple</span> <span class="n">s</span> <span class="k">in</span> <span class="n">B_S</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="n">r</span> <span class="n">and</span> <span class="n">s</span> <span class="n">match</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">emit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>Cost: $M+(\frac{M}{B-2}\times N)$</p>
</li>
<li>
<p>if $B-2&gt;M$, then cost: $M+N$</p>
</li>
<li>
<p>为啥nested loop join性能不行</p>
<ul>
<li>总要去遍历S表</li>
<li>为啥要遍历：<strong>没有索引等其他方案来提高查找S中属性的效率，所以只能傻瓜式的遍历</strong></li>
</ul>
</li>
<li>
<p>优化思路：提高S中查找/范围查找的速度</p>
</li>
<li>
<p><strong>Index Nested Loop Join</strong></p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="line"><span class="cl"><span class="k">foreach</span> <span class="n">tuple</span> <span class="n">r</span> <span class="k">in</span> <span class="n">R</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">foreach</span> <span class="n">tuple</span> <span class="n">S</span> <span class="k">in</span> <span class="n">Index</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">==</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">r</span> <span class="n">and</span> <span class="n">s</span> <span class="n">match</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">emit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>认为每次索引查询需要C次I/O</p>
</li>
<li>
<p>Cost: $M+(m\times C)$</p>
</li>
</ul>
<h3 id="sort-merge-join">Sort-Merge Join</h3>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter11-3.png" title="/img/CMU 15-445 Database Systems/chapter11-3.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter11-3.png" data-sub-html="<h2>先对Join的列进行排序，后面就是合并多个有序数组的思路</h2>">
        
    </a><figcaption class="image-caption">先对Join的列进行排序，后面就是合并多个有序数组的思路</figcaption>
    </figure>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter11-4.png" title="/img/CMU 15-445 Database Systems/chapter11-4.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter11-4.png" data-sub-html="<h2>匹配中可能会漏掉匹配项，必须要加上回退的功能</h2>">
        
    </a><figcaption class="image-caption">匹配中可能会漏掉匹配项，必须要加上回退的功能</figcaption>
    </figure>
<ul>
<li>
<p>Cost</p>
<ul>
<li>
<p>Sort R: $2M \times (1+\log_{B-1}\frac{M}{B})$</p>
</li>
<li>
<p>Sort S: $2N\times (1+\log_{B-1}\frac{N}{B})$</p>
</li>
<li>
<p>Merge Cost: $M+N$</p>
</li>
<li>
<p>Total Cost: $Sort + Merge$</p>
</li>
</ul>
</li>
<li>
<p>退化情况：两个连接列所有值一样，那么Merge Cost会因为回退增加到$M\times N$</p>
</li>
<li>
<p>适合的场景</p>
<ul>
<li>数据本身就有序</li>
<li>输出的结果需要排序</li>
</ul>
</li>
</ul>
<h3 id="hash-join">Hash Join</h3>
<ul>
<li>Hash table点查询比B+ Tree快
<ul>
<li>左表做hash，右表去匹配</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">build</span> <span class="nb">hash</span> <span class="n">table</span> <span class="n">HT_R</span> <span class="k">for</span> <span class="n">R</span>
</span></span><span class="line"><span class="cl"><span class="n">foreach</span> <span class="nb">tuple</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">S</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">h1</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">in</span> <span class="n">HT_R</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">output</span>
</span></span></code></pre></td></tr></table>
</div>
</div><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter11-5.png" title="/img/CMU 15-445 Database Systems/chapter11-5.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter11-5.png" data-sub-html="<h2>给左表做哈希表，右表的数据hash完成后去哈希表里面找匹配数据</h2>">
        
    </a><figcaption class="image-caption">给左表做哈希表，右表的数据hash完成后去哈希表里面找匹配数据</figcaption>
    </figure>
<ul>
<li>
<p>Hash</p>
<ul>
<li>Key:需要连接的列</li>
<li>Value
<ul>
<li>Full Tuple:放上需要的数据，不需要回表</li>
<li>Tuple Identifier:放索引，最后需要去回表拿数据</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>OPTIMIZATION</strong></p>
<ul>
<li>Create a probe filter (such as a Bloom Filter) during the build phase if the key is likely to not exist in the inner relation 加上一层过滤器先过滤掉部分没有匹配项的数据，防止在哈希表里面找半天发现没有，比如加一个布隆过滤器</li>
</ul>
</li>
<li>
<p>如果哈希表太大可能会面临内存池驱逐的问题，但是我们不想让内存池随机驱逐</p>
</li>
<li>
<p><strong>Grace Hash Join</strong></p>
<ul>
<li>
<p>1980’s东京大学搞数据库一体机的时候发明的（现在也有一体机，比如Oracle还在卖），银行和金融机构爱买</p>
</li>
<li>
<p>左表和右表都做hash，把哈希表存在硬盘里面，把硬盘里面相对应的哈希桶拿出来做nested loop join</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter11-6.png" title="/img/CMU 15-445 Database Systems/chapter11-6.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter11-6.png" data-sub-html="<h2>能连接上的行都在一个桶号里面，所以每次都加载两个哈希表里面相同桶号的桶</h2>">
        
    </a><figcaption class="image-caption">能连接上的行都在一个桶号里面，所以每次都加载两个哈希表里面相同桶号的桶</figcaption>
    </figure>
</li>
<li>
<p>如果哈希桶还是太大怎么办，再换别的哈希函数继续哈希，直到哈希出来的块够小（这个叫<strong>RECURSIVE PARTITIONING</strong>）</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter11-7.png" title="/img/CMU 15-445 Database Systems/chapter11-7.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter11-7.png" data-sub-html="<h2>RECURSIVE PARTITIONING</h2>">
        
    </a><figcaption class="image-caption">RECURSIVE PARTITIONING</figcaption>
    </figure>
</li>
</ul>
</li>
<li>
<p>Cost</p>
<ul>
<li>Partition Phash:$2(M+N)$(读到内存hash后还要写回去)</li>
<li>Probing Phash:$M+N$</li>
<li>Total:$3(M+N)$</li>
</ul>
</li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter11-8.png" title="/img/CMU 15-445 Database Systems/chapter11-8.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter11-8.png" data-sub-html="<h2>各方法开销</h2>">
        
    </a><figcaption class="image-caption">各方法开销</figcaption>
    </figure>
<ul>
<li>Sorting和Hash没有最好，要看条件选择
<ul>
<li>哈希碰撞，输出是否有序都会影响开销</li>
<li>优秀的数据库会有优化器来进行分析和选择</li>
</ul>
</li>
</ul>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #10: Sorting &amp; Aggregation Algorithms</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter10/</link>
    <pubDate>Thu, 11 Apr 2024 19:21:30 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter10/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-10-sorting--aggregation-algorithms">Lecture #10: Sorting &amp; Aggregation Algorithms</h2>
<h3 id="query-plan">Query Plan</h3>
<ul>
<li>
<p>从本节课开始将讨论DBMS的Operator Execution</p>
</li>
<li>
<p>优化器会把SQL变成一棵执行树，递归式的向上执行</p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter10-1.png" title="/img/CMU 15-445 Database Systems/chapter10-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter10-1.png" data-sub-html="<h2>执行树</h2>">
        
    </a><figcaption class="image-caption">执行树</figcaption>
    </figure>
<ul>
<li>本课DBMS的特点：内存没法一次处理全部数据，会OOM，往往需要把中间结果也给写回到磁盘，磁盘和内存要相互配合，要最大化利用连续I/O，减少随机I/O的压力</li>
</ul>
<h3 id="sorting">Sorting</h3>
<ul>
<li>
<p><strong>External merge sort</strong></p>
<ul>
<li>排的是硬盘里面的数据，而不是像往常那样排内存里面的数据</li>
<li>代表：MySQL</li>
<li>Phase #1 – Sorting: First, the algorithm sorts small chunks of data that fit in main memory, and then writes the sorted pages back to disk.</li>
<li>Phase #2 – Merge: Then, the algorithm combines the sorted runs into larger sorted runs.</li>
</ul>
</li>
<li>
<p>两种&lt;Key,Value&gt;的模式</p>
<ul>
<li>Early Materialization:&lt;Key,Tuple&gt;，直接存储的就是数据</li>
<li>Late Materialization:&lt;Key,Record id&gt;，需要回表</li>
</ul>
</li>
<li>
<p><strong>Two-way Merge Sort</strong></p>
<ul>
<li>N个页的大表，缓存池最多能承受B个页的容量</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter10-2.png" title="/img/CMU 15-445 Database Systems/chapter10-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter10-2.png" data-sub-html="<h2>把每页加载到内存后排序，然后把排序好的数据写回磁盘，最后再归并刚才写回磁盘的那些有序页</h2>">
        
    </a><figcaption class="image-caption">把每页加载到内存后排序，然后把排序好的数据写回磁盘，最后再归并刚才写回磁盘的那些有序页</figcaption>
    </figure></li>
<li>排序好的数据不是全部一把进到内存（那又该爆内存了，可以轮询着进，因为合并有序数组本来就是轮询比较的（参考力扣里面的题目））</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter10-3.png" title="/img/CMU 15-445 Database Systems/chapter10-3.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter10-3.png" data-sub-html="<h2>多个页的情况</h2>">
        
    </a><figcaption class="image-caption">多个页的情况</figcaption>
    </figure></li>
<li>优化：一次I/O不要只读一页，尽最大可能多读几页</li>
</ul>
</li>
<li>
<p><strong>General (K-way) Merge Sort</strong></p>
<ul>
<li>二路归并变成K路归并，一次比如读N/B个页，然后进行排序，Merge的轮数会少很多，这样效率会提高很多</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Using B+Trees</strong>
<ul>
<li>直接利用B+ Tree的有序性</li>
<li>要考虑聚簇还是非聚簇，因为聚簇的话关系到Early Materialization的问题，可以省去回表的过程，提高效率</li>
</ul>
</li>
</ul>
<h3 id="aggregations">Aggregations</h3>
<ul>
<li>
<p><strong>Sorting</strong></p>
<ul>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter10-4.png" title="/img/CMU 15-445 Database Systems/chapter10-4.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter10-4.png" data-sub-html="<h2>过滤，排序，去重</h2>">
        
    </a><figcaption class="image-caption">过滤，排序，去重</figcaption>
    </figure></li>
</ul>
</li>
<li>
<p><strong>Hashing</strong></p>
<ul>
<li>
<p>如果不要求有序可以用Hashing来提高效率</p>
</li>
<li>
<p><strong>External Hashing aggregations</strong></p>
</li>
<li>
<p><strong>Phase #1 – Partition</strong></p>
<ul>
<li>先给要Agg的字段做一个哈希表，然后把这个哈希表写回到磁盘里面</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter10-5.png" title="/img/CMU 15-445 Database Systems/chapter10-5.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter10-5.png" data-sub-html="<h2>把需要Agg的字段做第一次哈希，相同的值&#43;碰撞的都放在一个桶</h2>">
        
    </a><figcaption class="image-caption">把需要Agg的字段做第一次哈希，相同的值+碰撞的都放在一个桶</figcaption>
    </figure></li>
</ul>
</li>
<li>
<p><strong>Phase #2 – ReHash</strong>:把磁盘里面的哈希表再加载到内存中，读进去之后再做第二次哈希，这样就把碰撞的值也分开了，这样就生成了第二次的哈希表，也就是最终结果</p>
<ul>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter10-6.png" title="/img/CMU 15-445 Database Systems/chapter10-6.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter10-6.png" data-sub-html="<h2>二次哈希解决了哈希碰撞，也就拿到了最终结果</h2>">
        
    </a><figcaption class="image-caption">二次哈希解决了哈希碰撞，也就拿到了最终结果</figcaption>
    </figure></li>
</ul>
</li>
<li>
<p><strong>Hashing summarization</strong></p>
<ul>
<li>During the rehash phase, store pairs of the form (GroupKey→RunningVal) 如果说需要对值进行计算(count,sum等)，那么在hash的过程中也要带上其他需要的数值，这部分叫RunningVal</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter10-7.png" title="/img/CMU 15-445 Database Systems/chapter10-7.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter10-7.png" data-sub-html="<h2>带上需要的数据进行聚合类函数的计算</h2>">
        
    </a><figcaption class="image-caption">带上需要的数据进行聚合类函数的计算</figcaption>
    </figure></li>
</ul>
</li>
</ul>
</li>
<li>
<p>Sorting和Hashing没有绝对的好，要看条件，比如前置的数据有没有做了排序或者哈希，需要的结果到底要不要进行排序</p>
</li>
<li>
<p>优化的思路</p>
<ul>
<li>随机I/O尽量变成连续I/O:一次写入页的数量尽量多</li>
<li>预加载:能先加载到内存中的数据都先加载到内存中</li>
</ul>
</li>
</ul>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #09: Index Concurrency Control</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter9/</link>
    <pubDate>Thu, 11 Apr 2024 13:34:01 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter9/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-09-index-concurrency-control">Lecture #09: Index Concurrency Control</h2>
<h3 id="index-concurrency-control">Index Concurrency Control</h3>
<ul>
<li>
<p>前面讨论都默认是单线程条件下，但是对于DBMS这种主要问题在I/O上面的系统来说，肯定要上多线程，异步这些来提高效率，那么如何在这种条件下保证索引的线程安全很重要了</p>
</li>
<li>
<p>其他数据库的一些处理方法</p>
<ul>
<li>内存型NoSQL:直接单线程模式运行，比如Redis</li>
</ul>
</li>
<li>
<p>本节课主要研究<strong>Physical Correctness</strong>，关注底层设计</p>
</li>
</ul>
<h3 id="locks-vs-latches">Locks vs. Latches</h3>
<ul>
<li>和前面的课讨论的一样，一个逻辑锁，一个底层锁</li>
<li>死锁和回滚都是建立在Locks上面的</li>
<li>Latches这个锁要划分为读锁和写锁
<ul>
<li>多个线程可以同时去读一个变量，相应的读锁可以重入其他线程的读锁，但是其他线程不能写(也叫共享锁)</li>
<li>一个线程写数据的时候，其他线程不能读和写这个数据，所以写锁一般不可重入其他线程的锁(也叫独占锁)</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter9-1.png" title="/img/CMU 15-445 Database Systems/chapter9-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter9-1.png" data-sub-html="<h2>Locks和Latches的区别</h2>">
        
    </a><figcaption class="image-caption">Locks和Latches的区别</figcaption>
    </figure>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter9-1.png" title="/img/CMU 15-445 Database Systems/chapter9-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter9-1.png" data-sub-html="<h2>兼容矩阵</h2>">
        
    </a><figcaption class="image-caption">兼容矩阵</figcaption>
    </figure>
<h3 id="latch-implementations">Latch Implementations</h3>
<ul>
<li><strong>Blocking OS Mutex</strong>
<ul>
<li>simple to use(操作系统自己支持)</li>
<li>Non-scalable (about 25ns per lock/unlock invocation)，大规模使用不行，这东西效率太低</li>
<li>Example: std::mutex$\rightarrow$pthread_mutex$\rightarrow$futex</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">m</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Do something special...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">m</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>底层实现:内存中分配出来一个变量来获取锁，要锁的程序就把这个变量设置值，如果发现锁被夺取，这个线程就直接进入内核态自己sleep，如果锁被释放操作系统会试着唤醒sleep的线程
<ul>
<li>好处：竞争的线程拿不到锁直接sleep，不会额外消耗系统的资源</li>
<li>坏处：sleep和notify在操作系统层面上面很浪费资源（线程链表的调整）</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Test-and-Set Spin Latch (TAS)</strong></li>
<li>也叫自旋锁</li>
<li>Very efficient (single instruction to latch/unlatch)</li>
<li>Non-scalable, not cache friendly, not OS friendly.大规模用效率上也不行，自旋也很笨</li>
<li>Example: std::atomic&lt;T&gt;</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">atomic_flag</span> <span class="n">latch</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">while</span> <span class="p">(</span><span class="n">latch</span><span class="p">.</span><span class="n">test_and_set</span><span class="p">(</span><span class="err">…</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// Retry? Yield? Abort?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>检测和设置这一组操作必须要是原子的</p>
</li>
<li>
<p>自旋锁对于CPU的开销很大（一直空转）</p>
</li>
<li>
<p>很多语言会把TAS和Blocking结合，自旋一阵子不行就去睡一会</p>
</li>
</ul>
<hr>
<ul>
<li><strong>Atomic Instruction Example: compare-and-swap (CAS)</strong>
<ul>
<li>
<p>Atomic instruction that compares contents of a memory location M to a given value V</p>
<ul>
<li>If values are equal, installs new given value V’ in M</li>
<li>Otherwise, operation fails</li>
</ul>
</li>
<li>
<p>这个东西是CPU的一条指令，由CPU来保证原子性</p>
</li>
<li>
<p>经常作为自旋锁或者JUC的包里面的一些锁底层的实现</p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Reader-Writer Latches</strong>
<ul>
<li>Allows for concurrent readers. Must manage read/write queues to avoid starvation.</li>
<li>Can be implemented on top of spinlocks</li>
<li>Example: std::shared_mutex $\rightarrow$ pthread_rwlock</li>
</ul>
</li>
</ul>
<h3 id="hash-table-latching">Hash Table Latching</h3>
<ul>
<li>
<p>好加锁，无论是桶还是开放地址哈希，大家查找的方向是一致的，并且一次只能访问一个页/槽，这点上出不了死锁(当然HashMap的头插法可能会出，不过这个和链表的结构有关)，向其他搜索方向不一致的B+ Tree可能就会出死锁</p>
</li>
<li>
<p>如果要调整容量，一般把整个哈希表都给加上全局的写锁</p>
</li>
<li>
<p>其他情况下一般锁部分就可以了</p>
<ul>
<li>
<p><strong>Page/Block-level Latches</strong></p>
<ul>
<li>Each page/block has its own reader-writer latch that protects its entire contents.</li>
<li>Threads acquire either a read or write latch before they access a page/block</li>
<li>按块划分，加锁</li>
<li>Java的ConcurrentHashMap是这种处理方案，几个槽一个锁</li>
<li>好处：不用维护太多锁，还保证了并发性</li>
</ul>
</li>
<li>
<p><strong>Slot Latches</strong></p>
<ul>
<li>一个槽加一个锁</li>
<li>锁更细了，更能避免死锁和提高并发</li>
<li>但是维护这么多锁开销太高了</li>
</ul>
</li>
<li>
<p>还有其他方法，比如读写分离（比如go的sync.Map）</p>
</li>
</ul>
</li>
</ul>
<h3 id="btree-latching">B+Tree Latching</h3>
<ul>
<li>两方面的并发问题
<ul>
<li>节点内部的数据要做并发保护</li>
<li>节点的分裂/合并过程中要做并发保护</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p><strong>Latch Crabbing/Coupling</strong></p>
<ul>
<li>
<p>Get latch for parent，给根节点上锁</p>
</li>
<li>
<p>Get latch for child，给子节点上锁</p>
</li>
<li>
<p>Release latch for parent if “safe”，判断子节点是否“安全”，安全的话放根节点的锁</p>
</li>
<li>
<p>“safe”:A <strong>safe node</strong> is one that will not split or merge when updated.</p>
</li>
</ul>
</li>
<li>
<p>Find: Start at root and traverse down the tree</p>
<ul>
<li>Acquire R latch on child</li>
<li>Then unlatch parent</li>
<li>Repeat until we reach the leaf node</li>
</ul>
</li>
<li>
<p>Insert/Delete: Start at root and go down, obtaining W latches as needed. Once child is latched, check if it is safe:</p>
<ul>
<li>If child is safe, release all latches on ancestors</li>
</ul>
</li>
<li>
<p>问题：所有的操作都要先锁根节点，这是一个性能上面的瓶颈</p>
<ul>
<li>原因：上面的想法是悲观的，认为每次写操作都有可能会造成根节点的分裂/合并，但是实际上来说根节点变动的次数很少</li>
<li>使用乐观的想法：我认为大部分操作不会改变根节点的结构，所以我给根节点加读锁，如果说发现根节点要变动结构，这个时候从根节点重新给加写锁</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Leaf Node Scans</strong>
<ul>
<li>一般来说是顺序扫描</li>
<li>但是这样会带来一个风险:Find key &gt; 4和Find key &lt; 1扫描叶子节点的时候方向是相反的，会有死锁的风险</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter9-3.png" title="/img/CMU 15-445 Database Systems/chapter9-3.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter9-3.png" data-sub-html="<h2>方向相反造成死锁</h2>">
        
    </a><figcaption class="image-caption">方向相反造成死锁</figcaption>
    </figure></li>
<li>解决方法：<strong>制定规则</strong>，比如数据只能从大往小走，比如MySQL，之前不支持倒序遍历就和这个有关，后面又加上了倒叙索引才解决了这个问题</li>
</ul>
</li>
</ul>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #08: Tree Indexes</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter8/</link>
    <pubDate>Wed, 10 Apr 2024 15:53:39 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter8/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-08-tree-indexes">Lecture #08: Tree Indexes</h2>
<h3 id="table-indexes">Table Indexes</h3>
<ul>
<li>数据库中常常需要数据库的部分有序(这也是为什么哈希表做不成索引，因为无序)副本来提高查找的效率，这个副本一般称为索引</li>
<li>DBMS要自己维护索引和数据的一致性，还有执行SQL的时候使用什么索引</li>
</ul>
<h3 id="b-tree">B+ Tree</h3>
<ul>
<li>B+ Tree是一种自平衡搜索树，它可以将查找的复杂度控制在$O(logn)$，同时它的设计也减小了查找时磁盘的$I/O$，这对于DBMS的效率来说是十分重要的</li>
<li>几乎所有支持索引的现代DBMS都用了B+ Tree，B+ Tree和B Tree最大的区别在于B+ Tree之有叶子节点才存储了值，非叶子节点存储的是部分索引的值，而B Tree的每个节点都存储了值</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter8-1.png" title="/img/CMU 15-445 Database Systems/chapter8-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter8-1.png" data-sub-html="<h2>B&#43; Tree还借鉴了其他B Tree类数据结构的特性，比如从B-Link-Tree中学到的sibling pointers</h2>">
        
    </a><figcaption class="image-caption">B+ Tree还借鉴了其他B Tree类数据结构的特性，比如从B-Link-Tree中学到的sibling pointers</figcaption>
    </figure>
<ul>
<li>
<p>B+ Tree有以下特点</p>
<ul>
<li>它是完全平衡的（所有的叶子节点高度一致）</li>
<li>除了根节点外，每个内部节点至少为半满($\frac{M}{2}-1 \le num\ of\ keys \le M -1$)</li>
<li>每个有K个键的节点有K+1个非空子节点（指针是从两个key中间的“缝”出来的）</li>
</ul>
</li>
<li>
<p>B+ Tree的每个节点都包含一个Key-Value的数组&lt;索引值，下层的节点&gt;</p>
</li>
<li>
<p>B+ Tree的叶子节点有两种存储模式</p>
<ul>
<li>一种是存储Tuple的指针，通过这个指针去拿Tuple的数据</li>
<li>另一种是存储Tuple的数据，这样就可以直接获取，不用再去找一次Tuple的数据</li>
</ul>
</li>
<li>
<p>根据NULL在不同类型中的意义，NULL节点一般会在第一个或最后一个叶子节点里面（要看对NULL认为是无穷大的还是无穷小的）</p>
</li>
</ul>
<hr>
<ul>
<li><strong>Insertion</strong>
<ul>
<li>向下遍历树，找到插入的位置</li>
<li>如果索引有足够的空间，则直接插入</li>
<li>否则最下面的索引分裂，然后重新整合B+ Tree的结构后再插入</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Deletion</strong>
<ul>
<li>如果删除后的节点少于半满，需要合并树</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Composite Index</strong>
<ul>
<li>多个属性组成的联合索引</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="n">abc_index</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="k">c</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>我们可以使用联合索引来加快查询速度</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="k">c</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="k">table</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="k">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p><strong>Selection Conditions</strong></p>
<ul>
<li>要看联合索引的结构，是前面的字段先有序之后再排下一个字段，要想高效利用联合索引就要会最左匹配</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Duplicate Keys</strong>:重复索引的处理方法
<ul>
<li><strong>append record IDs</strong>:后面加上唯一标识符。比如主键或者(page,slot)的元组，这样就保证绝对唯一</li>
<li><strong>overflow nodes</strong>:给叶子节点再挂一个溢出节点，专门放碰撞的Key，但是增加了维护树结构的成本</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Clustered Indexes</strong>
<ul>
<li>主键B+ Tree的叶子节点对应的数据就是实际数据，这样遍历到主键的话直接就拿到数据</li>
<li>但是如果不是主键的B+ Tree的话，只能先拿到主键再去主键的B+ Tree上面找</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Index Scan Page Sorting</strong>
<ul>
<li>先扫描统计要那些主键对应的数据，再把数据做一次排序 ,然后进主键的B+ Tree一把搜出来</li>
</ul>
</li>
</ul>
<h3 id="btree-design-choices">B+Tree Design Choices</h3>
<ul>
<li><strong>Node size</strong>
<ul>
<li>磁盘越慢，B+ Tree的节点越大，这样减少I/O的压力，如果是内存，节点应该变小，因为这个时候筛选无用数据的成本已经高过磁盘中的I/O了
<ul>
<li>HDD: ~1MB</li>
<li>SSD: ~10KB</li>
<li>In-Memory: ~512B</li>
</ul>
</li>
<li>还有就是业务类型，OTAP喜欢点查询，节点小一点好，OLAP喜欢动不动扫描全表，节点大一点好</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Merge Threshold</strong>
<ul>
<li>一般来说合并拆分这种操作DBMS都是尽量拖一拖，因为这个过程开销太大了，所以不是到了阈值就马上合并</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Variable Length Keys</strong>
<ul>
<li>pointers:节点存指针</li>
<li>Variable Length Nodes:节点本身就是变长的，维护更加困难</li>
<li>Padding:数据不到规定大小，填充字节补偿(像字节对齐)</li>
<li>Key Map/Indirection:和slot很像，里面的结构加上slot-array来适应不同长度的数据</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Intra-Node Search</strong>
<ul>
<li>节点内部的数据怎么搜索
<ul>
<li><strong>Linear</strong>:线性遍历，看似低效，但是和I/O的时间比起来不算什么</li>
<li><strong>Binary</strong>:二分，复杂度降为$O(log(n))$</li>
<li><strong>Interpolation</strong>:利用数学规律/机器学习等其他方式进行推断查找</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="optimizations">Optimizations</h3>
<ul>
<li>
<p><strong>Prefix Compression</strong></p>
<ul>
<li>
<p>找前缀一样的统一存一下前缀，剩下的空间存后缀</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter8-2.png" title="/img/CMU 15-445 Database Systems/chapter8-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter8-2.png" data-sub-html="<h2>前缀压缩的例子</h2>">
        
    </a><figcaption class="image-caption">前缀压缩的例子</figcaption>
    </figure>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Deduplication</strong>
<ul>
<li>一个K，后面根据所有的V，防止K冗余</li>
<li>$(K_1,V_1),(K_1,V_2),(K_1,V_3),(K_2,V_4),(K_2,V_5) \rightarrow\ (K_1,V_1,V_2,V_3),(K_2,V_4,V_5)$</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Suffix Truncation</strong>
<ul>
<li>如果搜索的时候不要要全部数据往下走，只需要部分数据，那我存个前缀也行
<ul>
<li>比如string的like”x%”这种操作，存前缀就够了</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Bulk Insert</strong>
<ul>
<li>一次插入一批，减少树的分裂合并次数</li>
</ul>
</li>
</ul>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #07: Hash Tables</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter7/</link>
    <pubDate>Tue, 09 Apr 2024 21:11:32 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter7/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-07-hash-tables">Lecture #07: Hash Tables</h2>
<h3 id="data-structures">Data Structures</h3>
<ul>
<li>
<p>DBMS很多部分使用不同的数据结构</p>
<ul>
<li>Internal Meta-Data</li>
<li>Core Data Storage</li>
<li>Temporary Data Structures</li>
<li>Table Indices</li>
</ul>
</li>
<li>
<p>DBMS设计数据结构需要考虑两个方面</p>
<ul>
<li><strong>Data organization</strong>:数据结构应该怎么设计，什么数据应该存到那，从而保证有效的访问</li>
<li><strong>Concurrency</strong>:老话题，只要是DBMS上面的东西基本都要考虑并发安全</li>
</ul>
</li>
</ul>
<h3 id="hash-table">Hash Table</h3>
<ul>
<li>
<p>哈希表实现了一个Key $\rightarrow$ Value的关联数组，它提供了平均$O(1)$的操作复杂度（当然最差会是$O(n)$）和$O(n)$的存储复杂度，这理要注意的是$O(1)$是理论上面的，在现实中实现这个数据结构的时候要考虑常数因子的优化</p>
</li>
<li>
<p>哈希表的实现由两部分组成</p>
<ul>
<li>
<p><strong>Hash Function</strong>:如何将较大的值映射到一个较小的空间内，这里要注意碰撞率和计算耗时的关系</p>
<ul>
<li>计算越复杂，耗时越高，碰撞率越低</li>
<li>计算越简单，耗时越低，碰撞率越高</li>
<li>Hash Function理想的情况就是在计算耗时和碰撞率之间取得平衡</li>
</ul>
</li>
<li>
<p><strong>Hashing Scheme</strong>:考虑哈希冲突的时候的处理办法，在扩大哈希表减少冲突和发生冲突时处理方案的复杂性中取得平衡</p>
</li>
</ul>
</li>
</ul>
<h3 id="hash-functions">Hash Functions</h3>
<ul>
<li>
<p><strong>Hash Function</strong>接收的参数应该可以是任意类型的，然后返回一个整数，该函数的输出要是确定性的（相同的参数输出的值要一样）</p>
</li>
<li>
<p><strong>Hash Function</strong>一般不用网安那套加密安全哈希函数，因为不需要保护密钥的内容（这个东西只在DBMS内部使用，没有泄露的风险），我们只关心计算速度和碰撞率</p>
</li>
</ul>
<blockquote>
<p>The current state-of-the-art hash function is <a href="https://xxhash.com" target="_blank" rel="noopener noreffer">Facebook XXHash3</a>.</p>
</blockquote>
<h3 id="static-hashing-schemes">Static Hashing Schemes</h3>
<ul>
<li>
<p>对于一个固定容量的Hash table来说，如果容量满了再次扩容代价很大</p>
</li>
<li>
<p>一般扩容都是给扩容成原来的2倍</p>
</li>
<li>
<p>避免hash冲突是很重要的，一般我们期望元素数=槽数$\times$2</p>
</li>
</ul>
<hr>
<ul>
<li>
<p><strong>Linear Probe Hashing</strong></p>
<ul>
<li>
<p>碰到Hash冲突就把K-V存到下一个槽里面</p>
</li>
<li>
<p>如果下一个槽还碰撞就下下个槽，直到找到空位置</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter7-1.png" title="/img/CMU 15-445 Database Systems/chapter7-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter7-1.png" data-sub-html="<h2>碰撞的处理方法</h2>">
        
    </a><figcaption class="image-caption">碰撞的处理方法</figcaption>
    </figure>
</li>
<li>
<p>删除比较恶心</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter7-2.png" title="/img/CMU 15-445 Database Systems/chapter7-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter7-2.png" data-sub-html="<h2>D因为和C碰撞往下走，现在C被删了，结果查D发现D没有了，出现了错误</h2>">
        
    </a><figcaption class="image-caption">D因为和C碰撞往下走，现在C被删了，结果查D发现D没有了，出现了错误</figcaption>
    </figure>
</li>
<li>
<p>解决方案</p>
<ul>
<li>加上一个Tombstone标志，说明这个地方原来有数据，然后被删除了</li>
<li>Movement：把下边的数据往上挪，但是不能傻瓜式的向上推，hash值是对的就不能动</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Non-unique Keys</strong>:同一个键可能与多个不同的值或元组关联的情况，两种解决方案
<ul>
<li><strong>Separate Linked List</strong>:存储Value的不再是一个值，而是List&lt;V&gt;，这样就可以存储多个值了</li>
<li><strong>Redundant Keys</strong>:将Key和Value结合起来再做hash</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Optimizations</strong>
<ul>
<li><strong>Specialized hash table implementations based on the data type or size of keys</strong>:根据数据结构不同/键大小采取不同的措施，比如字符串，小的字符串我拷贝存一份，大的字符串我存指针或者哈希</li>
<li><strong>Storing metadata in a separate array</strong>:将空槽/墓碑数据集中存在一个bitmap里面，作为哈希表的头文件或者作为一个单独的哈希表，这样避免查找已经删除的键</li>
<li><strong>Maintaining versions for the hash table and its slots</strong>:在哈希表上面删除/分配内存代价很高，所以给哈希表的Value添加一个version字段，只要version不匹配就认为没有这个Value，删数据就不用释放内存了</li>
</ul>
</li>
</ul>
<blockquote>
<p>Google’s absl::flat hash map is a state-of-the-art implementation of Linear Probe Hashing.</p>
</blockquote>
<hr>
<ul>
<li><strong>Cuckoo Hashing</strong>
<ul>
<li>使用多个哈希表，每个哈希表使用的哈希函数整体一样，但是参数不同（就是设定的种子）</li>
<li>一旦发生哈希碰撞，就把原有的值使用别的哈希函数驱赶到别的哈希表中，如果被驱逐的值也发生哈希碰撞就重复上面的过程，直到没有哈希碰撞</li>
<li>使用的很少，现实中这种实现问题很大</li>
</ul>
</li>
</ul>
<h3 id="dynamic-hashing-schemes">Dynamic Hashing Schemes</h3>
<ul>
<li>
<p>如果不知道需要存储数据的量，那么就需要一个能够动态扩容的哈希表</p>
</li>
<li>
<p><strong>Chained Hashing</strong></p>
<ul>
<li>
<p>槽不再是单独的一个槽，而是变成了一个指针，指向一个“桶”，桶能存好多Value，一般也具备扩容的功能，有名的实现是Java的HashMap</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter7-3.png" title="/img/CMU 15-445 Database Systems/chapter7-3.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter7-3.png" data-sub-html="<h2>Chained Hashing模型</h2>">
        
    </a><figcaption class="image-caption"><strong>Chained Hashing</strong>模型</figcaption>
    </figure>
</li>
<li>
<p><strong>Bloom Filters</strong>:布隆过滤器，Redis有讲，用来先过滤一遍不存在的数据</p>
</li>
</ul>
</li>
<li>
<p><strong>Extendible Hashing</strong>:这个也和Java的HashMap思想很像，2的幂次方扩容，每次扩容重排桶中的数据，计算hash的时候因为是2的幂次所以可以用位运算，每次扩容就是参与运算的二进制位变多了一位</p>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter7-4.png" title="/img/CMU 15-445 Database Systems/chapter7-4.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter7-4.png" data-sub-html="<h2>扩容前</h2>">
          
      </a><figcaption class="image-caption">扩容前</figcaption>
      </figure>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter7-5.png" title="/img/CMU 15-445 Database Systems/chapter7-5.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter7-5.png" data-sub-html="<h2>扩容后</h2>">
          
      </a><figcaption class="image-caption">扩容后</figcaption>
      </figure>
</li>
<li>
<p><strong>Linear Hashing</strong></p>
<ul>
<li>
<p>之前的扩容是按照2的幂次扩容，扩容一次需要的代价很大，需要用户等待很多时间</p>
</li>
<li>
<p><strong>Linear Hashing</strong>希望扩容不要那么猛，一点一点慢慢扩容</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter7-6.png" title="/img/CMU 15-445 Database Systems/chapter7-6.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter7-6.png" data-sub-html="<h2>由size = 4扩容到size = 5，分家指针向下移动一位，分家指针上面的槽用旧哈希函数x%n，分家指针下面的槽用新哈希函数x%2n</h2>">
        
    </a><figcaption class="image-caption">由size = 4扩容到size = 5，分家指针向下移动一位，分家指针上面的槽用旧哈希函数x%n，分家指针下面的槽用新哈希函数x%2n</figcaption>
    </figure>
</li>
<li>
<p>分家指针指向原来的槽末尾再扩容就会回到0，此时一轮的扩容已经完成</p>
</li>
</ul>
</li>
</ul>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #06: Buffer Pools</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter6/</link>
    <pubDate>Mon, 08 Apr 2024 20:02:45 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter6/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-06-buffer-pools">Lecture #06: Buffer Pools</h2>
<h3 id="introduction">Introduction</h3>
<ul>
<li>DBMS需要负责管理数据在内存和磁盘之间移动，大多数情况下数据不能在磁盘中被处理，而是需要加载到内存中，处理完成后再写回磁盘，这个过程就需要Buffer Pools来进行管理，使得DBMS的其他部分可以像在内存中处理所有数据那样进行操作</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter6-1.png" title="/img/CMU 15-445 Database Systems/chapter6-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter6-1.png" data-sub-html="<h2>Buffer Pool模型</h2>">
        
    </a><figcaption class="image-caption">Buffer Pool模型</figcaption>
    </figure>
<ul>
<li>一个DBMS需要考虑下面的两个方面
<ul>
<li><strong>Spatial Control</strong>: refers to where pages are physically written on disk. The goal of spatial control is to keep pages
that are used together often as physically close together as possible on disk to possibly help with prefetching and
other optimizations.(写磁盘的时候把需要经常一起用的页尽量写到磁盘的一块地方，这样下次用也能够一把加载到Buffer Pool里面)</li>
<li><strong>Temporal Control</strong>: is deciding when to read pages into memory and when to write them to disk. Temporal control
aims to minimize the number of stalls from having to read data from disk.(何时写回磁盘，对于一些热点写数据没有必要写一次刷一次盘，完全可以写好多次刷一次磁盘，因为刷盘的代价太大了)</li>
</ul>
</li>
</ul>
<h3 id="locks-vs-latches">Locks vs. Latches</h3>
<ul>
<li>
<p>英语和概念性的问题</p>
</li>
<li>
<p><strong>Locks</strong>: A lock is a higher-level, logical primitive that protects the contents of a database (e.g., tuples, tables, databases)
from other transactions. Database systems can expose to the user which locks are being held as queries are run. Locks
need to be able to roll back changes.(逻辑上面的锁，比如行锁/表锁/库锁，不关心底层实现，用于理论上面的讨论，为了防止死锁，一般这种锁都可以回滚)</p>
</li>
<li>
<p><strong>Latches</strong>: A latch is a low-level protection primitive that the DBMS uses for the critical sections in its internal data
structures (e.g., hash tables, regions of memory). Latches are held for only the duration of the operation being made.
Latches do not need to be able to roll back changes. This is often implemented by simple language primitives like
mutexs and/or conditional variables.(Locks的具体实现，比如数据竞争的区域是哪，用互斥锁还是信号量，悲观锁还是乐观锁)</p>
</li>
</ul>
<h3 id="buffer-pool">Buffer Pool</h3>
<ul>
<li>
<p>It is organized as an array of fixed-size pages. Each array entry is called a frame. 缓存池的本质就是内存里面的一块固定的数组，这个里面的一个元素就叫frame了，但是其实和page是一个东西</p>
</li>
<li>
<p><strong>page directory</strong>:在数据库的磁盘上还维护了一个page directory，这个东西存的就是页id到页在磁盘物理位置的映射，所以说这个如果修改了必须写回到磁盘上，这样DBMS重新启动的时候才能找到，他也通常回一直在内存里面，因为你找页必须要先通过page directory去找页的物理位置</p>
</li>
<li>
<p><strong>Buffer Pool Meta-data</strong>:缓存池必须要存储一些meta-data，从而保证正确性和提高缓存池的效率，常见的一些meta-data</p>
<ul>
<li>
<p><strong>page table</strong>:这个是内存中的一个hash表，它的映射是页面id $\rightarrow$ 这个页在缓存池中的帧位置，因为页在缓存池里面的顺序和磁盘中的顺序往往不一致，所以需要page table来做这个额外的间接层，除了页在缓存池中的位置，page table还维护了其他meta-data，比如一个脏标志（说明这个页是不是脏页），引用计数器（有哪几个事务在用它），这个和page directory的一个大的区别就是他不用记在磁盘上</p>
</li>
<li>
<p><strong>dirty-flag</strong>:这个就是上面page table维护的一个页的meta-data之一，当有线程对buffer pool中的某个页面进行修改的时候这个标志会被设置，这提醒这个页在被踢出buffer pool的时候必须要刷盘</p>
</li>
<li>
<p><strong>Pin/reference counter</strong>:这个也是上面page table维护的一个页的meta-data之一，主要是记录有几个线程正在访问该页，线程必须在访问该页之前增加counter，如果counter &gt; 0，那么该页就无法被驱逐，counter不会管理并发事务那些东西，如果当前缓冲池的所有页都无法被踢，而且已经满了，就会抛出OOM(out-of-memory)的错误</p>
</li>
</ul>
</li>
<li>
<p><strong>Memory Allocation Policies</strong></p>
<ul>
<li>
<p>Memory in the database is allocated for the buffer pool according to two policies</p>
</li>
<li>
<p><strong>Global policies</strong>: 考虑所有事务，来找到分配内存的最佳决策</p>
</li>
<li>
<p><strong>local policies</strong>:做出决策的时候只考虑单个事务，即使他不适合整个工作负载，本地策略将帧分配给特定的事务，而不考虑并发事务的行为。但是，它仍然支持事务之间共享帧</p>
</li>
<li>
<p>Most systems use a combination of both global and local policies.</p>
</li>
</ul>
</li>
</ul>
<h3 id="buffer-pool-optimizations">Buffer Pool Optimizations</h3>
<ul>
<li>
<p><strong>Multiple Buffer Pools</strong></p>
<ul>
<li>DBMS可以开好多个缓冲池，比如按照类型分（索引缓冲池，数据缓冲池），同一类似使用hash再分到不同的区域，这样每个缓冲池都可以选择适合自己的存储策略，同时分成多个缓存池也避免了一个缓冲池频繁的锁竞争问题</li>
<li>Object IDs and hashing are two approaches to mapping desired pages to a buffer pool.
<ul>
<li><strong>Object IDs</strong>:维护一个id到缓存池区域的映射，这样根据页的id就能分配到对应的缓存池中，而且这个映射自己维护，你可以把分配的策略做的更细更智能，代价就是这个映射也是额外的内存开销</li>
<li><strong>hashing</strong>:对页的id做hash来确定到那块缓存池</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Pre-fetching</strong>: 根据查询计划来对预取页面进行优化，比如处理第一组页面的时候把第二组页面给预提取到缓冲池中（这个在顺序扫描的时候常用），在索引扫描的时候处理某个叶子页的时候可以把这个叶子页的下一页也预提取到缓冲池中，这都提高了效率（这个下一页都是逻辑上的，不是物理上的）</p>
</li>
<li>
<p><strong>Scan Sharing (Synchronized Scans)</strong>:尽量复用缓冲池里面的数据，比如第一个事务是SELECT ALL FROM A，第二个事务也是SELECT ALL FROM A，这个时候第一个事务把页3~6加载到缓冲池里面了，那第二个事务可以从这个地方跟着第一个事务开始扫，等把后面那些跟着第一个事务扫完之后再去扫前面的表，或者说这个时候有SELECT ALL FROM A LIMIT 100这种事务，可以直接到缓冲池里面找一张表拿100条数据就走（这也是为什么每次查询结果不一样的原因）</p>
</li>
<li>
<p><strong>Buffer Pool Bypass</strong>:全表扫描（可能加SORT），大型JOIN这种东西大概率这次查询完了之后近期不会再差，这种数据除了查询时加载到内存中查询完了就扔出去，来节约缓冲池的资源</p>
</li>
</ul>
<h3 id="buffer-replacement-policies">Buffer Replacement Policies</h3>
<ul>
<li>
<p>要求是准确+快+开销小</p>
</li>
<li>
<p><strong>COLCK</strong>:时钟轮询，如果有frame被访问过给打上标记，时钟循环看每一帧，有标记的清空标记，没有标记证明最近没人访问你，给踢出</p>
</li>
<li>
<p><strong>LRU/LRU-K</strong>:看这两篇就够了</p>
<ul>
<li>
<p><a href="https://jungle430.github.io/posts/cmu-15-445-database-systems/lru_and_lru-k/" target="_blank" rel="noopener noreffer">《LRU and LRU-K》</a></p>
</li>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/622224538" target="_blank" rel="noopener noreffer">《CMU 15-445 P1 LRU-K Replacement Policy》</a></p>
</li>
</ul>
</li>
<li>
<p><strong>localization per query</strong>:驱逐页只驱逐自己事务相关的，防止把其他事务的页给驱逐</p>
</li>
<li>
<p><strong>priority hints</strong>:给一些页上标记，告诉缓存池这页不要随便清理，比如索引的根节点，这种东西轻易不会清理</p>
</li>
<li>
<p><strong>Dirty Pages</strong>:踢出页的时候页是否是脏页对于踢出页时候的处理不一样</p>
<ul>
<li>非脏页：直接删除就行</li>
<li>脏页：要刷回磁盘，当然能写不回去就尽量先不写回去（后面会讲WAL，redo-log），一定要先写回再踢出</li>
</ul>
</li>
</ul>
<h3 id="disk-io-and-os-cache">Disk I/O and OS Cache</h3>
<ul>
<li>操作系统本身也有cache的管理，但是和DBMS要求的差的很多，所以DBMS的缓存管理都是定制化的，不依赖操作系统的调用</li>
</ul>
<h3 id="other-memory-pools">Other Memory Pools</h3>
<ul>
<li>
<p>除了缓存页还会缓存别的数据（比如热点查询数据，这里有点像NoSQL的一些功能了）</p>
<ul>
<li>
<p>Sorting + Join Buffers</p>
</li>
<li>
<p>Query Caches</p>
</li>
<li>
<p>Maintenance Buffers</p>
</li>
<li>
<p>Log Buffers</p>
</li>
<li>
<p>Dictionary Caches</p>
</li>
</ul>
</li>
</ul>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #05: Storage Models &amp; Compression</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter5/</link>
    <pubDate>Mon, 08 Apr 2024 10:31:51 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter5/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-05-storage-models--compression">Lecture #05: Storage Models &amp; Compression</h2>
<h3 id="database-workloads">DataBase WorkLoads</h3>
<ul>
<li>
<p><strong>On-Line Transaction Processing(OLTP)</strong>:Fast operations that only read/update a small amount of data each time.</p>
<ul>
<li>快速操作，事务简单，读/写数据量很小</li>
<li>通常处理的写操作多于读操作</li>
<li>例子：银行转一次钱</li>
<li>往往意味着高并发，比如支付宝，微信支付</li>
</ul>
</li>
<li>
<p><strong>On-Line Analytical Processing(OLAP):</strong> Complex queries that read of a lot of data to computer aggregates</p>
<ul>
<li>一般是公司要对某一段时间的所有数据进行统计分析的时候使用</li>
<li>事务复杂，且要读大量的数据，从现有的大量数据中分析派生出新的数据</li>
<li>典型代表：数仓，深度学习的数据收集（比如常见的深度学习模型的训练）</li>
</ul>
</li>
<li>
<p><strong>Hybrid(混合) Transaction + Analytical Processing(HTAP):</strong> OLTP+OLAP together on the same database instance</p>
<ul>
<li>希望这个数据库两种事务都能应对（兼顾）</li>
<li>很像之前讲的disk和memory的结合体（</li>
</ul>
</li>
<li>
<p>公司方案:<strong>BIFURCATED ENVIRONMENT</strong>：OLTP和OLAP分别布置</p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-1.png" title="/img/CMU 15-445 Database Systems/chapter5-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-1.png" data-sub-html="<h2>OLTP负责对用户的事务处理，在流量低的时候将数据整合到数仓里面，分析师再过来操作数仓进行数据分析</h2>">
        
    </a><figcaption class="image-caption">OLTP负责对用户的事务处理，在流量低的时候将数据整合到数仓里面，分析师再过来操作数仓进行数据分析</figcaption>
    </figure>
<ul>
<li>
<p>HTAP或许能避免上面<strong>BIFURCATED ENVIRONMENT</strong>(要准备两套数据库，而且数据还要从这两套系统中来回迁移)的问题，但是也有可能是两头都跑不好</p>
</li>
<li>
<p>行存的模型适合OLTP，列存(DSM)的模型适合OLAP</p>
</li>
<li>
<p>现在很多主流数据库也会加入列存引擎来处理OLAP的事务</p>
</li>
</ul>
<h3 id="storage-models">Storage Models</h3>
<ul>
<li>这部分主要讲数据库的数据在磁盘上面不同的物理布局，对于不同的场景，不同的布局会有不一样的效果</li>
</ul>
<hr>
<ul>
<li>
<p><strong>N-Ary Storage Model (NSM)</strong></p>
<ul>
<li>
<p><u>The DBMS stores (almost) all attributes for a single tuple contiguously in a single page</u>(一个元组里面是所有属性，连续地存储在一个页中)</p>
</li>
<li>
<p>Also known as a “<strong>row store</strong>”（国内叫“行存”）</p>
</li>
<li>
<p>非常适合OLTP的工作负载，读的东西少，但是一直在频繁的写数据，行存的模型对写数据很友好</p>
</li>
<li>
<p>NSM数据库页面大小通常是硬件页面的常数倍(m $\times$ 4KB)：Oracle(4KB),Postgres(8KB),MySQL(16KB)</p>
</li>
</ul>
</li>
<li>
<p><strong>NSM: PHYSICAL ORGANIZATION</strong></p>
<ul>
<li>
<p>无论是定长还是不定长度，这个NSM都是用的之前的slotted page的存储模型，元组就连续的存储在页里面，再加上一个slot array来做标定，header来存储头部必要的一些信息</p>
</li>
<li>
<p>DBMS区分物理元组的唯一标识：<strong>record id</strong>(page#,slot#)，注意这个<strong>record id</strong>是页标识+槽标识构造的，不是数据库主键/唯一键，一定要区分!</p>
</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-2.png" title="/img/CMU 15-445 Database Systems/chapter5-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-2.png" data-sub-html="<h2>slotted page的物理存储模型</h2>">
        
    </a><figcaption class="image-caption">slotted page的物理存储模型</figcaption>
    </figure>
<ul>
<li><strong>NSM</strong>性能上的缺点
<ul>
<li>进行OLAP的操作的时候会有很多无用的数据，浪费效率</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-3.png" title="/img/CMU 15-445 Database Systems/chapter5-3.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-3.png" data-sub-html="<h2>OLAP往往是所有行的扫描，但是只要其中的几列数据，其他列的数据是无用的，但是DBMS就要为此扫描所有页，大量的I/O造成了效率低下</h2>">
        
    </a><figcaption class="image-caption">OLAP往往是所有行的扫描，但是只要其中的几列数据，其他列的数据是无用的，但是DBMS就要为此扫描所有页，大量的I/O造成了效率低下</figcaption>
    </figure>
<ul>
<li><strong>NSM:SUMMARY</strong>
<ul>
<li><strong>Advantages</strong>
<ul>
<li>Fast inserts, updates, and deletes</li>
<li>Good for queries that need the entire tuple(OLTP)</li>
<li>Can use index-oriented physical storage for clustering</li>
</ul>
</li>
<li><strong>Disadvantages</strong>
<ul>
<li>Not good for scanning large portions of the table and/or a subset of the attributes</li>
<li>Terrible memory locality for OLAP access patterns.(数据分散到了多个页，属性列不是连续的)</li>
<li>Not ideal for compression because of multiple value domains within a single page.(压缩数据靠的是数据的相似性，同一列的数据相似性才高，但是NSM是按行存不同列的数据，每一页数据的相似性很低，很难压缩)</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p><strong>Decomposition Storage Model (DSM)</strong></p>
<ul>
<li>The DBMS stores a single attribute for all tuples contiguously in a block of data.</li>
<li>Also known as a “<strong>column store</strong>”(国内叫“列存”)</li>
<li>非常适合OLAP的工作负载，大量的读取数据，而且往往都要的是某一列属性</li>
<li>DBMS这个时候主要就负责读写的时候拆分和组合属性</li>
</ul>
</li>
<li>
<p><strong>DSM: PHYSICAL ORGANIZATION</strong></p>
<ul>
<li>
<p>Store attributes and metadata (e.g.nulls) in separate arrays of fixedlength values.(固定长度的属性最好存储，数组完美匹配)</p>
</li>
<li>
<p>唯一标识：偏移量</p>
</li>
<li>
<p>难的是处理变长属性，需要在前面在加上一个id数据来做为标识，这样其实造成了数据冗余（id存了好几次）</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-6.png" title="/img/CMU 15-445 Database Systems/chapter5-6.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-6.png" data-sub-html="<h2>属性定长和不定长的两种存储方式</h2>">
        
    </a><figcaption class="image-caption">属性定长和不定长的两种存储方式</figcaption>
    </figure>
</li>
<li>
<p>Maintain a separate file per attribute with a dedicated header area for metadata about the entire column.(一个属性一个文件，加上Header来处理元数据)</p>
</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-4.png" title="/img/CMU 15-445 Database Systems/chapter5-4.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-4.png" data-sub-html="<h2>DSM的文件结构</h2>">
        
    </a><figcaption class="image-caption">DSM的文件结构</figcaption>
    </figure>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-5.png" title="/img/CMU 15-445 Database Systems/chapter5-5.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-5.png" data-sub-html="<h2>OLAP下只需要找对应属性的页，不需要像NSM那样全页扫描</h2>">
        
    </a><figcaption class="image-caption">OLAP下只需要找对应属性的页，不需要像NSM那样全页扫描</figcaption>
    </figure>
<ul>
<li>
<p><strong>DSM:SUMMARY</strong></p>
<ul>
<li><strong>Advantages</strong>
<ul>
<li>Reduces the amount wasted I/O per query because the DBMS only reads the data that it needs.</li>
<li>Faster query processing because of increased locality and cached data reuse.（属性上面的局部性 &gt; 行的局部性）</li>
<li>Better data compression (more on this in a few slides).</li>
</ul>
</li>
<li><strong>Disadvantages</strong>
<ul>
<li>Slow for point queries, inserts, updates, and deletes because of tuple splitting/stitching/reorganization.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>OBSERVATION</strong></p>
<ul>
<li>OLAP往往也要面临JOIN这样的操作，但是DSM的存储模型在JOIN上面的操作不是很优秀</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p><strong>PAX STORAGE MODEL</strong></p>
<ul>
<li>
<p>Partition Attributes Across (PAX) is a <strong>hybrid storage model</strong> that vertically partitions attributes within a database page.</p>
</li>
<li>
<p>The goal is to get the benefit of <strong>faster processing on columnar storage while retaining</strong> the spatial locality benefits of <strong>row storage</strong>.（保留行存优势地前提下，在列处理上面提速来匹配OLAP操作）</p>
</li>
</ul>
</li>
<li>
<p><strong>PAX: PHYSICAL ORGANIZATION</strong></p>
<ul>
<li>水平地将行划分为组，然后将这组的属性进行列存</li>
<li>每个页的Header里面会标明这个页里面每一组的偏移量
<ul>
<li>如果这个文件不可变，Header就存到页脚</li>
</ul>
</li>
<li>每一组都会有自己的<strong>metadata header</strong>(比如标明那一行那个属性是null，其他有关这个组的信息)</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-7.png" title="/img/CMU 15-445 Database Systems/chapter5-7.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-7.png" data-sub-html="<h2>PAX的物理结构</h2>">
        
    </a><figcaption class="image-caption">PAX的物理结构</figcaption>
    </figure>
<h3 id="database-compression">Database Compression</h3>
<ul>
<li>
<p>When a DBMS uses compression, it is always lossless because people don’t like losing data. Any kind of lossy compression must be performed at the application level.（数据库只能做无损压缩，有损压缩只能在应用程序里面做，数据库是绝对不给做的）</p>
</li>
<li>
<p><strong>COMPRESSION GRANULARITY</strong>（压缩的力度）</p>
</li>
</ul>
<h3 id="naïve-compression">NAÏVE COMPRESSION</h3>
<ul>
<li>
<p><strong>Block-Level</strong>：压缩同一个表里面的元组块</p>
</li>
<li>
<p>使用通用的算法来压缩数据</p>
</li>
<li>
<p>压缩的范围仅限于提供的数据</p>
</li>
<li>
<p>LZO (1996), LZ4 (2011), Snappy (2011),Oracle OZIP (2014), Zstd (2015)</p>
</li>
</ul>
<p>需要考虑的因素</p>
<ul>
<li>计算的开销</li>
<li>压缩和解压的速度</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-8.png" title="/img/CMU 15-445 Database Systems/chapter5-8.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-8.png" data-sub-html="<h2>MySQL INNODB的解压过程，把压缩好的数据读到缓存池再解压</h2>">
        
    </a><figcaption class="image-caption">MySQL INNODB的解压过程，把压缩好的数据读到缓存池再解压</figcaption>
    </figure>
<ul>
<li>这个模式的一个弊端就是每次读写数据的时候都先要做解码，效率很低</li>
<li>另一个思路：能不能不解码，而是对查询的数据使用算法变换，然后操作压缩后的数据</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-9.png" title="/img/CMU 15-445 Database Systems/chapter5-9.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-9.png" data-sub-html="<h2>这个就是上面的想法，把SQL中的数据进行变换，然后直接操作压缩的数据</h2>">
        
    </a><figcaption class="image-caption">这个就是上面的想法，把SQL中的数据进行变换，然后直接操作压缩的数据</figcaption>
    </figure>
<h3 id="columnar-compression">COLUMNAR COMPRESSION</h3>
<ul>
<li>
<p><strong>Column-Level</strong>：压缩属性值的列(DSM-only)，也叫<strong>COLUMNAR COMPRESSION</strong>（柱状压缩）</p>
</li>
<li>
<p><strong>Run-length Encoding</strong></p>
<ul>
<li>将单个列中的相同值改为三元组
<ul>
<li>属性的值</li>
<li>该值在这一列的起始位置</li>
<li>该值的元素个数</li>
</ul>
</li>
<li>适合的情景是该列对属性进行智能排序，这样可以获取最大化压缩的机会</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-10.png" title="/img/CMU 15-445 Database Systems/chapter5-10.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-10.png" data-sub-html="<h2>Run-length Encoding算法演示</h2>">
        
    </a><figcaption class="image-caption">Run-length Encoding算法演示</figcaption>
    </figure>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-11.png" title="/img/CMU 15-445 Database Systems/chapter5-11.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-11.png" data-sub-html="<h2>如果只有GROUP BY的操作，那么压缩的会更好</h2>">
        
    </a><figcaption class="image-caption">如果只有GROUP BY的操作，那么压缩的会更好</figcaption>
    </figure>
<ul>
<li><strong>Bit-Packing Encoding</strong>
<ul>
<li>如果整数属性的值很小，那么二进制前面的几位就可以不要</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-12.png" title="/img/CMU 15-445 Database Systems/chapter5-12.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-12.png" data-sub-html="<h2>bit packing压缩方案</h2>">
        
    </a><figcaption class="image-caption">bit packing压缩方案</figcaption>
    </figure>
<ul>
<li><strong>PATCHING/MOSTLY ENCODING</strong>
<ul>
<li>当属性中的大多数值小于对应类型的最大值时，使用更小的数据类型来对其进行存储，对于少数数值很大的值仍然使用原来的数据类型来进行存储</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-13.png" title="/img/CMU 15-445 Database Systems/chapter5-13.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-13.png" data-sub-html="<h2>int32-&gt;int8，Header会标定一下那个数据还是用的int32</h2>">
        
    </a><figcaption class="image-caption">int32-&gt;int8，Header会标定一下那个数据还是用的int32</figcaption>
    </figure>
<ul>
<li>
<p><strong>Bit-map Encoding</strong></p>
<ul>
<li>
<p>对于一些属性，它的值就那些（比如枚举）</p>
</li>
<li>
<p>那直接用位运算存几个bit里面就完全够了</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-14.png" title="/img/CMU 15-445 Database Systems/chapter5-14.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-14.png" data-sub-html="<h2>一共只有Y和N，那直接用两位bit就够了</h2>">
        
    </a><figcaption class="image-caption">一共只有Y和N，那直接用两位bit就够了</figcaption>
    </figure>
</li>
<li>
<p>但是从上面的图上面来看这个模式没有完全压榨二进制位运算的空间（比如只能用01和10，00和11都浪费了），所以在一些情况下压缩不如不压缩</p>
</li>
</ul>
</li>
<li>
<p><strong>Delta Encoding</strong></p>
<ul>
<li>
<p>记录和上一列的差别，不记录实际数据</p>
</li>
<li>
<p>基础值内联到表里面或者单独查询，有这个基础值下面的值都能推断出来了</p>
</li>
<li>
<p>配合<strong>Run-Length-Encoding</strong>压缩效果会更好</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-15.png" title="/img/CMU 15-445 Database Systems/chapter5-15.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-15.png" data-sub-html="<h2>先Delta Encoding再Run-Length-Encoding</h2>">
        
    </a><figcaption class="image-caption">先Delta Encoding再Run-Length-Encoding</figcaption>
    </figure>
</li>
</ul>
</li>
<li>
<p><strong>DICTIONARY COMPRESSION</strong></p>
<ul>
<li>
<p>Replace frequent values with smaller fixed-length codes and then maintain a mapping (dictionary) from the codes to the original values(搞一个K-V的映射，然后把原来数据的V换成长度更小的K)</p>
</li>
<li>
<p>Most widely used native compression scheme in DBMSs.</p>
</li>
<li>
<p>理想的字典查询是希望在单点查询和范围查询上面都有良好的性能</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-16.png" title="/img/CMU 15-445 Database Systems/chapter5-16.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-16.png" data-sub-html="<h2>建一个Hash表，然后压缩原表</h2>">
        
    </a><figcaption class="image-caption">建一个Hash表，然后压缩原表</figcaption>
    </figure>
</li>
<li>
<p>字典需要有两个功能</p>
<ul>
<li>Eecode/Locate：给了Key要能编码</li>
<li>Decode/Extract：给了Value能解压成Key</li>
<li><strong>所以即使上面会用Hash这个词，但是这个结构不能靠Hash函数来实现（Hash只能正着算，不能反向算）</strong></li>
</ul>
</li>
<li>
<p>字典还要保序，不能说编完码之后你原表的数据顺序就变了，因为你要考虑范围查找这种东西</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-17.png" title="/img/CMU 15-445 Database Systems/chapter5-17.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-17.png" data-sub-html="<h2>如果保序，范围查找对SQL里面的key做一次Hash就可以操作压缩后的数据了</h2>">
        
    </a><figcaption class="image-caption">如果保序，范围查找对SQL里面的key做一次Hash就可以操作压缩后的数据了</figcaption>
    </figure>
</li>
<li>
<p>字典压缩还有一个好处就是如果查询中有DISTINCT这种关键字，那么不需要进行全表扫描，直接去字典里面扫描一遍Value就够了</p>
</li>
<li>
<p>数据结构的选择</p>
<ul>
<li>Array
<ul>
<li>一个数组包含可变长度的字符串，一个数组包含指向映射到前面数组字符串的指针</li>
<li>更新成本很高，只能用在不可变文件中</li>
</ul>
</li>
<li>Hash Table
<ul>
<li>快速，紧凑</li>
<li>无法进行范围查询和前缀查询</li>
</ul>
</li>
<li>B+ Tree
<ul>
<li>比Hash Table要慢，而且占用更多的内存</li>
<li>支持范围查询和前缀查询</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #04: Database Storage (Part II)</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter4/</link>
    <pubDate>Mon, 25 Mar 2024 21:32:28 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter4/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-04-database-storage-part-ii">Lecture #04: Database Storage (Part II)</h2>
<h3 id="log-structured-storage">Log-Structured Storage</h3>
<ul>
<li>
<p>Slotted-Page(页+槽)的存储结构遇到的一些问题</p>
<ul>
<li><strong>Fragmentation</strong>:删除元组可能会在页中留下空白</li>
<li><strong>Useless Disk I/O</strong>:更新一组数据，但是你要把这个数据所在的页从磁盘load到内存里面</li>
<li><strong>Random Disk I/O</strong>:如果说你随机更新了很多数据，那么可能需要从磁盘load好多页到内存，时间会变得非常慢</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>另一种解决思路:<strong>Log-Structured Storage</strong></li>
</ul>
<blockquote>
<p>Log-structured Storage is based on the Log-Structured File System (LSFS) by Rosenblum and Ousterhout’92 and Log-structured Merge Trees (LSM Tree) by O’Neil, Cheng</p>
<p>LSM-tree也是数据库里面一个重要的知识点</p>
</blockquote>
<ul>
<li>DBMS不存储元组，而是只存储元组更改的记录，DBMS将新的日志添加到内存缓冲区中，不检查之前记录，然后按照更改数据写回到磁盘里面(这个顺序写盘就能解决上面的<strong>Random Disk I/O</strong>问题)，</li>
<li>这种模式对于写数据库的操作来说速度很快（直接写一个log刷回到盘里面就行了），这个在K-V数据库里面很流行</li>
<li>读记录的时候则需要从最旧的顺序扫描日志文件，从而获取元组的最新内容，为了提高效率，log也会使用索引来加快查找速度</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter4-1.png" title="/img/CMU 15-445 Database Systems/chapter4-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter4-1.png" data-sub-html="<h2>log&#43;索引</h2>">
        
    </a><figcaption class="image-caption">log+索引</figcaption>
    </figure>
<ul>
<li>
<p><strong>Compaction</strong></p>
</li>
<li>
<p>如果就一直记录日志，那么磁盘肯定有一天会不够写，所以DBMS需要定期压缩日志，压缩后的日志甚至不用按照时间戳排序，而是按照id排序（找的更快）</p>
</li>
<li>
<p>按层压缩（<strong>Level Compaction</strong>）</p>
<ul>
<li>代表:RocksDB(RocksDB第一/二/三层文件)</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter4-2.png" title="/img/CMU 15-445 Database Systems/chapter4-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter4-2.png" data-sub-html="<h2>Level0的两个文件内部可以压缩，但是如果update A在文件一，delete A在文件二，那这两条数据就没法合并压缩了</h2>">
          
      </a><figcaption class="image-caption">Level0的两个文件内部可以压缩，但是如果update A在文件一，delete A在文件二，那这两条数据就没法合并压缩了</figcaption>
      </figure>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter4-3.png" title="/img/CMU 15-445 Database Systems/chapter4-3.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter4-3.png" data-sub-html="<h2>解决方案：直接读取这两个文件中的日志，一起压缩到Level1的一个新文件里面</h2>">
          
      </a><figcaption class="image-caption">解决方案：直接读取这两个文件中的日志，一起压缩到Level1的一个新文件里面</figcaption>
      </figure>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter4-4.png" title="/img/CMU 15-445 Database Systems/chapter4-4.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter4-4.png" data-sub-html="<h2>这种情况可以一直递归压缩</h2>">
          
      </a><figcaption class="image-caption">这种情况可以一直递归压缩</figcaption>
      </figure>
<ul>
<li>RocksDB最多能压缩到第七层</li>
<li>读取的时候就从0层开始读，读不到就再读下一层</li>
</ul>
</li>
<li>
<p>通用压缩（<strong>Universal Compaction</strong>）</p>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter4-5.png" title="/img/CMU 15-445 Database Systems/chapter4-5.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter4-5.png" data-sub-html="<h2>不用分层，能合并就合并</h2>">
          
      </a><figcaption class="image-caption">不用分层，能合并就合并</figcaption>
      </figure>
</li>
</ul>
<hr>
<ul>
<li><strong>Log-Structured Storage</strong>的利弊
<ul>
<li>快速的顺序写入，对于需要频繁更改的数据库来说效率提示很多</li>
<li>读取可能很慢（要读很多日志）</li>
<li>压缩日志的代价很大</li>
<li>受制于写入放大（一个逻辑写入可能有多个物理写入，比如UPDATE ALL STUDENT age TO age + 1，对于这种语句到它的日志里面要写一堆）</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter4-6.png" title="/img/CMU 15-445 Database Systems/chapter4-6.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter4-6.png" data-sub-html="<h2>Log-Structured Storage代表数据库</h2>">
        
    </a><figcaption class="image-caption">Log-Structured Storage代表数据库</figcaption>
    </figure>
<h3 id="index-organized-storage">Index-Organized Storage</h3>
<ul>
<li>加入额外的索引存储，从而提高查找的速度</li>
</ul>
<h3 id="data-representation">Data Representation</h3>
<blockquote>
<p>There are five high level datatypes that can be stored in tuples: <strong>integers, variable-precision numbers, fixedpoint precision numbers, variable length values, and dates/times.</strong></p>
</blockquote>
<ul>
<li>
<p>元组中的数据本质就是字节数组，你要规定如何存储和解释这些字节，从而存储你的信息</p>
<ul>
<li>
<p>字节对齐的问题</p>
<ul>
<li><strong>Padding</strong>:在属性后添加空位，确保元组对其</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter4-7.png" title="/img/CMU 15-445 Database Systems/chapter4-7.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter4-7.png" data-sub-html="<h2>属性长度不够，后面填充字节码</h2>">
            
        </a><figcaption class="image-caption">属性长度不够，后面填充字节码</figcaption>
        </figure>
<ul>
<li>
<p><strong>Reordering</strong>:重新排列属性+填充</p>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter4-8.png" title="/img/CMU 15-445 Database Systems/chapter4-8.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter4-8.png" data-sub-html="<h2>能凑到一块的先凑起来，然后再填充</h2>">
              
          </a><figcaption class="image-caption">能凑到一块的先凑起来，然后再填充</figcaption>
          </figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>其他数据表示：整数，字符串这俩都很好记录，字符串可能头部需要存储一个长度，但是也不难，这里重点讨论浮点数/高精度和时间的表示</p>
</li>
<li>
<p>浮点数:IEEE-754下面的标准转到十进制是有误差的，这个在金融等需要绝对准确的领域里面是无法忍受的</p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter4-9.png" title="/img/CMU 15-445 Database Systems/chapter4-9.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter4-9.png" data-sub-html="<h2>0.1 &#43; 0.2 != 0.3</h2>">
        
    </a><figcaption class="image-caption">0.1 + 0.2 != 0.3</figcaption>
    </figure>
<ul>
<li>解决方案：高精度</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter4-10.png" title="/img/CMU 15-445 Database Systems/chapter4-10.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter4-10.png" data-sub-html="<h2>pg的高精度</h2>">
        
    </a><figcaption class="image-caption">pg的高精度</figcaption>
    </figure>
<hr>
<ul>
<li>
<p><strong>LARGE VALUES</strong></p>
</li>
<li>
<p>某一段数据很长造成的，比如在存储字符串的地方存了一本电子小说的内容，数据长到比最小的页还长，整个页都没法完整地把这个数据给存储下来</p>
</li>
<li>
<p>解决方案:<strong>Overflow Page</strong>，新开一个“溢出页”，把大的数据存到这个新开的页里面，然后原始页里面存放这个数据的地方去存放这个新开的页的地址</p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter4-11.png" title="/img/CMU 15-445 Database Systems/chapter4-11.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter4-11.png" data-sub-html="<h2>溢出页和原有页的关系</h2>">
        
    </a><figcaption class="image-caption">溢出页和原有页的关系</figcaption>
    </figure>
<ul>
<li>
<p>如果溢出页还不够：后面再加溢出页（当成拉链法去理解就好）</p>
</li>
<li>
<p><strong>使用数据库尽量避免这样的情况，很损害数据库的性能</strong></p>
<ul>
<li>一种方案是存成文件，然后数据库里面存文件路径，缺点就是这个文件里面数据没有持久性和事务保护</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Null Data Types</strong></li>
<li>在DBMS里面表示null的方法
<ul>
<li><strong>Null Column Bitmap Header</strong>：在数据的头部集中存储一个bitmap，这个bitmap就表示本条数据里面那些属性是null，这是最常见的方法</li>
<li><strong>Special Values</strong>：用特殊值来标记null，比如给整数标定一个int32min来表示null</li>
<li><strong>Per Attribute Null Flag</strong>：给每个属性前面都加一位来表示这个属性是不是为null，不推荐，因为不节约内存，多这一位的数据可能会造成内存需要填充好几位才能维持字节对齐</li>
</ul>
</li>
</ul>
<h3 id="system-catalogs">System Catalogs</h3>
<ul>
<li>每个数据库都有一个System Catalogs，里面的表存自己的元数据（有什么表，表结构，用户，用户权限，统计信息，日志信息。。。）</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter4-12.png" title="/img/CMU 15-445 Database Systems/chapter4-12.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter4-12.png" data-sub-html="<h2>MySQL的information schema</h2>">
        
    </a><figcaption class="image-caption">MySQL的information schema</figcaption>
    </figure>
<ul>
<li>每个数据库里面都有information schema，但是存的东西不一样</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter4-13.png" title="/img/CMU 15-445 Database Systems/chapter4-13.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter4-13.png" data-sub-html="<h2>MySQL的information schema里面的TABLES表，存了这个数据库里面所有表的信息</h2>">
        
    </a><figcaption class="image-caption">MySQL的information schema里面的TABLES表，存了这个数据库里面所有表的信息</figcaption>
    </figure>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #03: Database Storage (Part I)</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter3/</link>
    <pubDate>Mon, 25 Mar 2024 15:48:05 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter3/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-03-database-storage-part-i">Lecture #03: Database Storage (Part I)</h2>
<h3 id="storage">Storage</h3>
<ul>
<li>
<p>本课程讨论的都是存储在磁盘上的数据库，不考虑后期出现的内存数据库</p>
</li>
<li>
<p>补充计组的知识：设备离CPU越近，存储速度越快，内存越小，价格越贵</p>
</li>
<li>
<p><strong>Volatile Devices</strong></p>
<ul>
<li>断了电就没有数据了</li>
<li>可以通过字节寻址快速随机访问，程序可以随机获取数据</li>
<li>这个地方基本就叫内存</li>
</ul>
</li>
<li>
<p><strong>Non-Volatile Devices</strong></p>
<ul>
<li>断了电也不怕</li>
<li>也是块/页可寻址的，但是如果程序要读取需要先load到内存</li>
<li>更适合顺序访问（加载到内存+局部性原理）</li>
<li>一般叫磁盘，这个课不区分机械盘和SSD</li>
</ul>
</li>
<li>
<p>部分公司后面为了获取两个设备的长处推出了“持久内存”，但是本课程不会讨论，而且从Intel 2022开始逐步停产该系列产品来看，它没有想象中那么好</p>
</li>
<li>
<p>本课程主要是磁盘存储的数据库，我们必须明白一点，磁盘上面的数据必须要先load到内存中才能操作</p>
</li>
</ul>
<h3 id="disk-oriented-dbms-overview">Disk-Oriented DBMS Overview</h3>
<ul>
<li>
<p>数据库全部存储在磁盘上，数据库文件被数据组织成页，<strong>第一页是目录页</strong></p>
</li>
<li>
<p>为了对数据库进行操作，DBMS需要将数据放入内存，<strong>这个时候会使用一个缓冲池来管理在磁盘和内存之间移动的数据</strong></p>
</li>
<li>
<p>例子：以DBMS中的查询为例，执行引擎会让缓冲池请求特定的页面，缓冲池将该页加载到内存，然后返回给执行引擎目前内存中该页的指针，使得执行引擎可以进行下一步的工作</p>
</li>
</ul>
<h3 id="dbms-vs-os">DBMS vs. OS</h3>
<ul>
<li>
<p>DBMS和OS的虚拟内存都涉及到了cache和disk调用的问题，那么是否可以在DBMS中使用mmap呢</p>
<ul>
<li>不可以</li>
<li>mmap一旦出现地址错误会block，这对于DBMS的性能来说是不能接收的</li>
<li>mmap是为OS设计的，对于cache和disk的调用，DBMS其实更应该根据自己的情况来定制化其他方案</li>
</ul>
</li>
<li>
<p>但是我们和disk交互的时候仍然可以使用下面的OS调用，这些是符合我们期望的</p>
</li>
</ul>
<blockquote>
<p>• <strong>madvise</strong>: Tells the OS know when you are planning on reading certain pages.</p>
<p>• <strong>mlock</strong>: Tells the OS to not swap memory ranges out to disk.</p>
<p>• <strong>msync</strong>: Tells the OS to flush memory ranges out to disk.</p>
</blockquote>
<ul>
<li>对于DBMS这种如此吃性能的设施，很多解决方案还是需要手搓定制化，而不是依赖OS的调用</li>
</ul>
<h3 id="file-storage">File Storage</h3>
<ul>
<li>
<p>DBMS将数据库作为文件存储在磁盘上，有些使用文件层次结构，有些使用单个文件（比如SQLite）</p>
</li>
<li>
<p>OS是不知道这些文件存储的是什么，只有DBMS才能读懂和操作它们（有特定的编码）</p>
</li>
<li>
<p>DBMS的存储管理器负责管理数据库的文件。<strong>它将文件表示为页面的集合</strong>，它还跟踪哪些数据被读取和写入到页面，以及这些页面中有多少空闲空间</p>
</li>
</ul>
<h3 id="database-pages">Database Pages</h3>
<ul>
<li>
<p>DBMS会将多个文件组织成固定大小的数据块，这个东西就叫页</p>
</li>
<li>
<p>页面可以包含不同的数据类型，但是大多数系统是不会在页面中混合使用这些类型的</p>
</li>
<li>
<p>有些系统要求页面是自包含的，这意味着读取每个页面所需的所有信息都在页面本身上</p>
</li>
<li>
<p>每个页面都有一个唯一的标识符</p>
</li>
<li>
<p>如果数据库是单个文件，那么页id可以只是文件偏移量。大多数DBMS都有一个间接层，它将页id映射到文件路径和偏移量。系统的上层将要求提供特定的页码。然后，存储管理器必须将该页码转换为文件和偏移量以查找该页</p>
</li>
<li>
<p>大多数的页大小都是固定的，不然难以管理内存（内存碎片）</p>
</li>
<li>
<p>DBMS中的三种页面</p>
<ul>
<li>Hardware page (usually 4 KB).</li>
</ul>
<ol start="2">
<li>
<p>OS page (4 KB).</p>
</li>
<li>
<p>Database page (1-16 KB).</p>
</li>
</ol>
</li>
<li>
<p>硬件页设计的小是为了能够利用硬件的条件原子性写入，但是到了数据库的页就无法保证了，所以需要使用额外的措施保证原子性</p>
</li>
</ul>
<h3 id="database-heap">Database Heap</h3>
<ul>
<li>数据库的页“堆”成一个文件的方式</li>
<li>也要能够有创建页，遍历页，删除页的操作，那么页之间怎么组织？
<ul>
<li>Linked List</li>
<li>Page Directory</li>
</ul>
</li>
</ul>
<h3 id="page-layout">Page Layout</h3>
<ul>
<li>
<p>Every page includes a header that records meta-data about the page’s contents:</p>
<ul>
<li>
<p>Page size.</p>
</li>
<li>
<p>Checksum.</p>
</li>
<li>
<p>DBMS version.</p>
</li>
<li>
<p>Transaction visibility.</p>
</li>
<li>
<p>Self-containment. (Some systems like Oracle require this.)</p>
</li>
</ul>
</li>
<li>
<p>数据的存储方案</p>
<ul>
<li>
<p>Tuple-oriented:按照真实数据一行一行存</p>
<ul>
<li>
<p>如何避免内存碎片化问题：Slotted Page结构，索引在一个区，剩下的空间存储数据</p>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter3-1.png" title="/img/CMU 15-445 Database Systems/chapter3-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter3-1.png" data-sub-html="<h2>Slotted Page</h2>">
              
          </a><figcaption class="image-caption">Slotted Page</figcaption>
          </figure>
</li>
<li>
<p>定位：page_id + offset/slot</p>
</li>
</ul>
</li>
<li>
<p>Log-Structured:存操作日志</p>
</li>
</ul>
</li>
</ul>
<h3 id="tuple-layout">Tuple Layout</h3>
<ul>
<li>一组数据存储在磁盘上面就是bytes，需要我们附加其他的信息进行解析</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter3-2.png" title="/img/CMU 15-445 Database Systems/chapter3-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter3-2.png" data-sub-html="<h2>Tuple布局</h2>">
        
    </a><figcaption class="image-caption">Tuple布局</figcaption>
    </figure>
<ul>
<li>
<p><strong>Tuple Header</strong>: Contains meta-data about the tuple.</p>
<ul>
<li>
<p>并发控制信息（为了事务安全）</p>
</li>
<li>
<p>NULL值的Bit映射（解析Tuple需要的信息）</p>
</li>
<li>
<p>注：不需要存结构信息（每一个Header都存一下内存浪费太多了）</p>
</li>
<li>
<p>属性通常按照创建表的时候指定的数据存储</p>
</li>
<li>
<p>大多数DBMS不允许一个元组超过一个页面的大小</p>
</li>
</ul>
</li>
<li>
<p><strong>Unique Identifier</strong></p>
<ul>
<li>最常见的是page_id+offset</li>
<li>应用程序不能直接用这些，只能用主键这类的属性（因为这个东西会因为内存整理而更改，程序员只能和DBMS这部分的管理系统用主键交流，由这个系统进行映射）</li>
</ul>
</li>
<li>
<p><strong>Denormalized Tuple Data</strong>: If two tables are related, the DBMS can “pre-join” them, so the tables end up
on the same page. This makes reads faster since the DBMS only has to load in one page rather than two
separate pages. However, it makes updates more expensive since the DBMS needs more space for each
tuple.</p>
<ul>
<li>两个表如果总是需要JOIN，那我提前给你在内存中连好</li>
<li>理论上可行，现实中会让插入等的复杂度变的很高，目前这种方案已经被废止</li>
</ul>
</li>
</ul>
]]></description>
</item>
</channel>
</rss>
