<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>所有文章 - Jungle&#39;s Blog</title>
        <link>https://Jungle430.github.io/posts/</link>
        <description>所有文章 | Jungle&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>1239946358@qq.com (Jungle)</managingEditor>
            <webMaster>1239946358@qq.com (Jungle)</webMaster><lastBuildDate>Sat, 04 Mar 2023 15:47:02 &#43;0800</lastBuildDate><atom:link href="https://Jungle430.github.io/posts/" rel="self" type="application/rss+xml" /><item>
    <title>Linux x86 Program Start Up or - How the heck do we get to main()?</title>
    <link>https://Jungle430.github.io/posts/operating-system/support2/</link>
    <pubDate>Sat, 04 Mar 2023 15:47:02 &#43;0800</pubDate><author>1239946358@qq.com (Jungle)</author><guid>https://Jungle430.github.io/posts/operating-system/support2/</guid>
    <description><![CDATA[<h2 id="概述">概述</h2>
<ul>
<li>
<p>文章介绍了X86系统main函数调用前后的一些细节，并阐述了C程序的<b>构造函数</b>和<b>析构函数</b>，<u>以及<code>.init</code>,<code>.fini</code>,<code>init_array</code>和<code>fini_array</code>各section相对于main函数及彼此的执行顺序。遗憾的是这篇文章是基于32位CPU架构来研究的</u></p>
</li>
<li>
<p>文章对$debug$ <code>main</code>函数之前的代码有一定的帮助效果</p>
</li>
<li>
<p>主要介绍了X86 ELF文件的动态加载过程</p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/Operating%20System/support2-1.png" title="/img/Operating System/support2-1.png" data-thumbnail="/img/Operating System/support2-1.png" data-sub-html="<h2>总体流程图</h2>">
        
    </a><figcaption class="image-caption">总体流程图</figcaption>
    </figure>
<h2 id="调用过程分析">调用过程分析</h2>
<h3 id="main函数的调用">main函数的调用</h3>
<ul>
<li>先写一个最简单的C程序prog1.c</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>编译一下</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">gcc -ggdb -o prog1 prog1.c
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>注：<code>-ggdb</code>的选项作用：生成<code>gdb</code>专用的调试信息，会有一些<code>gdb</code>专用的扩展</p>
</blockquote>
<ul>
<li>然后我们用objdump做一下反汇编</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">objdump -d prog1 &gt; prog1.asm
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="从我们终端敲回车到程序被载入执行的过程中发生了什么">从我们终端敲回车到程序被载入执行的过程中发生了什么？</h4>
<ul>
<li>当我们从终端输入要运行的程序或者是从有关的<code>gui</code>界面点击相关的button的时候，<b>shell</b>或者<b>gui</b>就会调用<code>execve()</code>。这里不是我们重点关心的地方，简单来说，execve()会设立一个栈，然后将参数<code>argc</code>，<code>argv</code>和<code>envp</code>压入栈中。文件描述符0，1，2（stdin, stdout和stderr）由之前的shell设置，加载器会帮我们完成有关重定位的许多工作，当所有搞定之后，控制权会传递给<code>_start()</code></li>
</ul>
<figure><a class="lightgallery" href="/img/Operating%20System/support2-2.png" title="/img/Operating System/support2-2.png" data-thumbnail="/img/Operating System/support2-2.png" data-sub-html="<h2>shell输入man execve之后的函数声明和所在位置</h2>">
        
    </a><figcaption class="image-caption">shell输入<code>man execve</code>之后的函数声明和所在位置</figcaption>
    </figure>
<h4 id="_start">_start()</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">080482e0 &lt;_start&gt;:
</span></span><span class="line"><span class="cl">80482e0:       31 ed                   xor    %ebp,%ebp
</span></span><span class="line"><span class="cl">80482e2:       5e                      pop    %esi
</span></span><span class="line"><span class="cl">80482e3:       89 e1                   mov    %esp,%ecx
</span></span><span class="line"><span class="cl">80482e5:       83 e4 f0                and    $0xfffffff0,%esp
</span></span><span class="line"><span class="cl">80482e8:       50                      push   %eax
</span></span><span class="line"><span class="cl">80482e9:       54                      push   %esp
</span></span><span class="line"><span class="cl">80482ea:       52                      push   %edx
</span></span><span class="line"><span class="cl">80482eb:       68 00 84 04 08          push   $0x8048400
</span></span><span class="line"><span class="cl">80482f0:       68 a0 83 04 08          push   $0x80483a0
</span></span><span class="line"><span class="cl">80482f5:       51                      push   %ecx
</span></span><span class="line"><span class="cl">80482f6:       56                      push   %esi
</span></span><span class="line"><span class="cl">80482f7:       68 94 83 04 08          push   $0x8048394
</span></span><span class="line"><span class="cl">80482fc:       e8 c3 ff ff ff          call   80482c4 &lt;__libc_start_main@plt&gt;
</span></span><span class="line"><span class="cl">8048301:       f4                      hlt
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>任何值<code>xor</code>自身得到的结果都是0。所以<code>xor %ebp,%ebp</code>语句会把<code>%ebp</code>设置为0。ABI（Application Binary Interface specification）推荐这么做，目的是为了标记最外层函数的页帧（frame）</li>
<li>接下来，从栈中弹出栈顶的值保存到<code>%esi</code>。在最开始的时候我们把<code>argc</code>，<code>argv</code>和<code>envp</code>放到了栈里，所以现在的<code>pop</code>语句会把<code>argc</code>放到<code>%esi</code>中</li>
<li>这里只是临时保存一下，稍后我们会把它再次压回栈中</li>
<li>因为我们弹出了<code>argc</code>，所以<code>%ebp</code>现在指向的是<code>argv</code>。<code>mov</code>指令把<code>argv</code>放到了<code>%ecx</code>中，但是并没有移动栈指针</li>
<li><u>然后，将栈指针和一个可以清除后四位的掩码做<code>and</code>操作。根据当前栈指针的位置不同，栈指针将会向下移动0到15个字节。这么做，保证了任何情况下，栈指针都是16字节的偶数倍对齐的。对齐的目的是保证栈上所有的变量都能够被内存和cache快速的访问</u></li>
<li><u>要求这么做的是SSE，就是指令都能在单精度浮点数组上工作的那个<b>（扩展指令集）</b></u></li>
<li>例子：某次运行时，<code>_start</code>函数刚被调用的时候，<code>%esp</code>处于<code>0xbffff770</code>。在我们从栈上弹出<code>argc</code>后，<code>%esp</code>指向<code>0xbffff774</code>。它向高地址移动了（栈向下增长）。当对栈指针执行了<code>and</code>操作后，栈指针回到了<code>0xbffff770</code></li>
</ul>
<h4 id="__libc_start_main">__libc_start_main</h4>
<ul>
<li>现在，我们把<code>__libc_start_main</code>函数的参数压入栈中。第一个参数<code>%eax</code>被压入栈中，里面保存了无效信息，原因是稍后会有七个参数将被压入栈中，但是为了保证16字节对齐，所以需要第八个参数。这个值也并不会被用到。<code>__libc_start_main</code>是在链接的时候从glibc复制过来的。在glibc的代码中，它位于<code>csu/libc-start.c</code>文件里。<code>__libc_start_main</code>的定义如下</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">__libc_start_main</span><span class="p">(</span>  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">main</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="o">*</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="o">*</span> <span class="n">ubp_av</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">init</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fini</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">rtld_fini</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                <span class="kt">void</span> <span class="p">(</span><span class="o">*</span> <span class="n">stack_end</span><span class="p">));</span>
</span></span></code></pre></td></tr></table>
</div>
</div><figure><a class="lightgallery" href="/img/Operating%20System/support2-3.jpg" title="/img/Operating System/support2-3.jpg" data-thumbnail="/img/Operating System/support2-3.jpg" data-sub-html="<h2>参数说明</h2>">
        
    </a><figcaption class="image-caption">参数说明</figcaption>
    </figure>
<ul>
<li>__libc_csu_fini函数也是从glibc被链接进我们代码的，它的源代码位于csu/elf-init.c中</li>
</ul>
<h4 id="环境变量哪里去了">环境变量哪里去了？</h4>
<ul>
<li>
<p>我们并没有获取envp（栈里指向我们环境变量的指针）？它并不是<code>__libc_start_main</code>函数的参数。但是我们知道main函数的原型其实是<code>int main(int argc, char** argv, char** envp)</code>。所以，到底怎么回事？</p>
</li>
<li>
<p>其实，<code>__libc_start_main</code>函数会调用<code>__libc_init_first</code>，这个函数会使用内部信息去找到环境变量（实际上环境变量就位于<code>argv</code>的终止字符null的后面），然后设置一个全局变量<code>__environ</code>，这个全局变量可以被<code>__libc_start_main</code>函数内部任何地方使用，包括调用main函数时。当<code>envp</code>建立了之后，<code>__libc_start_main</code>函数会使用相同的小技巧，越过envp数组之后的<code>NULL</code>字符，获取另一个向量——ELF辅助向量（加载器使用它给进程传递一些信息）</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">__libc_init_first</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">arg0</span><span class="p">,</span> <span class="p">...)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arg0</span><span class="p">,</span> <span class="o">**</span><span class="n">envp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">argv</span><span class="p">[</span><span class="n">argc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">__environ</span> <span class="o">=</span> <span class="n">envp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">__libc_init</span> <span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">envp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>运行程序前，设置环境变量<code>LD_SHOW_AUXV=1</code>,可以查看里面的内容</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ <span class="nv">LD_SHOW_AUXV</span><span class="o">=</span><span class="m">1</span> ./prog1
</span></span><span class="line"><span class="cl">AT_SYSINFO:      0xe62414
</span></span><span class="line"><span class="cl">AT_SYSINFO_EHDR: 0xe62000
</span></span><span class="line"><span class="cl">AT_HWCAP:    fpu vme de pse tsc msr pae mce cx8 apic
</span></span><span class="line"><span class="cl">             mtrr pge mca cmov pat pse36 clflush dts
</span></span><span class="line"><span class="cl">             acpi mmx fxsr sse sse2 ss ht tm pbe
</span></span><span class="line"><span class="cl">AT_PAGESZ:       <span class="m">4096</span>
</span></span><span class="line"><span class="cl">AT_CLKTCK:       <span class="m">100</span>
</span></span><span class="line"><span class="cl">AT_PHDR:         0x8048034
</span></span><span class="line"><span class="cl">AT_PHENT:        <span class="m">32</span>
</span></span><span class="line"><span class="cl">AT_PHNUM:        <span class="m">8</span>
</span></span><span class="line"><span class="cl">AT_BASE:         0x686000
</span></span><span class="line"><span class="cl">AT_FLAGS:        0x0
</span></span><span class="line"><span class="cl">AT_ENTRY:        0x80482e0
</span></span><span class="line"><span class="cl">AT_UID:          <span class="m">1002</span>
</span></span><span class="line"><span class="cl">AT_EUID:         <span class="m">1002</span>
</span></span><span class="line"><span class="cl">AT_GID:          <span class="m">1000</span>
</span></span><span class="line"><span class="cl">AT_EGID:         <span class="m">1000</span>
</span></span><span class="line"><span class="cl">AT_SECURE:       <span class="m">0</span>
</span></span><span class="line"><span class="cl">AT_RANDOM:       0xbff09acb
</span></span><span class="line"><span class="cl">AT_EXECFN:       ./prog1
</span></span><span class="line"><span class="cl">AT_PLATFORM:     i686
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>各种各样的信息。<code>AT_ENTRY</code>是<code>_start</code>的地址，还有我们的UID、有效UID和GID</p>
</li>
<li>
<p><b>__libc_start_main功能总结</b></p>
<ul>
<li>处理关于setuid、setgid程序的安全问题</li>
<li>启动线程</li>
<li>把<code>fini</code>函数和<code>rtld_fini</code>函数作为参数传递给<code>at_exit</code>调用，使它们在<code>at_exit</code>里被调用，从而完成用户程序和加载器的调用结束之后的清理工作</li>
<li>调用其<code>init</code>参数</li>
<li>调用<code>main</code>函数，并把<code>argc</code>和<code>argv</code>参数、环境变量传递给它</li>
<li>调用<code>exit</code>函数，并将main函数的返回值传递给它</li>
</ul>
</li>
</ul>
<h2 id="相关参考资料">相关参考资料</h2>
<ul>
<li>参考文章
<ul>
<li><a href="http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html" target="_blank" rel="noopener noreffer">《Linux x86 Program Start Up or - How the heck do we get to main()? by Patrick Horgan》</a></li>
<li><a href="https://luomuxiaoxiao.com/?p=516" target="_blank" rel="noopener noreffer">《Linux X86 程序启动 – main函数是如何被执行的？——落木萧萧的博客》</a>（已与作者沟通，同意部分转载）</li>
</ul>
</li>
</ul>
]]></description>
</item>
<item>
    <title>速通BigInteger</title>
    <link>https://Jungle430.github.io/posts/java/biginteger/</link>
    <pubDate>Tue, 28 Feb 2023 23:59:46 &#43;0800</pubDate><author>1239946358@qq.com (Jungle)</author><guid>https://Jungle430.github.io/posts/java/biginteger/</guid>
    <description><![CDATA[<h1 id="速通biginteger">速通BigInteger</h1>
<ul>
<li>首先需要导包</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">java.math.BigInteger</span><span class="o">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><table border="2" >
	<tr>
		<td colspan="2">BigInteger的一些方法</td>
    </tr>
    <tr>
        <td>BigInteger bigInteger = new BigInteger("123456");</td>
        <td>使用String进行初始化</td>
    </tr>
    <tr>
        <td>abs()</td>
        <td>返回一个BigInteger。值为当前对象的绝对值</td>
    </tr>
    <tr>
        <td>add(BigInteger)</td>
        <td>相加:<br>
            bigInteger = bigInteger.add(new BigInteger("123456"));</td>
    </tr>
    <tr>
        <td>and(BigInteger)</td>
        <td>二进制AND(&)运算符:<br>
            bigInteger = bigInteger.and(new BigInteger("123456"));</td>
    </tr>
    <tr>
        <td>andNot(BigInteger)</td>
        <td>二进制按位与非运算符,等同于and(BigTnteger.not()):<br>
            bigInteger = bigInteger.andNot(new BigInteger("123456"));</td>
    </tr>
    <tr>
        <td>bitCount()</td>
        <td>该方法用于返回该BigInteger的<u>补码表示中与符号位不同的位数</u></td>
    </tr>
    <tr>
        <td>bitLength()</td>
        <td>返回二进制补码表示的长度</td>
    </tr>
    <tr>
        <td>compareTo(BigInteger)</td>
        <td>返回二者比较结果:小于 -1， 等于 0， 大于 1</td>
    </tr>
    <tr>
        <td>divide(BigInteger)</td>
        <td>相除，相当于"/"</td>
    </tr>
    <tr>
        <td>divideAndRemainder(BigInteger)</td>
        <td>返回一个BigInteger数组，第一位是截断结果(/)，第二位是余数(%)</td>
    </tr>
    <tr>
        <td>doubleValue()</td>
        <td>返回对应的double值</td>
    </tr>
    <tr>
        <td>gcd()</td>
        <td>gcd(abs(val1), abs(val2)),使用gcd算法</td>
    </tr>
    <tr>
        <td>intValue(), longValue()</td>
        <td>返回对应类型的值</td>
    </tr>
    <tr>
        <td>max(), min()</td>
        <td>最大最小值</td>
    </tr>
    <tr>
        <td>mod(BigInteger)</td>
        <td>相当于%</td>
    </tr>
    <tr>
        <td>multiply(BigInteger)</td>
        <td>相当于X</td>
    </tr>
    <tr>
    	<td>negate()</td>
        <td>取相反数</td>
    </tr>
    <tr>
        <td>pow(int)</td>
        <td>以该对象为基底，参数为幂</td>
    </tr>
    <tr>
        <td>isProbablePrime(int certainty)</td>
        <td>是否是质数,certainty - 这一措施的调用者能容忍的不确定性,此方法的执行时间正比于该参数的值</td>
    </tr>
    <tr>
        <td>shiftLeft(),shiftRight()</td>
        <td>左移,右移</td>
    </tr>
    <tr>
        <td>subtract()</td>
        <td>相减</td>
    </tr>
</table>    
]]></description>
</item>
<item>
    <title>Chapter2-部分二刷-个人理解System call</title>
    <link>https://Jungle430.github.io/posts/operating-system/support1/</link>
    <pubDate>Sun, 26 Feb 2023 21:02:57 &#43;0800</pubDate><author>1239946358@qq.com (Jungle)</author><guid>https://Jungle430.github.io/posts/operating-system/support1/</guid>
    <description><![CDATA[<h1 id="二刷部分chapter2-longrightarrow-如何理解system-call">二刷部分Chapter2 $\Longrightarrow$ 如何理解<code>System call</code></h1>
<h2 id="问题构造最小的hello-world程序">问题：构造最小的”Hello world”程序</h2>
<h3 id="基本程序和静态编译">基本程序和静态编译</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Hello world&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">gcc -static hello.c -o hello <span class="o">&amp;&amp;</span> ./hello
</span></span></code></pre></td></tr></table>
</div>
</div><p>编译出来很大(Ubuntu上约900KB)</p>
<ul>
<li>如果只编译，不链接，看一下obj文件的反汇编</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">gcc -c hello.c <span class="o">&amp;&amp;</span> objdump -d hello.o
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">hello.o：     文件格式 elf64-x86-64
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Disassembly of section .text:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="m">0000000000000000</span> &lt;main&gt;:
</span></span><span class="line"><span class="cl">   0:	f3 0f 1e fa          	endbr64 
</span></span><span class="line"><span class="cl">   4:	<span class="m">55</span>                   	push   %rbp
</span></span><span class="line"><span class="cl">   5:	<span class="m">48</span> <span class="m">89</span> e5             	mov    %rsp,%rbp
</span></span><span class="line"><span class="cl">   8:	<span class="m">48</span> 8d <span class="m">05</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> 	lea    0x0<span class="o">(</span>%rip<span class="o">)</span>,%rax        <span class="c1"># f &lt;main+0xf&gt;</span>
</span></span><span class="line"><span class="cl">   f:	<span class="m">48</span> <span class="m">89</span> c7             	mov    %rax,%rdi
</span></span><span class="line"><span class="cl">  12:	b8 <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>       	mov    <span class="nv">$0</span>x0,%eax
</span></span><span class="line"><span class="cl">  17:	e8 <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>       	call   1c &lt;main+0x1c&gt;
</span></span><span class="line"><span class="cl">  1c:	b8 <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>       	mov    <span class="nv">$0</span>x0,%eax
</span></span><span class="line"><span class="cl">  21:	5d                   	pop    %rbp
</span></span><span class="line"><span class="cl">  22:	c3                   	ret    
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>就和普通的函数差不多，只有参数压栈，call和参数出栈的过程
<ul>
<li>普通函数<code>fun.c</code></li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">gcc -c fun.c <span class="o">&amp;&amp;</span> objdump -d fun.o 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">fun.o：     文件格式 elf64-x86-64
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Disassembly of section .text:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="m">0000000000000000</span> &lt;f&gt;:
</span></span><span class="line"><span class="cl">   0:	f3 0f 1e fa          	endbr64 
</span></span><span class="line"><span class="cl">   4:	<span class="m">55</span>                   	push   %rbp
</span></span><span class="line"><span class="cl">   5:	<span class="m">48</span> <span class="m">89</span> e5             	mov    %rsp,%rbp
</span></span><span class="line"><span class="cl">   8:	<span class="m">90</span>                   	nop
</span></span><span class="line"><span class="cl">   9:	5d                   	pop    %rbp
</span></span><span class="line"><span class="cl">   a:	c3                   	ret
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>可以看到不链接的话和普通的函数调用过程差不多</p>
</li>
<li>
<p>链接失败！</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">○ → ld hello.o
</span></span><span class="line"><span class="cl">ld: 警告: 无法找到项目符号 _start<span class="p">;</span> 缺省为 <span class="m">0000000000401000</span>
</span></span><span class="line"><span class="cl">ld: hello.o: in <span class="k">function</span> <span class="sb">`</span>main<span class="s1">&#39;:
</span></span></span><span class="line"><span class="cl"><span class="s1">hello.c:(.text+0x18): undefined reference to `printf&#39;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>本来以为找的<code>main</code>，但是它实际上在找<code>_start</code>这个东西？</li>
</ul>
<h3 id="那我们就把main改成_start">那我们就把<code>main</code>改成<code>_start</code></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">_start</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Hello world&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><figure><a class="lightgallery" href="/img/Operating%20System/support1-1.png" title="/img/Operating System/support1-1.png" data-thumbnail="/img/Operating System/support1-1.png" data-sub-html="<h2>ld仍然不予通过-&gt; 找不到printf?</h2>">
        
    </a><figcaption class="image-caption"><code>ld仍然不予通过</code>-&gt; 找不到printf?</figcaption>
    </figure>
<ul>
<li>那把printf也给去了</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">_start</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>编译与链接全部成功！</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">○ → gcc -c hello.c <span class="o">&amp;&amp;</span> objdump -d hello.o <span class="o">&amp;&amp;</span> ld hello.o
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">hello.o：     文件格式 elf64-x86-64
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Disassembly of section .text:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="m">0000000000000000</span> &lt;_start&gt;:
</span></span><span class="line"><span class="cl">   0:	f3 0f 1e fa          	endbr64 
</span></span><span class="line"><span class="cl">   4:	<span class="m">55</span>                   	push   %rbp
</span></span><span class="line"><span class="cl">   5:	<span class="m">48</span> <span class="m">89</span> e5             	mov    %rsp,%rbp
</span></span><span class="line"><span class="cl">   8:	<span class="m">90</span>                   	nop
</span></span><span class="line"><span class="cl">   9:	5d                   	pop    %rbp
</span></span><span class="line"><span class="cl">   a:	c3                   	ret    
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>程序很小，只有99个字节</p>
</li>
<li>
<p>但是运行 $\Longrightarrow$ 段错误！</p>
</li>
<li>
<p>但是里面加入while(1)这种死循环就没事了</p>
</li>
</ul>
<hr>
<ul>
<li>对于没有while(1)的a.out，使用gdb狠狠的拷打调试</li>
</ul>
<a class="lightgallery" href="/img/Operating%20System/support1-2.jpg" title="/img/Operating System/support1-2.jpg" data-thumbnail="/img/Operating System/support1-2.jpg">
        
    </a>
<p>这个时候我们看到rsp的地址是合法的，里面的值是1，当执行ret后，rsp将栈顶的值1赋给了pc，gdb显示pc访问了非法位置</p>
<figure><a class="lightgallery" href="/img/Operating%20System/support1-3.png" title="/img/Operating System/support1-3.png" data-thumbnail="/img/Operating System/support1-3.png" data-sub-html="<h2>🤡呦吼，崩溃了！</h2>">
        
    </a><figcaption class="image-caption">🤡呦吼，崩溃了！</figcaption>
    </figure>
<ul>
<li>CPU只会执行指令，该怎么停下来？(mov,add这些指令停不下来)</li>
<li>需要什么指令让它停下来？ $\Longrightarrow$ <code>System call</code> 也就是管态</li>
</ul>
<h3 id="最小的hello-world程序">最小的<code>Hello world</code>程序</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/syscall.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="n">globl</span> <span class="n">_start</span>
</span></span><span class="line"><span class="cl"><span class="nl">_start</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">movq</span> <span class="err">$</span><span class="n">SYS_write</span><span class="p">,</span> <span class="o">%</span><span class="n">rax</span>   <span class="err">#</span> <span class="n">write</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="n">movq</span> <span class="err">$</span><span class="mi">1</span><span class="p">,</span>         <span class="o">%</span><span class="n">rdi</span>   <span class="err">#</span>   <span class="n">fd</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">movq</span> <span class="err">$</span><span class="n">st</span><span class="p">,</span>        <span class="o">%</span><span class="n">rsi</span>   <span class="err">#</span>   <span class="n">buf</span><span class="o">=</span><span class="n">st</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">movq</span> <span class="err">$</span><span class="p">(</span><span class="n">ed</span> <span class="o">-</span> <span class="n">st</span><span class="p">),</span> <span class="o">%</span><span class="n">rdx</span>   <span class="err">#</span>   <span class="n">count</span><span class="o">=</span><span class="n">ed</span><span class="o">-</span><span class="n">st</span>
</span></span><span class="line"><span class="cl">  <span class="n">syscall</span>                 <span class="err">#</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">movq</span> <span class="err">$</span><span class="n">SYS_exit</span><span class="p">,</span>  <span class="o">%</span><span class="n">rax</span>   <span class="err">#</span> <span class="n">exit</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="n">movq</span> <span class="err">$</span><span class="mi">1</span><span class="p">,</span>         <span class="o">%</span><span class="n">rdi</span>   <span class="err">#</span>   <span class="n">status</span><span class="o">=</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">  <span class="n">syscall</span>                 <span class="err">#</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">st</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="p">.</span><span class="n">ascii</span> <span class="s">&#34;</span><span class="se">\033</span><span class="s">[01;31mHello, OS World</span><span class="se">\033</span><span class="s">[0m</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nl">ed</span><span class="p">:</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>它在干什么
<ul>
<li>给许多寄存器赋值，然后call了syscall</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/Operating%20System/support1-4.png" title="/img/Operating System/support1-4.png" data-thumbnail="/img/Operating System/support1-4.png" data-sub-html="<h2>编译后查看反汇编代码</h2>">
        
    </a><figcaption class="image-caption">编译后查看反汇编代码</figcaption>
    </figure>
<ul>
<li>ld链接，编译成功，运行成功！</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">○ → objdump -d a.out <span class="p">|</span> less
</span></span></code></pre></td></tr></table>
</div>
</div><figure><a class="lightgallery" href="/img/Operating%20System/support1-5.png" title="/img/Operating System/support1-5.png" data-thumbnail="/img/Operating System/support1-5.png" data-sub-html="<h2>查看反汇编代码</h2>">
        
    </a><figcaption class="image-caption">查看反汇编代码</figcaption>
    </figure>
<figure><a class="lightgallery" href="/img/Operating%20System/support1-6.png" title="/img/Operating System/support1-6.png" data-thumbnail="/img/Operating System/support1-6.png" data-sub-html="<h2>man syscall查看syscall的文档</h2>">
        
    </a><figcaption class="image-caption"><code>man syscall</code>查看syscall的文档</figcaption>
    </figure>
<p>我们会发现，syscall会告诉我们在各种架构的计算机中该如何通过寄存器为syscall传入参数,<code>man syscalls</code>会告诉我们Linux操作系统的接口</p>
<ul>
<li>所以程序的执行模式</li>
</ul>
<div class="mermaid" id="id-1"></div>
<div class="details admonition tip open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-lightbulb fa-fw"></i>感谢<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><div class="typeit"><div id="id-2" class=""></div></div>
<p>感谢jyy互助群里<b>zweix</b>大佬提供的<a href="https://github.com/zweix123/jyyslide-md" target="_blank" rel="noopener noreffer">
jyyslide-md</a></p>
<p>使用过程中发现因为Windows很烂的编码问题始终会出现gbk解码错误的error，和<b>zweix</b>大佬差不多沟通了大半个下午，由于懒得给vscode配环境直接改成手动print看数据🤣，感觉就是命令行传参编码的问题，最后终于找到了解决方法😆，只能说Windows这个编码设置也是没谁了。</p>
</div>
        </div>
    </div>
]]></description>
</item>
<item>
    <title>《C&#43;&#43; Primer》 字符串，向量和数组</title>
    <link>https://Jungle430.github.io/posts/cpp-primer/chapter3/</link>
    <pubDate>Wed, 22 Feb 2023 22:31:49 &#43;0800</pubDate><author>1239946358@qq.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cpp-primer/chapter3/</guid>
    <description><![CDATA[<h1 id="c-primer">C++ Primer</h1>
<h2 id="字符串向量和数组">字符串，向量和数组</h2>
<h3 id="标准库类型string">标准库类型string</h3>
<ul>
<li>标准库类型<code>string</code>表示可变长的字符序列，使用<code>string</code>类型必须先包含头文件，<code>string</code>定义在命名空间<code>std</code>中</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>定义和初始化<code>string</code>对象</li>
</ul>
<table border="2" >
	<tr>
		<td colspan="2">初始化string对象的方式</td>
	</tr>
	<tr>
		<td>string s1</td>
		<td>默认初始化，s1是一个空串</td>
	</tr>
	<tr>
		<td>string s2(s1)</td>
        <td>s2是s1的副本</td>
	</tr>
	<tr>
		<td>string s2 = s1</td>
		<td>等价于s2(s1),s2是s1的副本</td>
	</tr>
	<tr>
		<td>string s3("value")</td>
		<td>s3是字面值"value"的副本，除了字面值最后的那个空字符外</td>
	</tr>
	<tr>
		<td>string s3 = "value"</td>
		<td>等价于s3("value"),s3是字面值"value"的副本
	</tr>
	<tr>
		<td>string s4(n, 'c')</td>
		<td>把s4初始化为由连续n个字符c组成的串</td>
	</tr>
</table>
<ul>
<li>
<p>直接初始化和拷贝初始化</p>
<ul>
<li>使用等号(=) $\rightarrow$ <strong>拷贝初始化</strong>(copy initialization),编译器把等号右侧的初始值拷贝到新创建的对象中去</li>
<li>不使用等号，执行的是<strong>直接初始化</strong>(direct initialization)</li>
</ul>
</li>
<li>
<p>如何使用</p>
<ul>
<li>初始化需要一个值：拷贝初始化和直接初始化都行</li>
<li>初始化需要多个值
<ul>
<li>尽量用直接初始化</li>
<li>拷贝初始化需要显式地创建一个（临时）对象来进行拷贝：<code>string s8 = string(10, 'c');</code>（可读性差，也没有任何补偿优势）</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>string</code>对象上的操作</p>
</li>
</ul>
<table border="2" >
	<tr>
		<td colspan="2">string的操作</td>
	</tr>
	<tr>
		<td>os << s</td>
		<td>将s写到输出流os当中，返回os</td>
	</tr>
	<tr>
		<td>is >> s</td>
		<td>从is中读取字符串赋给s，字符串以空白分隔，返回is</td>
	</tr>
	<tr>
		<td>getline(is, s)</td>
		<td>从is中读取一行赋给s，返回is(换行符也被读了进来,但是不会存入读入的字符串中去)</td>
	</tr>
	<tr>
		<td>s.empty()</td>
		<td>s为空返回true，否则返回false</td>
	</tr>
	<tr>
		<td>s.size()</td>
		<td>返回s中字符的个数</td>
	</tr>
	<tr>
		<td>s[n]</td>
		<td>返回s中第n个字符的<b>引用</b></td>
	</tr>
    <tr>
        <td>s1 + s2</td>
        <td>返回s1和s2连接后的结果</td>
    </tr>
    <tr>
        <td>s1 = s2</td>
        <td>用s2的副本替代s1中原来的字符</td>
    </tr>
    <tr>
    	<td>s1 == s2</td>
        <td>如果s1个s2中所含的字符完全一样，则返回true,否则返回false</td>
    </tr>
    <tr>
    	<td>s1 != s2</td>
        <td>等性判断对字母的大小写敏感</td>
    </tr>
    <tr>
        <td><, <=, >, >=</td>
        <td>利用字典序进行比较，对字母大小写敏感</td>
    </tr>
</table>    
<ul>
<li>技巧:读取未知数量的string对象</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">word</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">word</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">word</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>原理：<u>CTRL+Z/读到文件末尾 -&gt; 引发异常 -&gt; 记录异常 -&gt; fail() 返回true-&gt; operator void*() 返回 0 -&gt; while结束</u>，参考文章:<a href="https://www.zhangjiee.com/blog/2013/deep-into-while-cin.html" target="_blank" rel="noopener noreffer">C++ 深入探究 while(cin)</a></p>
<ul>
<li>如果是按行读</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">line</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">,</span> <span class="n">line</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">line</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>string::size_type类型</p>
<ul>
<li>
<p>string类的size函数返回的是是一个string::size_type类型的值，无符号类型，足以存放下任何<code>string</code>对象的大小，下标运算符参数类型也是如此</p>
</li>
<li>
<p>string类以及其他大多数标准库类型都定义了几种配套的类型。<u>这些配套类型体现了标准库类型与机器无关的特性，类型<b>size_type</b>即是其中的一种</u>。标准库会根据运行的机器型号分配适当的类型，我们不需过多关心，如果要看类型在C++11以后可以借助<code>auto</code>和<code>decltype</code>来推断变量类型</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">len</span> <span class="o">=</span> <span class="n">line</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>由于string::size_type是一个无符号类型，所以我们在对字符串进行有关size的相关操作时，尽量避免int与unsigned混用，否则会由于反补码机制出现意想不到的一些bug，正确做法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">line</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="k">decltype</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">str</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">............</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>
<p>字典序相关比较机制</p>
</li>
</ul>
<ol>
<li>较短的string对象小于较长的string对象(前面的内容都完全相同)</li>
<li>如果两个string对象在某些对应的位置上不一致，则string对象比较的结果其实是string对象中第一对相异字符比较的结果</li>
</ol>
<ul>
<li>
<p>字面值和string对象相加</p>
<ul>
<li>
<p>通过重载+和+=运算符实现，使用时一定要注意返回值的问题，不要两边类型不匹配（例如两个字面值相加）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s3</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">+</span> <span class="s">&#34;, &#34;</span> <span class="o">+</span> <span class="n">s2</span> <span class="o">+</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>防止上述问题：<b>必须确保每个加法运算符(+)的两侧运算对象至少有一个是string</b></p>
</li>
</ul>
</li>
<li>
<p>处理string对象中的字符</p>
<ul>
<li>主要利用到了头文件<code>&lt;cctype&gt;</code></li>
</ul>
</li>
</ul>
<table border="2" >
	<tr>
		<td colspan="2">&ltccytpe&gt中的常用函数</td>
	</tr>
    <tr>
        <td>isdigit(c)</td>
        <td>当c是数字的时候为真</td>
    </tr>
    <tr>
        <td>islower(c)</td>
        <td>c是小写字母的时候为真</td>
    </tr>
    <tr>
        <td>isupper(c)</td>
        <td>c是大写字母的时候为真</td>
    </tr>
    <tr>
        <td>isspace(c)</td>
        <td>c是空格的时候为真</td>
    </tr>
    <tr>
        <td>tolower(c)</td>
        <td>如果c是大写字母，则输出对应的小写字母，否则原样输出c</td>
    </tr>
    <tr>
        <td>toupper(c)</td>
        <td>如果c是小写字母，则输出对应的大写字母，否则原样输出c</td>
    </tr>
</table> 
<blockquote>
<p>为了向后兼容C，C++保留了C的标准库，但是为了更好地符合C++的要求，C++自己又开发出了一套新的标准库，去掉C库中的.h,前面加上c，即&lt;name.h&gt; $\rightarrow$ &lt;cname&gt;，上面&lt;cctype&gt;就是由C中的&lt;ctype.h&gt;衍生过来的，C++库中的函数为了防止与C标准库中的内容发生命名冲突，都在std命名空间中</p>
</blockquote>
<ul>
<li>基于范围的for语句
<ul>
<li>C++11的新特性</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="nl">declaration</span> <span class="p">:</span> <span class="n">expression</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">statement</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//example    
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">(</span><span class="s">&#34;Some string&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">str</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>重载的下标运算符
<ul>
<li>operator[] -&gt; 接收输入是std::string::size_type类型的值，返回string对应位置字符的引用</li>
<li>超出范围下标将引发不可预知的结果（内存非法越界访问或者访问到<code>nullptr</code> $\rightarrow$ 空字符串，C++为了性能并不会像Java那样在下标访问时进行检查，会有很大风险）</li>
</ul>
</li>
</ul>
<h3 id="标准库类型vector">标准库类型vector</h3>
<ul>
<li>
<p>vector本质是一种变长数组</p>
</li>
<li>
<p>vector也是一种容器(container)</p>
</li>
<li>
<p>vector包含于头文件&lt;vector&gt;中，定义在std命名空间下</p>
</li>
<li>
<p>vector是类模板，使用时必须声明其类型（其实在Modern C++中编译器也能自己推导一部分了），编译器根据模板创建类或函数函数的过程称为<b>实例化</b>(instantiation),由于C++的分离式编译，<b>自己写模板的时候一定要将声明与实现都写在.h里，不要将实现分离到.cpp中，否则会导致编译失败</b></p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/C&#43;&#43;%20Primer/chapter3-1.jpg" title="/img/C&#43;&#43; Primer/chapter3-1.jpg" data-thumbnail="/img/C&#43;&#43; Primer/chapter3-1.jpg" data-sub-html="<h2>由于模板的声明与实现分离导致编译失败</h2>">
        
    </a><figcaption class="image-caption"><code>由于模板的声明与实现分离导致编译失败</code></figcaption>
    </figure>
<figure><a class="lightgallery" href="/img/C&#43;&#43;%20Primer/chapter3-2.jpg" title="/img/C&#43;&#43; Primer/chapter3-2.jpg" data-thumbnail="/img/C&#43;&#43; Primer/chapter3-2.jpg" data-sub-html="<h2>全部写入头文件后编译成功</h2>">
        
    </a><figcaption class="image-caption"><code>全部写入头文件后编译成功</code></figcaption>
    </figure>
<ul>
<li>vector能容纳绝大多数类型的对象作为其元素，但是因为<u>引用不是对象，所以不存在包含引用的vector</u></li>
</ul>
<hr>
<ul>
<li>定义和初始化vector对象</li>
</ul>
<table border="2" >
	<tr>
		<td colspan="2">初始化vector对象的方法</td>
	</tr>
    <tr>
        <td>vector&ltT&gt v1</td>
        <td>v1是一个空vector，它潜在的元素是T类型的，执行默认初始化</td>
    </tr>
    <tr>
    	<td>vector&ltT&gt v2(v1)</td>
        <td>v2中包含有v1所有元素的副本</td>
    </tr>
    <tr>
        <td>vector&ltT&gt v2 = v1</td>
        <td>等价于v2(v1),v2中包含有v1所有元素的副本</td>
    </tr>
    <tr>
        <td>vector&ltT&gt v3(n, val)</td>
        <td>v3包含了n个重复元素，每个元素的值都是val</td>
    </tr>
    <tr>
    	<td>vector&ltT&gt v4(n)</td>
        <td>v4重复包含了n个重复地执行了值初始化的对象（默认初始化）</td>
    </tr>
    <tr>
        <td>vector&ltT&gt v5{a, b, c, ...}</td>
        <td>v5包含了初始值个数的元素，每个元素都被赋予了相应的初始值(注意使用花括号)</td>
    </tr>
    <tr>
        <td>vector&ltT&gt v5 = {a, b, c, ...}</td>
        <td>等价于v5{a, b, c, ...}</td>
    </tr>
</table>    
<ul>
<li>
<p>圆括号与花括号</p>
<ul>
<li>圆括号是提供的值用来构造(construct)vector对象的</li>
<li>花括号是用来进行列表初始化的(list initialize),初始化过程会尽可能的把花括号内的值当成是元素初始值的列表来处理，只有在<u>无法执行列表初始化时才会考虑其他初始化方式</u> $\Longrightarrow$ 列表内数据与所需元素类型不同</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v1</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// -&gt; {0, 0, 0, 0, 0, 0, 0, 0, 0, 0} 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v2</span><span class="p">{</span><span class="mi">10</span><span class="p">};</span> <span class="c1">// -&gt; {10}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v3</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// -&gt; {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v4</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span> <span class="c1">// -&gt; {10, 1}
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>列表初始化构造失败转为直接构造</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v5</span><span class="p">{</span><span class="mi">10</span><span class="p">};</span> <span class="c1">//10个默认初始化string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v8</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="s">&#34;hi&#34;</span><span class="p">};</span> <span class="c1">//10个&#34;hi&#34;
</span></span></span></code></pre></td></tr></table>
</div>
</div><hr>
<ul>
<li>vector有关操作</li>
</ul>
<table border="2" >
	<tr>
		<td colspan="2">vector支持的操作</td>
	</tr>
    <tr>
        <td>v.empty()</td>
        <td>返回元素个数是否为空</td>
    </tr>
    <tr>
        <td>v.size()</td>
        <td>返回元素个数</td>
    </tr>
    <tr>
        <td>v.push_back(t)</td>
        <td>向v的尾端添加一个值为t的元素</td>
    </tr>
    <tr>
        <td>v[n]</td>
        <td>下标访问，返回第n个位置上元素的引用</td>
    </tr>
    <tr>
        <td>v1 = v2</td>
        <td>用v2中元素的拷贝替换v1中的元素</td>
    </tr>
    <tr>
        <td>v1 = {a, b, c...}</td>
        <td>用列表中的元素拷贝替换v1中的元素</td>
    </tr>
    <tr>
        <td>v1 == v2; v1 != v2</td>
        <td>判等条件：元素数量相等且对应位置的元素值相等(对象需要重载==和!=运算符)</td>
    </tr>
    <tr>
        <td>&lt, &lt=, &gt, &gt=</td>
        <td>字典序比较，对象需要重载相应运算符</td>
    </tr>
</table> 
<ul>
<li>有关使用push_back的建议</li>
</ul>
<ol>
<li>不需要在创建<code>vector</code>时确定其中的元素及其大小，后续使用push_back即可</li>
<li>在循环体内部包含向<code>vector</code>对象添加元素的操作时，不应该使用<code>foreach</code>循环</li>
</ol>
<ul>
<li>
<p>size()返回的类型为vector::size_type,同string::size_type,由头文件和机器来决定类型，下标运算符参数类型也是如此(同string)</p>
</li>
<li>
<p>虽然vector可以扩容，但是不能通过下标来添加元素，通过下标访问不存在的元素会产生非常严重的后果，例如缓冲区溢出(<code>buffer overflow</code>),会导致出现安全问题</p>
</li>
</ul>
<h3 id="迭代器介绍与使用">迭代器介绍与使用</h3>
<ul>
<li>目的：访问对象中的元素</li>
<li>迭代器类似于指针类型，<u>也提供了对对象的间接访问</u>，使用迭代器可以访问某个元素，也可以从一个元素移动到另一个元素</li>
<li>有效与无效迭代器
<ul>
<li>有效：迭代器指向<u>某个元素或者容器中尾元素的下一位置</u></li>
<li>无效：除了上述指向的迭代器都无效</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>获取迭代器：获取迭代器不能使用取地址符，有专门的方法进行获取，容器一般都支持<b>begin</b>和<b>end</b>方法
<ul>
<li>begin返回指向第一个元素的迭代器</li>
<li>end返回指向容器<b>“尾元素的下一位置(one past the end)”的迭代器</b>,这样的迭代器没有什么实际意义，只是一个标记，表示我们已经处理完了容器中的所有元素。end成员返回的迭代器通常被称为<b>尾后迭代器(off-the-end iterator)或尾迭代器(end iterator)</b></li>
<li><b>如果容器为空，begin和end返回的是同一个迭代器,都是尾后迭代器(可以作为容器的判空手段）</b></li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">e</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><table border="2" >
	<tr>
		<td colspan="2">标准容器迭代器的运算符</td>
	</tr>
    <tr>
        <td>*iter</td>
        <td>返回迭代器iter所指元素的引用</td>
    </tr>
    <tr>
        <td>iter->men</td>
        <td>解引用iter并获得该元素的名为men的成员，等价于(*iter).men</td>
    </tr>
    <tr>
        <td>++iter</td>
        <td>令iter指示容器中的下一个元素</td>
    </tr>
    <tr>
        <td>--iter</td>
        <td>令iter指示容器中的下一个元素</td>
    </tr>
    <tr>
        <td>iter1 == iter2; iter1 != iter2</td>
        <td>判等条件：两个迭代器指示的是同一个元素或者他们是同一个容器的尾后迭代器，则相等；反之则不等</td>
    </tr>
</table>    
<ul>
<li>试图解引用一个非法迭代器或者尾后迭代器也是危险行为！</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">string</span> <span class="nf">s</span><span class="p">(</span><span class="s">&#34;Some thing&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">!=</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// -&gt; is empty?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">it</span> <span class="o">=</span> <span class="n">toupper</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>一般循环</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">ii</span> <span class="o">!=</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//......
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>大多数标准库容器的迭代器都定义了<code>==</code>和<code>!=</code>，但是它们中的大多数都没有定义<code>&lt;</code>运算符，所以我们使用迭代器是尽量使用<code>==</code>和<code>!=</code></p>
</li>
<li>
<p>迭代器类型</p>
<ul>
<li>iterator可读可写</li>
<li>const_iterator只读</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">it</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>实际使用中使用auto让编译器决定即可</p>
</li>
<li>
<p><code>begin()</code>和<code>end</code>自己决定返回的是否为const，如果必须要用const_iterator,使用<code>cbegin()</code>和<code>cend()</code>即可<code>C++ 11</code></p>
</li>
<li>
<p>注意，凡是使用了迭代器的循环体，都不要向迭代器所属的容器中添加元素，否则可能会造成迭代器失效</p>
</li>
</ul>
<hr>
<ul>
<li>迭代器运算</li>
</ul>
<table border="2" >
	<tr>
		<td colspan="2">迭代器运算</td>
	</tr>
    <tr>
        <td>iter + n</td>
        <td>迭代器加上了一个整数值仍得一个迭代器，迭代器指示的新位置与原来相比向后移动了若干元素</td>
    </tr>
    <tr>
        <td>iter - n</td>
        <td>迭代器减去了一个整数值仍得一个迭代器，迭代器指示的新位置与原来相比向前移动了若干元素</td>
    </tr>
    <tr>
        <td>iter += n</td>
        <td>iter = iter + n</td>
    </tr>
    <tr>
        <td>iter -= n</td>
        <td>iter = iter - n</td>
    </tr>
    <tr>
        <td>iter1 - iter2</td>
        <td>两个迭代器相减的结果是它们之间的距离，两个迭代器必须是同一个容器的有效迭代器，返回值类型为<b>difference_type(带符号类型)</b></td>
    </tr>
    <tr>
        <td>&gt, &gt=, &lt, &lt=</td>
        <td>关系运算符，注意两个迭代器必须是同一个容器的有效迭代器</td>
    </tr>
</table>    
<h3 id="数组">数组</h3>
<ul>
<li>编译的时候数组的维度应该是已知的，<b>维度必须是一个常量表达式</b></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">unsigned</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> <span class="c1">// 不是常量表达式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">constexpr</span> <span class="kt">unsigned</span> <span class="n">sz</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>  <span class="c1">//常量表达式
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><u>默认情况下，数组中的元素会被默认初始化</u> $\Longrightarrow$ <b>这里注意如果遇到了<code>new</code>和<code>delete</code>相关的一些操作，一定要防止默认初始化改变指针最后导致<code>delete</code>释放内存的时候程序崩溃</b></li>
</ul>
<figure><a class="lightgallery" href="/img/C&#43;&#43;%20Primer/chapter3-3.png" title="/img/C&#43;&#43; Primer/chapter3-3.png" data-thumbnail="/img/C&#43;&#43; Primer/chapter3-3.png" data-sub-html="<h2>HEAP CORRUPTION DETECTED报错说明及解决方案</h2>">
        
    </a><figcaption class="image-caption"><a href="https://blog.csdn.net/weixin_44426759/article/details/107194567?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167729932416800182739726%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=167729932416800182739726&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-107194567-null-null.142%5ev73%5ewechat,201%5ev4%5eadd_ask,239%5ev2%5einsert_chatgpt&amp;utm_term=heap%20corruption%20detected&amp;spm=1018.2226.3001.4187" target="_blank" rel="noopener noreffer">HEAP CORRUPTION DETECTED报错说明及解决方案</a></figcaption>
    </figure>
<ul>
<li>显式初始化 $\Longrightarrow$ 通过列表初始化数组</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">unsigned</span> <span class="n">sz</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">ia1</span><span class="p">[</span><span class="n">sz</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a2</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span> <span class="c1">//维度为3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">a3</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span> <span class="c1">// {0, 1, 2, 0, 0} 后面会默认初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">a5</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span> <span class="c1">//错误，初始值过多
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>字符数组
<ul>
<li>字符数组可以用字符串字面值进行赋值，但是要注意最后还有一个终止符</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">char</span> <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;Hello world&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">char</span> <span class="n">b</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;Daniel&#34;</span><span class="p">;</span> <span class="c1">//错误，忽略了最后的&#39;\0&#39;
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span><span class="p">[]{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a2</span><span class="p">[]</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="c1">//错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">a2</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="c1">//错误
</span></span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>本质是指针的拷贝，最后容易导致出现内存泄漏和野指针问题，虽然部分编译器支持上述行为，但是为了安全性和通用性，尽量不要出现上述代码</p>
</blockquote>
<ul>
<li>
<p>阅读数组声明含义：由内向外读</p>
</li>
<li>
<p>数组也可以用基于范围的for循环</p>
</li>
<li>
<p>访问数组元素使用的下标用的类型为<code>size_t</code>，也是一种机器相关类型，头文件C：<b>&lt;stddef.h&gt;</b> $\Longrightarrow$ C++：<b>&lt;cstddef&gt;</b>，但是内置下标运算符也可以使用负数(不同于vector和string)</p>
</li>
<li>
<p>数组的下标访问同样只由程序员负责检查，一定要防止非法访问</p>
</li>
<li>
<p><code>auto</code>返回的是指针,<code>decltype</code>返回的是数组</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//指针迭代器用法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">]{};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">arr</span><span class="p">;</span> <span class="n">b</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="n">b</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">do_something</span><span class="p">(</span><span class="o">*</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>C++11后引入了begin和end函数(定义于&lt;iterator&gt;，可以通过这两个函数获得的指针来模拟迭代器</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">arr</span><span class="p">[]{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="o">*</span><span class="n">begin</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(;</span> <span class="n">begin</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="n">begin</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">begin</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>两个指针相减的结果类型是<code>ptrdiff_t</code>的机器相关有符号类型，定义于&lt;cstddef&gt;文件中</p>
</li>
<li>
<p>同一数组的两个有效指针可以进行比较</p>
</li>
<li>
<p>C风格的字符串处理函数位于头文件&lt;cstring&gt;中，但是为了方便性和安全性，C++程序中尽量使用std::string</p>
</li>
<li>
<p>C风格的字符串比较实际是在比较字符串数组首地址</p>
</li>
<li>
<p>旧代码接口</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">string</span> <span class="n">s</span> <span class="p">{</span><span class="s">&#34;Hello world&#34;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">c_str</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">//但是在后续由于扩容等机制c_str()的指针可能会失去作用，最好通过s.c_str()拷贝复制一份
</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">*</span><span class="n">arr</span><span class="p">[]{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">arr</span><span class="p">));</span> <span class="c1">// -&gt; {0, 1, 2, 3, 4, 5}
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><u>建议：尽量使用标准库而非指针和数组</u></li>
</ul>
<blockquote>
<p>多维数组基于范围的for循环，除了最内层，其他所有循环的控制变量都应该是引用（转化为数组，如果不是引用会转化为指针)</p>
<p>for (auto &amp;i : arr)</p>
<p>​	for (auto &amp;j : i)</p>
<p>​		for (auto k : j) {</p>
<p>​			do_something(k);</p>
<p>}</p>
</blockquote>
<div id="id-1"><strong>Ending</strong></div>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #01: Course Overview &amp; Relational Model</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter1/</link>
    <pubDate>Wed, 22 Feb 2023 15:23:14 &#43;0800</pubDate><author>1239946358@qq.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter1/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-01-course-overview--relational-model">Lecture #01: Course Overview &amp; Relational Model</h2>
<h3 id="outline">Outline</h3>
<ul>
<li>Course Logistics</li>
<li>Relational Model</li>
<li>Relational Algebra</li>
</ul>
<h3 id="course-overiew">Course overiew</h3>
<ul>
<li>This course is about the design/implementation of database management systems (<code>DBMSs</code>)</li>
<li>This is <strong>not</strong> a course ($\rightarrow Key\ point\ is\ the\ theory\ and\ the\ concept$) about how to use a DBMS to build applications or how to administer a DBMS.→ See <a href="http://www.heinz.cmu.edu/academic-resources/course-results/course-details/index.aspx?cid=273" target="_blank" rel="noopener noreffer">CMU 95-703</a> (Heinz College)</li>
</ul>
<h3 id="projects">PROJECTS</h3>
<ul>
<li>
<p>All projects will use the CMU DB Group <a href="https://github.com/cmu-db/bustub" target="_blank" rel="noopener noreffer">BusTub</a> academic DBMS.</p>
<ul>
<li>→ Each project builds on the previous one.</li>
<li>→ We will not teach you how to write/debug C++17</li>
</ul>
</li>
<li>
<p><strong>complete <a href="https://15445.courses.cs.cmu.edu/fall2022/project0/" target="_blank" rel="noopener noreffer">Project #0</a> ! ! !</strong></p>
</li>
</ul>
<h3 id="database">Database</h3>
<ul>
<li>
<p><strong>Organized collection of inter-related data that models some aspect of the real-world</strong></p>
</li>
<li>
<p><strong>Databases are the core component of most computer applications</strong></p>
</li>
</ul>
<h4 id="example">Example</h4>
<p>Create a database that models a digital music store to keep track of artists and albums</p>
<ul>
<li>Things we need for our store
<ul>
<li>Information about <code>Artists</code></li>
<li>What <code>Albums</code> those Artists released</li>
</ul>
</li>
</ul>
<h5 id="flat-file-strawman">FLAT FILE STRAWMAN</h5>
<ul>
<li>
<p>Store our database as <strong>comma-separated value (CSV)</strong> files that we manage ourselves in our application code</p>
<ul>
<li>
<p>Use a separate file per entity</p>
</li>
<li>
<p>The application must parse the files each time they want to read/update records</p>
</li>
</ul>
</li>
<li>
<p>Create a database that models a digital music store</p>
</li>
</ul>
<p>Artist(name, year, country)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="s2">&#34;Wu-Tang Clan&#34;</span><span class="err">,</span><span class="mi">1992</span><span class="err">,</span><span class="s2">&#34;USA&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s2">&#34;Notorious BIG&#34;</span><span class="err">,</span><span class="mi">1992</span><span class="err">,</span><span class="s2">&#34;USA&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s2">&#34;GZA&#34;</span><span class="err">,</span><span class="mi">1990</span><span class="err">,</span><span class="s2">&#34;USA&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Album(name, artist, year)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="s2">&#34;Enter the Wu-Tang&#34;</span><span class="err">,</span><span class="s2">&#34;Wu-Tang Clan&#34;</span><span class="err">,</span><span class="mi">1993</span>
</span></span><span class="line"><span class="cl"><span class="s2">&#34;St.Ides Mix Tape&#34;</span><span class="err">,</span><span class="s2">&#34;Wu-Tang Clan&#34;</span><span class="err">,</span><span class="mi">1994</span>
</span></span><span class="line"><span class="cl"><span class="s2">&#34;Liquid Swords&#34;</span><span class="err">,</span><span class="s2">&#34;GZA&#34;</span><span class="err">,</span><span class="mi">1990</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="our-code">Our Code</h5>
<ul>
<li>Example: Get the year that GZA went solo $\rightarrow$ Artist</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file</span><span class="o">.</span><span class="n">readlines</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">	<span class="n">record</span> <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="n">record</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&#34;GZA&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nb">print</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">record</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="problem-about-flat-files-rightarrow-data-integrity">Problem about FLAT FILES $\rightarrow$ DATA-INTEGRITY</h4>
<ul>
<li>
<p>How do we ensure that the artist is the same for each album entry?</p>
</li>
<li>
<p>What if somebody overwrites the album year with an invalid string?</p>
</li>
<li>
<p>What if there are multiple artists on an album?</p>
</li>
<li>
<p>What happens if we delete an artist that has albums?</p>
</li>
</ul>
<h4 id="problem-about-flat-files-rightarrow-implementation">Problem about FLAT FILES $\rightarrow$ IMPLEMENTATION</h4>
<ul>
<li>
<p>How do you find a particular record?</p>
</li>
<li>
<p>What if we now want to create a new application that uses the same database?</p>
</li>
<li>
<p>What if two threads try to write to the same file at the same time?</p>
</li>
</ul>
<h4 id="problem-about-flat-files-rightarrow-durability">Problem about FLAT FILES $\rightarrow$ DURABILITY</h4>
<ul>
<li>
<p>What if the machine crashes while our program is updating a record?</p>
</li>
<li>
<p>What if we want to replicate the database on multiple machines for high availability?</p>
</li>
</ul>
<h3 id="database-management-system">DATABASE MANAGEMENT SYSTEM</h3>
<ul>
<li>
<p>A <u>database management system</u> (<strong>DBMS</strong>) is software that allows applications to <strong>store and analyze information in a database</strong></p>
</li>
<li>
<p>A general-purpose DBMS supports the <u>definition, creation, querying, update, and administration of databases</u> in accordance with some <u>data model</u></p>
</li>
</ul>
<h4 id="early-dbmss">EARLY DBMSs</h4>
<blockquote>
<p>Early database applications were difficult to build and maintain on available DBMSs in the 1960s</p>
<blockquote>
<p>Examples: IDS, IMS, CODASYL</p>
<p>Computers were expensive, humans were cheap😂</p>
</blockquote>
</blockquote>
<ul>
<li><u>Tight coupling</u> between <strong>logical</strong> and <strong>physical</strong> layers</li>
<li>Programmers had to (roughly) know what queries the application would execute before they could deploy the database😟</li>
</ul>
<blockquote>
<p><strong>Ted Codd</strong> was a <u>mathematician</u> working at IBM Research in the late 1960s</p>
<p>He saw IBM&rsquo;s developers spending their time <strong>rewriting database programs</strong> every time <u>the database’s schema or layout changed</u>😨</p>
<p>Devised the <strong>relational model</strong> in 1969</p>
</blockquote>
<h3 id="relational-model">RELATIONAL MODEL</h3>
<ul>
<li>
<p>The relational model defines a database abstraction based on relations to avoid maintenance overhead</p>
</li>
<li>
<p>Key tenets</p>
<ul>
<li>Store database in simple data structures (relations)</li>
<li>Physical storage left up to the DBMS implementation</li>
<li>Access data through high-level language, DBMS figures out best execution strategy</li>
</ul>
</li>
<li>
<p><strong>Structure:</strong> The definition of the database&rsquo;s relations and their contents</p>
</li>
<li>
<p><strong>Integrity:</strong> Ensure the database&rsquo;s contents satisfy constraints</p>
</li>
<li>
<p><strong>Manipulation:</strong> Programming interface for accessing and modifying a database&rsquo;s contents</p>
</li>
</ul>
<hr>
<ul>
<li>A <u>relation</u> is an unordered set that contain the relationship of attributes that represent entities</li>
<li>A <u>tuple</u> is a set of attribute values (also known as its <u>domain</u>) in the relation
<ul>
<li>Values are (normally) atomic/scalar</li>
<li>The special value <strong>NULL</strong> is a member of every domain (if allowed)</li>
</ul>
</li>
</ul>
<p>Artist(name, year, country)</p>
<table>
<thead>
<tr>
<th>name</th>
<th>year</th>
<th>country</th>
</tr>
</thead>
<tbody>
<tr>
<td>Wu-Tang Clan</td>
<td>1992</td>
<td>USA</td>
</tr>
<tr>
<td>Notorious BIG</td>
<td>1992</td>
<td>USA</td>
</tr>
<tr>
<td>GZA</td>
<td>1990</td>
<td>USA</td>
</tr>
</tbody>
</table>
<p>$$
n-ary\ Relation=Table\ with\ n\ columns\newline
$$</p>
<h4 id="relational-model-primary-keys">RELATIONAL MODEL: PRIMARY KEYS</h4>
<ul>
<li>A relation&rsquo;s <u>primary key</u> <strong>uniquely</strong> identifies a single tuple</li>
<li>Some <code>DBMSs</code> automatically create an internal primary key if a table does not define one</li>
<li>Auto-generation of unique integer primary keys
<ul>
<li>→ <strong>SEQUENCE</strong> (SQL:2003)</li>
<li>→ <strong>AUTO_INCREMENT</strong> (MySQL)</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>year</th>
<th>country</th>
</tr>
</thead>
<tbody>
<tr>
<td>123</td>
<td>Wu-Tang Clan</td>
<td>1992</td>
<td>USA</td>
</tr>
<tr>
<td>456</td>
<td>Notorious BIG</td>
<td>1992</td>
<td>USA</td>
</tr>
<tr>
<td>789</td>
<td>GZA</td>
<td>1990</td>
<td>USA</td>
</tr>
</tbody>
</table>
<h4 id="relational-model-foreign-keys">RELATIONAL MODEL: FOREIGN KEYS</h4>
<ul>
<li>A <u>foreign key</u> specifies that an attribute <strong>from one relation</strong> has to <strong>map to a tuple in another relation</strong></li>
</ul>
<a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter1-1.png" title="/img/CMU 15-445 Database Systems/chapter1-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter1-1.png">
        
    </a>
<h3 id="data-models">DATA MODELS</h3>
<ul>
<li>
<p>A <u>data model</u> is a collection of concepts for describing the data in a database</p>
</li>
<li>
<p>A <u>schema</u> is a description of a particular collection of data, <u>using a given data model</u></p>
</li>
</ul>
<hr>
<ul>
<li>
<p>Example</p>
<ul>
<li>
<p><strong>Relational</strong> $\leftarrow This\ Course\newline$</p>
</li>
<li>
<p>Key/Value</p>
</li>
<li>
<p>Graph</p>
</li>
<li>
<p>Document / Object</p>
</li>
<li>
<p>Wide-Column / Column-family</p>
</li>
<li>
<p>Array / Matrix / Vectors</p>
</li>
<li>
<p>Hierarchical</p>
</li>
<li>
<p>Network</p>
</li>
<li>
<p>Multi-Value</p>
</li>
</ul>
</li>
</ul>
<h3 id="data-manipulation-languages-dml">DATA MANIPULATION LANGUAGES (DML)</h3>
<ul>
<li>
<p>Methods to store and retrieve information from a database</p>
</li>
<li>
<p><strong>Procedural:</strong></p>
<ul>
<li>→ The query specifies the (high-level) strategy to find the desired result based on sets / bags $\leftarrow Relational\ Algebra\newline$</li>
</ul>
</li>
<li>
<p><strong>Non-Procedural (Declarative):</strong></p>
<ul>
<li>→ The query specifies only what data is wanted and not how to find it. $\leftarrow Relational\ Calculus\newline$</li>
</ul>
</li>
</ul>
<h3 id="relational-algebra">RELATIONAL ALGEBRA</h3>
<ul>
<li>
<p>Fundamental operations to retrieve and manipulate tuples in a relation</p>
<ul>
<li>→ Based on set algebra</li>
</ul>
</li>
<li>
<p>Each operator takes one or more relations as its inputs and outputs a new relation</p>
<ul>
<li>→ We can &ldquo;chain&rdquo; operators together to create more complex operations</li>
</ul>
</li>
</ul>
<p>$$
\begin{align}
&amp;\sigma\Longrightarrow Select\newline
&amp;\prod\Longrightarrow Projection\newline
&amp;\cup\Longrightarrow Union\newline
&amp;\cap\Longrightarrow Intersection\newline
&amp;-\Longrightarrow Difference\newline
&amp;\times\Longrightarrow Product\newline
&amp;\bowtie\Longrightarrow Join\newline
\end{align}
$$</p>
<h4 id="select">SELECT</h4>
<ul>
<li>
<p>Choose a subset of the tuples from a relation that satisfies a selection predicate</p>
<ul>
<li>
<p>Predicate acts as a filter to retain only tuples that fulfill its qualifying requirement</p>
</li>
<li>
<p>Can combine multiple predicates using conjunctions / disjunctions</p>
</li>
</ul>
</li>
</ul>
<p>$$
Syntax:\sigma_{predicate}(R)
$$</p>
<a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter1-2.png" title="/img/CMU 15-445 Database Systems/chapter1-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter1-2.png">
        
    </a>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">R</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="k">WHERE</span><span class="w"> </span><span class="n">a_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;a2&#39;</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">b_id</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">102</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="projection">PROJECTION</h4>
<ul>
<li>
<p>Generate a relation with tuples that contains only the specified attributes</p>
<ul>
<li>
<p>Can rearrange attributes’ ordering</p>
</li>
<li>
<p>Can manipulate the values</p>
</li>
</ul>
</li>
</ul>
<p>$$
Syntax:\prod_{A_1, A_2, &hellip;A_n}(R)
$$</p>
<a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter1-3.png" title="/img/CMU 15-445 Database Systems/chapter1-3.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter1-3.png">
        
    </a>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="n">b_id</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="n">a_id</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="k">FROM</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">a_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;a2&#39;</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="union">UNION</h4>
<ul>
<li>Generate a relation that contains all tuples that <strong>appear in either only one or both input relations</strong></li>
</ul>
<p>$$
Syntax:(R\cup S)
$$</p>
<a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter1-4.png" title="/img/CMU 15-445 Database Systems/chapter1-4.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter1-4.png">
        
    </a>
<a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter1-5.png" title="/img/CMU 15-445 Database Systems/chapter1-5.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter1-5.png">
        
    </a>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">R</span><span class="p">)</span><span class="w"> </span><span class="k">UNION</span><span class="w"> </span><span class="k">ALL</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">S</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="intersection">INTERSECTION</h4>
<ul>
<li>Generate a relation that contains only the tuples that <strong>appear in both of the input relations</strong></li>
</ul>
<p>$$
Syntax:(R\cap S)
$$</p>
<a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter1-6.png" title="/img/CMU 15-445 Database Systems/chapter1-6.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter1-6.png">
        
    </a>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">R</span><span class="p">)</span><span class="w"> </span><span class="k">INTERSECT</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">S</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="difference">DIFFERENCE</h4>
<ul>
<li>Generate a relation that contains only the tuples that appear in the first and not the second of the input relations</li>
</ul>
<p>$$
Syntax:(R-S)
$$</p>
<a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter1-7.png" title="/img/CMU 15-445 Database Systems/chapter1-7.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter1-7.png">
        
    </a>
<a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter1-8.png" title="/img/CMU 15-445 Database Systems/chapter1-8.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter1-8.png">
        
    </a>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">R</span><span class="p">)</span><span class="w"> </span><span class="k">EXCEPT</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">S</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="product">PRODUCT</h4>
<ul>
<li>Generate a relation that contains all possible combinations of tuples from the input relations(<code>combination</code>)</li>
</ul>
<p>$$
Syntax:(R\times S)
$$</p>
<a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter1-9.png" title="/img/CMU 15-445 Database Systems/chapter1-9.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter1-9.png">
        
    </a>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="k">CROSS</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">S</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">R</span><span class="p">,</span><span class="w"> </span><span class="n">S</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="join-">JOIN !</h4>
<ul>
<li>Generate a relation that contains all tuples that are a combination of two tuples (one from each input relation) with a common value(s) for one or more attributes</li>
</ul>
<p>$$
Syntax:(R\bowtie S)
$$</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="k">NATURAL</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">S</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>R</li>
</ul>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>1</td>
</tr>
<tr>
<td>b</td>
<td>2</td>
</tr>
</tbody>
</table>
<ul>
<li>S</li>
</ul>
<table>
<thead>
<tr>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>x</td>
</tr>
<tr>
<td>1</td>
<td>y</td>
</tr>
<tr>
<td>3</td>
<td>z</td>
</tr>
</tbody>
</table>
<ul>
<li>$R\bowtie S$</li>
</ul>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>1</td>
<td>x</td>
</tr>
<tr>
<td>a</td>
<td>1</td>
<td>y</td>
</tr>
</tbody>
</table>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="k">USING</span><span class="w"> </span><span class="p">(</span><span class="n">a_id</span><span class="p">,</span><span class="w"> </span><span class="n">b_id</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter1-10.png" title="/img/CMU 15-445 Database Systems/chapter1-10.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter1-10.png">
        
    </a>
<h4 id="extra-operators">EXTRA OPERATORS</h4>
<ul>
<li>
<p>Rename($\rho$)</p>
</li>
<li>
<p>Assignment($R \leftarrow S$)</p>
</li>
<li>
<p>Duplicate Elimination($\delta$)</p>
</li>
<li>
<p>Aggregation($\gamma$)</p>
</li>
<li>
<p>Sorting($\tau$)</p>
</li>
<li>
<p>Division($R\div S$)</p>
</li>
</ul>
<h4 id="observation">OBSERVATION</h4>
<blockquote>
<p>Relational algebra is a procedural language because it defines the high level-steps of how to compute a query. For example, $\sigma_{b_id=102}(R\bowtie S)$ is saying to first do the join of R and S and then do the select,whereas $(R \bowtie (\sigma_{b_id=102}(S)))$ will do the select on S first, and then do the join. These two statements will actually produce the same answer, but if there is only 1 tuple in S with b_id=102 out of a billion tuples, then$(R \bowtie (\sigma_{b_id=102}(S)))$ will be significantly faster than $\sigma_{b_id=102}(R\bowtie S)$😂</p>
</blockquote>
<blockquote>
<p>A better approach is to say the result you want (state $\rightarrow$<u>retrieve the joined tuples from R and S where b_id equals 102</u>), and let the DBMS decide the steps it wants to take to compute the query. SQL will do exactly this,and it is the de facto standard for writing queries on relational model databases🐮</p>
</blockquote>
<h4 id="queries">QUERIES</h4>
<ul>
<li>
<p>The relational model is independent of any query language implementation.</p>
</li>
<li>
<p><strong>SQL</strong> is the <em>de facto</em> standard (many dialects)</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file</span><span class="o">.</span><span class="n">readlines</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">	<span class="n">record</span> <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="n">record</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&#34;GZA&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nb">print</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">record</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="k">year</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">artists</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="k">WHERE</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;GZA&#39;</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="document-data-model">DOCUMENT DATA MODEL</h3>
<ul>
<li>Embed data hierarchy into a single object❌</li>
</ul>
<a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter1-11.png" title="/img/CMU 15-445 Database Systems/chapter1-11.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter1-11.png">
        
    </a>
<div class="mermaid" id="id-1"></div>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Artist</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">year</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Album</span> <span class="n">albums</span><span class="o">[];</span>
</span></span><span class="line"><span class="cl"><span class="o">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Album</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">year</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>$$
\Downarrow
$$</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;GZA&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;year&#34;</span><span class="p">:</span> <span class="mi">1990</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;albums&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Liquid Swords&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;year&#34;</span><span class="p">:</span> <span class="mi">1995</span>
</span></span><span class="line"><span class="cl">        <span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Beneath the Surface&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;year&#34;</span><span class="p">:</span> <span class="mi">1999</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="conclusion">CONCLUSION</h3>
<ul>
<li>
<p>Databases are ubiquitous</p>
</li>
<li>
<p>Relational algebra defines the primitives for processing queries on a relational database.</p>
</li>
<li>
<p>We will see relational algebra again when we talk about query optimization + execution</p>
</li>
</ul>
]]></description>
</item>
<item>
    <title>Computer Organization and Architecture Parallel Process &amp; Multicore Computers</title>
    <link>https://Jungle430.github.io/posts/computer-organization-and-architecture/computer-organization-and-architecture-parallel-process-multicore-computers/</link>
    <pubDate>Wed, 01 Feb 2023 01:31:38 &#43;0800</pubDate><author>1239946358@qq.com (Jungle)</author><guid>https://Jungle430.github.io/posts/computer-organization-and-architecture/computer-organization-and-architecture-parallel-process-multicore-computers/</guid>
    <description><![CDATA[<h1 id="computer-organization-and-architecture">Computer Organization and Architecture</h1>
<h2 id="parallel-process--multicore-computers">Parallel Process &amp; Multicore Computers</h2>
<h3 id="outline">Outline</h3>
<ul>
<li>
<p>Parallel Processing</p>
<ul>
<li>Multiple Processor Organizations</li>
<li>Symmetric Multiprocessors</li>
<li>Clusters</li>
<li>Nonuniform Memory Access</li>
<li>Vector Computation</li>
</ul>
</li>
<li>
<p>Multicore Computers</p>
</li>
</ul>
<h3 id="multiple-processor-organizations">Multiple Processor Organizations</h3>
<h4 id="types-of-multiple-processor">Types of multiple processor</h4>
<ul>
<li>
<p>Single instruction, single data stream – <code>SISD</code></p>
</li>
<li>
<p>Single instruction, multiple data stream – <code>SIMD</code></p>
</li>
<li>
<p>Multiple instruction, single data stream – <code>MISD</code></p>
</li>
<li>
<p>Multiple instruction, multiple data stream - <code>MIMD</code></p>
</li>
</ul>
<h4 id="sisd-organizations">SISD Organizations</h4>
<div class="mermaid" id="id-1"></div>
<ul>
<li>
<p>SISD的结构中包含1个CU控制单元，1个PU处理单元，以及1个MU存储单元</p>
</li>
<li>
<p>CU向PU发送指令流，MU向PU发送数据流</p>
</li>
<li>
<p>PU根据CU发送的指令流，对来自MU的数据流进行操作，并产生结果。</p>
</li>
<li>
<p>SISD并没有并行的能力，PU按照CU提供的指令流，进行相应的操作</p>
</li>
</ul>
<div class="mermaid" id="id-2"></div>
<ul>
<li>
<p>SIMD，单指令多数据流，结构中包含1个控制单元，多个处理单元。每个处理单元有自己的存储器</p>
</li>
<li>
<p>控制单元将指令流发送给多个处理单元进行同步处理，同步处理采用的是锁步方式</p>
</li>
<li>
<p>不同的处理器在不同的数据集上执行相同的指令，产生不同的处理结果</p>
</li>
<li>
<p>实质是对不同的数据集进行相同的处理，通过并行得到一组结果，并行处理提高效率</p>
</li>
<li>
<p>矢量和阵列处理器属于SIMD类型</p>
</li>
</ul>
<h4 id="misd">MISD</h4>
<ul>
<li>
<p>Sequence of data</p>
</li>
<li>
<p>Transmitted to set of processors</p>
</li>
<li>
<p>Each processor executes different instruction sequence</p>
</li>
<li>
<p>Never been implemented</p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter17-1.png" title="/img/Computer Organization and Architecture/chapter17-1.png" data-thumbnail="/img/Computer Organization and Architecture/chapter17-1.png" data-sub-html="<h2>MIMD Organizations</h2>">
        
    </a><figcaption class="image-caption"><code>MIMD Organizations</code></figcaption>
    </figure>
<ul>
<li>
<p>MIMD，多指令多数据流架构，多个控制单元CU，多个处理单元PU。存储方面，有两种结构</p>
<ul>
<li>
<p>共享存储器：所有的PU共享一个存储器，数据都存储在共享存储器中</p>
</li>
<li>
<p>分布式存储：每个PU都有自己的LM，这些机器通过互联网连接在一起</p>
</li>
</ul>
</li>
<li>
<p>一组处理器，能够同时执行不同的指令序列。每个处理器都有自己的数据集。</p>
</li>
<li>
<p>对称多处理SMP，集群，非均匀存储器访问NUMA等，都属于MIMD架构</p>
</li>
</ul>
<h3 id="symmetric-multiprocessors">Symmetric Multiprocessors</h3>
<h4 id="smp">SMP</h4>
<ul>
<li>
<p>Tightly Coupled</p>
</li>
<li>
<p>Processors share memory and I/O</p>
<ul>
<li>
<p>Share single memory or pool</p>
</li>
<li>
<p>Shared bus to access memory</p>
</li>
<li>
<p>Public area set in shared storage stores status information to achieve communication between processors</p>
</li>
<li>
<p>Memory access time to given area of memory is approximately the same for each processor</p>
</li>
</ul>
</li>
</ul>
<h4 id="characteristic-of-smp">Characteristic of SMP</h4>
<ul>
<li>
<p>Two or more processors with similar function</p>
<ul>
<li>
<p>All processors share memory and I/O</p>
</li>
<li>
<p>All processors share access to I/O</p>
</li>
<li>
<p>Perform the same function</p>
</li>
</ul>
</li>
<li>
<p>Controlled by a centralized operating system</p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter17-2.png" title="/img/Computer Organization and Architecture/chapter17-2.png" data-thumbnail="/img/Computer Organization and Architecture/chapter17-2.png" data-sub-html="<h2>Symmetric Multiprocessor Organization</h2>">
        
    </a><figcaption class="image-caption"><code>Symmetric Multiprocessor Organization</code></figcaption>
    </figure>
<ul>
<li>
<p>每个处理器有自己的$L1\ cache$，也可能会配置各自的$L2\ cache\newline$</p>
</li>
<li>
<p>处理器都挂在共享的系统总线上，共享对主存储器的访问</p>
</li>
<li>
<p>I/O系统也挂在系统总线上，各个处理器对I/O系统进行共享访问</p>
</li>
</ul>
<h4 id="smp-advantages">SMP Advantages</h4>
<ul>
<li>
<p>High performance</p>
<ul>
<li>Greatly improved performance if some work can be done in parallel</li>
</ul>
</li>
<li>
<p>High availability</p>
<ul>
<li>
<p>All processors can perform the same functions</p>
</li>
<li>
<p>Failure of a single processor does not halt the system</p>
</li>
</ul>
</li>
<li>
<p>Incremental growth</p>
<ul>
<li>
<p>Flexible system expansion</p>
</li>
<li>
<p>User can enhance performance by adding additional processors</p>
</li>
</ul>
</li>
<li>
<p>Scaling</p>
<ul>
<li>
<p>Vendors can offer range of products based on number of processors</p>
</li>
<li>
<p>Different products have different prices and performance, which can give users more choices</p>
</li>
</ul>
</li>
</ul>
<h4 id="design-issues">Design issues</h4>
<ul>
<li>
<p>SMP system is managed by a unified operating system</p>
</li>
<li>
<p>Operating system is responsible for scheduling processes and resources</p>
</li>
<li>
<p>Operating system needs to complete</p>
<ul>
<li>
<p>Simultaneous concurrent processes</p>
</li>
<li>
<p>Scheduling</p>
</li>
<li>
<p>Synchronization</p>
</li>
<li>
<p>Memory management</p>
</li>
<li>
<p>Reliability and fault tolerance</p>
</li>
</ul>
</li>
<li>
<p>Simultaneous concurrent processes</p>
<ul>
<li>
<p>Allow multiple processors to execute the same piece of OS code at the same time</p>
</li>
<li>
<p>Manage OS tables and other structures to avoid deadlocks</p>
</li>
</ul>
</li>
<li>
<p>Scheduling</p>
<ul>
<li>Reasonably schedule the processor execution process</li>
</ul>
</li>
<li>
<p>Synchronization</p>
<ul>
<li>Provide synchronization mechanism to ensure mutual exclusion and order of memory and I/O access</li>
</ul>
</li>
<li>
<p>Memory management</p>
<ul>
<li>Solve concurrency and consistency problems</li>
<li>Ensure the performance and correctness under multiprocessors</li>
</ul>
</li>
<li>
<p>Reliability and fault tolerance</p>
<ul>
<li>For a processor failure, the operating system shall be able to reconstruct the system so that the system can be degraded for use</li>
</ul>
</li>
</ul>
<h3 id="clusters">Clusters</h3>
<ul>
<li>
<p>Loosely Coupled</p>
</li>
<li>
<p>Collection of independent uniprocessors or <code>SMPs</code></p>
</li>
<li>
<p>Interconnected to form a cluster</p>
</li>
<li>
<p>Communication via fixed path or network connections</p>
</li>
</ul>
<hr>
<ul>
<li>
<p>Composition of cluster</p>
<ul>
<li>
<p>A group of interconnected whole computers</p>
</li>
<li>
<p>Working together as unified resource</p>
</li>
<li>
<p>Illusion of being one machine</p>
</li>
<li>
<p>Each computer called a node</p>
</li>
</ul>
</li>
<li>
<p>Characteristics</p>
<ul>
<li>
<p>High performance</p>
</li>
<li>
<p>High availability</p>
</li>
<li>
<p>Alternative to SMP</p>
</li>
</ul>
</li>
<li>
<p>Server applications</p>
</li>
</ul>
<h4 id="cluster-benefits">Cluster Benefits</h4>
<ul>
<li>
<p>Absolute scalability</p>
<ul>
<li>
<p>Build hundreds of thousands of independent computers into a large cluster system, and the processing capacity may far exceed that of the largest independent computer</p>
</li>
<li>
<p>Each machine in the cluster can be a single processing system or a multiprocessor architecture</p>
</li>
</ul>
</li>
<li>
<p>Incremental scalability</p>
<ul>
<li>
<p>New nodes can be added to the cluster system step by step to improve processing capacity and gradually expand</p>
</li>
<li>
<p>Very flexible capacity expansion</p>
</li>
</ul>
</li>
<li>
<p>High availability</p>
<ul>
<li>
<p>Each node is an independent computer</p>
</li>
<li>
<p>The failure of one or more nodes will not affect the use of the cluster system</p>
</li>
<li>
<p>Node fault diagnosis and fault tolerance are automatically completed by the system</p>
</li>
</ul>
</li>
<li>
<p>Superior price/performance</p>
<ul>
<li>
<p>Combine mature commercial computers into a cluster</p>
</li>
<li>
<p>The system performance is far greater than that of a single large server</p>
</li>
<li>
<p>High cost performance</p>
</li>
</ul>
</li>
</ul>
<h4 id="blade-servers">Blade Servers</h4>
<ul>
<li>
<p><strong>Common implementation of cluster</strong></p>
</li>
<li>
<p>Server houses multiple server modules (blades) in single chassis</p>
<ul>
<li>
<p>Save space</p>
</li>
<li>
<p>Improve system management</p>
</li>
<li>
<p>Chassis provides power supply</p>
</li>
<li>
<p>Each blade has processor, memory, disk</p>
</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter17-3.png" title="/img/Computer Organization and Architecture/chapter17-3.png" data-thumbnail="/img/Computer Organization and Architecture/chapter17-3.png" data-sub-html="<h2>Blade Servers</h2>">
        
    </a><figcaption class="image-caption"><code>Blade Servers</code></figcaption>
    </figure>
<h4 id="cluster-v-smp">Cluster v. SMP</h4>
<ul>
<li>
<p>Both provide multiprocessor support to high demand applications</p>
</li>
<li>
<p>Both available commercially</p>
</li>
<li>
<p>SMP for longer</p>
</li>
</ul>
<hr>
<ul>
<li>
<p><code>SMP</code></p>
<ul>
<li>
<p>Easier to manage and control</p>
</li>
<li>
<p>Closer to single processor systems</p>
</li>
<li>
<p>Scheduling is important</p>
</li>
<li>
<p>Less physical space</p>
</li>
<li>
<p>Lower power consumption</p>
</li>
</ul>
</li>
<li>
<p>Clustering</p>
<ul>
<li>
<p>Superior incremental &amp; absolute scalability</p>
</li>
<li>
<p>Superior availability</p>
<ul>
<li>Redundancy</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="nonuniform-memory-access">Nonuniform Memory Access</h3>
<h4 id="numa">NUMA</h4>
<ul>
<li>
<p>Tightly Coupled</p>
</li>
<li>
<p>Nonuniform memory access</p>
<ul>
<li>Access times to different regions of memory may differ</li>
</ul>
</li>
<li>
<p>Main object</p>
<ul>
<li>
<p>Overcoming the limitation on the number of processors in SMP</p>
</li>
<li>
<p>It solves the problem caused by the independent memory used by each node in the cluster system</p>
</li>
</ul>
</li>
<li>
<p>Alternative to SMP &amp; clustering</p>
</li>
</ul>
<hr>
<ul>
<li>
<p>Uniform memory access</p>
<ul>
<li>
<p>All processors have access to all parts of memory</p>
</li>
<li>
<p>Using load &amp; store</p>
</li>
<li>
<p>Access time to all regions of memory is the same</p>
</li>
<li>
<p>Access time to memory for different processors same</p>
</li>
<li>
<p>As used by SMP</p>
</li>
</ul>
</li>
</ul>
<h4 id="nonuniform-memory-access-1">Nonuniform Memory Access</h4>
<ul>
<li>
<p>All processors have access to all parts of memory</p>
</li>
<li>
<p>Using load &amp; store</p>
</li>
<li>
<p>Access time of processor differs depending on region of memory</p>
</li>
<li>
<p>Different processors access different regions of memory at different speeds</p>
</li>
</ul>
<hr>
<ul>
<li>
<p>Cache coherent NUMA(<code>CC-NUMA</code>)</p>
<ul>
<li>
<p>Cache coherence is maintained among the caches of the various processors</p>
</li>
<li>
<p>For a system without cache consistency maintenance, it is similar to a cluster system</p>
</li>
<li>
<p><code>CC-NUMA</code> is discussed here</p>
</li>
<li>
<p>Significantly different from SMP and clusters</p>
</li>
</ul>
</li>
</ul>
<h4 id="motivation">Motivation</h4>
<ul>
<li>
<p>SMP has practical limit to number of processors</p>
<ul>
<li>Bus traffic limits to between 16 and 64 processors</li>
</ul>
</li>
<li>
<p>In cluster，each node has own memory</p>
<ul>
<li>Apps do not see large global memory</li>
<li>Coherence maintained by software not hardware</li>
</ul>
</li>
<li>
<p>NUMA retains SMP flavour while giving large scale multiprocessing</p>
<ul>
<li>e.g. Silicon Graphics Origin NUMA 1024 MIPS R10000 processors</li>
</ul>
</li>
<li>
<p>Objective</p>
<ul>
<li>
<p>maintain transparent system wide memory while permitting multiprocessor nodes</p>
</li>
<li>
<p>each with own bus or internal interconnection system</p>
</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter17-4.png" title="/img/Computer Organization and Architecture/chapter17-4.png" data-thumbnail="/img/Computer Organization and Architecture/chapter17-4.png" data-sub-html="<h2>CC-NUMA Organization</h2>">
        
    </a><figcaption class="image-caption"><code>CC-NUMA Organization</code></figcaption>
    </figure>
<ul>
<li>
<p>NUMA系统由多个结点组成。每个节点包含有若干个处理器，每个处理器有自己的L1 cache和L2 cache，有自己的内部总线，并且有自己的主存和I/O</p>
</li>
<li>
<p>处理器访问存储器的时候，首先看是否在cache中，如果不在，cache会去访问本地存储器。如果在的话，就通过内部总线取过来。如果不在本地存储器中，cache会发出一个请求，通过互联网络从远端取过来，放到总线上，发出请求的cache从总线上读取。这些动作都是自动的，对处理器和cache都是透明的。</p>
</li>
</ul>
<h3 id="vector-computation">Vector Computation</h3>
<ul>
<li>
<p>Maths problems involving physical processes present different difficulties for computation</p>
<ul>
<li>
<p>Aerodynamics, seismology, meteorology</p>
</li>
<li>
<p>Continuous field simulation</p>
</li>
</ul>
</li>
<li>
<p>Requirement</p>
<ul>
<li>
<p>High precision</p>
</li>
<li>
<p>Repeated floating point calculations on large arrays of numbers</p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p>Solution 1: supercomputer</p>
<ul>
<li>
<p>Hundreds of millions of float</p>
</li>
<li>
<p>Optimized for Vector Computation</p>
</li>
<li>
<p>$10-15 million</p>
</li>
<li>
<p>Limited market</p>
</li>
<li>
<p>Research, government agencies, meteorology</p>
</li>
</ul>
</li>
<li>
<p>Solution 2:  Array processor</p>
<ul>
<li>
<p>Alternative to supercomputer</p>
</li>
<li>
<p>Configured as peripherals to mainframe &amp; mini</p>
</li>
<li>
<p>Just run vector portion of problems</p>
</li>
</ul>
</li>
</ul>
<h3 id="multicore-computers">Multicore Computers</h3>
<h4 id="what-is-multicore-computers">What is Multicore Computers?</h4>
<ul>
<li>
<p>Also known as single chip multiprocessor</p>
</li>
<li>
<p>Two or more processors are integrated on a single chip, and each processor is called a core</p>
</li>
<li>
<p>Each core consists of all components of an independent processor, including register set, ALU, pipeline hardware, control unit, and L1 data and instruction cache</p>
</li>
<li>
<p>Some multicore processors also include L2 cache and L3 cache on the chip</p>
</li>
</ul>
<h3 id="hardware-performance-issues">Hardware Performance Issues</h3>
<ul>
<li>
<p>Microprocessors have seen an exponential increase in performance</p>
<ul>
<li>
<p>Improved organization</p>
</li>
<li>
<p>Increased clock frequency</p>
</li>
</ul>
</li>
<li>
<p>Increase in Parallelism</p>
<ul>
<li>
<p>Pipelining</p>
</li>
<li>
<p>Superscalar</p>
</li>
<li>
<p>Simultaneous multithreading</p>
</li>
</ul>
</li>
</ul>
<h4 id="simultaneous-multithreading">Simultaneous multithreading</h4>
<ul>
<li>
<p>同步多线程能够从多个线程中取出指令来运行，它能够同时执行不同线程的指令</p>
</li>
<li>
<p>同步多线程架构中，配置了多个PC和多个寄存器组，底层共享指令cache和数据cache。这样可以在多个线程之间共享流水线资源</p>
</li>
<li>
<p>通过同步多线程技术，系统能够动态调整系统环境，如有可能同时执行不同线程的指令。当一个线程遇到长延迟事件时，允许另一个线程使用所有的处理单元</p>
</li>
</ul>
<h4 id="hardware-performance-issues-1">Hardware Performance Issues</h4>
<ul>
<li>
<p>Processor performance continues to improve</p>
<ul>
<li>
<p>Adjustment of chip architecture</p>
</li>
<li>
<p>Improvement of main frequency</p>
</li>
</ul>
</li>
<li>
<p>Diminishing returns</p>
<ul>
<li>
<p>More complexity requires more logic</p>
</li>
<li>
<p>Need more chip area for coordinating and signal transfer logic</p>
</li>
<li>
<p>Harder to design, make and debug</p>
</li>
<li>
<p>Hardware performance reaches the bottleneck, which is very difficult to improve</p>
</li>
</ul>
</li>
</ul>
<h4 id="power-consumption">Power consumption</h4>
<ul>
<li>
<p>Power requirements grow exponentially with chip density and clock frequency</p>
</li>
<li>
<p>Increased power consumption causes CPU cooling problems</p>
</li>
<li>
<p>It is increasingly difficult to improve performance by improving chip integration</p>
</li>
</ul>
<hr>
<ul>
<li>
<p>One solution is use more chip area for cache</p>
<ul>
<li>
<p>Storage transistors require low power consumption</p>
</li>
<li>
<p>Cache is close to CPU and fast</p>
</li>
<li>
<p>By 2015，100 billion transistors on 300mm2 ，Cache of 100MB ，1 billion transistors for logic</p>
</li>
</ul>
</li>
<li>
<p>Large capacity cache provides basic resources for multi-core processors</p>
</li>
</ul>
<h4 id="pollacks-rule">Pollack’s rule</h4>
<ul>
<li>
<p>Pollack’s rule</p>
<ul>
<li>
<p>Performance is roughly proportional to square root of increase in complexity</p>
</li>
<li>
<p>Double complexity gives 40% more performance</p>
</li>
</ul>
</li>
<li>
<p>So,integrating multiple processor cores on one chip becomes a better solution</p>
<ul>
<li>
<p>Multicore makes performance close to linear improvement</p>
</li>
<li>
<p>Unlikely that one core can use all cache effectively</p>
</li>
</ul>
</li>
</ul>
<h3 id="software-performance-issues">Software Performance Issues</h3>
<ul>
<li>
<p>Performance benefits dependent on effective exploitation of parallel resources</p>
<ul>
<li>
<p>Amdahl’s Law</p>
</li>
<li>
<p>Even small amounts of serial code impact performance</p>
</li>
<li>
<p>10% inherently serial on 8 processor system gives only 4.7 times performance</p>
</li>
</ul>
</li>
<li>
<p>Other factors affecting performance: communication, distribution of work and cache coherence overheads</p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter17-5.png" title="/img/Computer Organization and Architecture/chapter17-5.png" data-thumbnail="/img/Computer Organization and Architecture/chapter17-5.png" data-sub-html="<h2>Performance Effect of Multiple Cores</h2>">
        
    </a><figcaption class="image-caption"><code>Performance Effect of Multiple Cores</code></figcaption>
    </figure>
<ul>
<li>
<p>图（a）给出了串行代码比例对加速比的影响。如果没有串行代码，理论上加速比和性能的提升成正比。但是，由于串行处理的问题，导致加速比比理论值小了很多。</p>
</li>
<li>
<p>图（b）指出管理开销对加速比的影响。可以看到，在5个处理器的时候，加速比最大，随着核数的增加，管理开销会导致性能收益递减</p>
</li>
</ul>
<h4 id="effective-applications">Effective Applications</h4>
<ul>
<li>
<p>Some applications effectively exploit multicore processors</p>
<ul>
<li>
<p>Database</p>
</li>
<li>
<p>Servers handling independent transactions</p>
</li>
<li>
<p>Multi-threaded native applications，such as Lotus Domino, Siebel CRM</p>
</li>
<li>
<p>Multi-process applications, such as Oracle, SAP, PeopleSoft</p>
</li>
</ul>
</li>
<li>
<p>Java applications</p>
<ul>
<li>
<p><code>JVM</code> is multi-thread with scheduling and memory management</p>
</li>
<li>
<p>Sun’s Java Application Server, BEA’s Weblogic, IBM Websphere, Tomcat</p>
</li>
</ul>
</li>
<li>
<p>Multi-instance applications</p>
<ul>
<li>One application running multiple times</li>
</ul>
</li>
<li>
<p>Game Software</p>
</li>
</ul>
<h3 id="multicore-organization">Multicore Organization</h3>
<ul>
<li>
<p>Number of core processors on chip</p>
</li>
<li>
<p>Number of levels of cache on chip</p>
</li>
<li>
<p>Amount of shared cache</p>
</li>
<li>
<p>Next slide examples of each organization</p>
<ul>
<li>
<p>(a) ARM11 MPCore</p>
</li>
<li>
<p>(b) AMD Opteron</p>
</li>
<li>
<p>(c) Intel Core Duo</p>
</li>
<li>
<p>(d) Intel Core i7</p>
</li>
</ul>
</li>
</ul>
<h4 id="individual-core-architecture">Individual Core Architecture</h4>
<ul>
<li>
<p>Intel Core Duo uses superscalar cores</p>
</li>
<li>
<p>Intel Core i7 uses simultaneous multi-threading (SMT)</p>
<ul>
<li>Scales up number of threads supported</li>
<li>4 SMT cores, each supporting 4 threads appears as 16 core</li>
</ul>
</li>
</ul>
<h3 id="intel-x86-multicore-organization">Intel x86 Multicore Organization</h3>
<p>Example: Core Duo and Core i7</p>
<h3 id="arm11-mpcore">ARM11 MPCore</h3>
<ul>
<li>
<p>Up to 4 processors each with own L1 instruction and data cache</p>
</li>
<li>
<p>Distributed interrupt controller</p>
</li>
<li>
<p>Timer per CPU</p>
</li>
<li>
<p>Watchdog</p>
<ul>
<li>Warning alerts for software failures</li>
<li>Counts down from predetermined values</li>
<li>Issues warning at zero</li>
</ul>
</li>
<li>
<p>CPU interface</p>
<ul>
<li>Interrupt acknowledgement, masking and completion acknowledgement</li>
</ul>
</li>
<li>
<p>CPU</p>
<ul>
<li>Single ARM11 called MP11</li>
</ul>
</li>
<li>
<p>Vector floating-point unit</p>
<ul>
<li>FP co-processor</li>
</ul>
</li>
<li>
<p>L1 cache</p>
</li>
<li>
<p>Snoop control unit</p>
<ul>
<li>Maintain L1 cache coherency</li>
</ul>
</li>
</ul>
<h4 id="summary-of-parallel">Summary of parallel</h4>
<ul>
<li>
<p>Internal of CPU</p>
<ul>
<li>
<p>Pipeline</p>
</li>
<li>
<p>Superscalar</p>
</li>
<li>
<p>simultaneous multi-threading(SMT)</p>
</li>
</ul>
</li>
<li>
<p>On chip</p>
<ul>
<li>Multicore</li>
</ul>
</li>
<li>
<p>Internal of machine</p>
<ul>
<li>
<p>SMP</p>
</li>
<li>
<p>NUMA</p>
</li>
<li>
<p>Array processor</p>
</li>
</ul>
</li>
<li>
<p>Multi-machine</p>
<ul>
<li>Cluster</li>
</ul>
</li>
</ul>
]]></description>
</item>
<item>
    <title>Computer Organization and Architecture Control Unit Operation &amp; Microprogrammed Control</title>
    <link>https://Jungle430.github.io/posts/computer-organization-and-architecture/computer-organization-and-architecture-control-unit-operation-microprogrammed-control/</link>
    <pubDate>Tue, 31 Jan 2023 15:20:52 &#43;0800</pubDate><author>1239946358@qq.com (Jungle)</author><guid>https://Jungle430.github.io/posts/computer-organization-and-architecture/computer-organization-and-architecture-control-unit-operation-microprogrammed-control/</guid>
    <description><![CDATA[<h1 id="computer-organization-and-architecture">Computer Organization and Architecture</h1>
<h2 id="control-unit-operation--microprogrammed-control">Control Unit Operation &amp; Microprogrammed Control</h2>
<h3 id="outline">Outline</h3>
<ul>
<li>
<p>Control Unit Operation</p>
<ul>
<li>
<p>Micro-Operations</p>
</li>
<li>
<p>Control of the Processor</p>
</li>
<li>
<p>Hardwired Implementation</p>
</li>
</ul>
</li>
<li>
<p>Microprogrammed Control</p>
<ul>
<li>Basic Concepts</li>
<li>Microinstruction Sequencing</li>
<li>Microinstruction Execution</li>
</ul>
</li>
</ul>
<h3 id="control-unit-operation">Control Unit Operation</h3>
<h4 id="the-function-of-a-processor">The function of a processor</h4>
<ul>
<li>
<p>Instruction Fetch and Execute</p>
<ul>
<li>Execute program</li>
</ul>
</li>
<li>
<p>Interrupts</p>
<ul>
<li>Handling performance differences between CPU and other components</li>
</ul>
</li>
<li>
<p>I/O Function</p>
<ul>
<li>Inter-working with peripherals</li>
</ul>
</li>
</ul>
<h4 id="composition-of-instructions">Composition of instructions</h4>
<ul>
<li>
<p>Instructions include opcodes and operands</p>
</li>
<li>
<p>Opcodes</p>
<ul>
<li>Determines what type of operation the instruction does</li>
</ul>
</li>
<li>
<p>Operands</p>
<ul>
<li>
<p>Determine the object of instruction operation</p>
</li>
<li>
<p>Operands may be in registers, memory, I/O, or immediate</p>
</li>
<li>
<p>Finding operands through addressing mode</p>
</li>
</ul>
</li>
</ul>
<h4 id="micro-operations">Micro-operations</h4>
<ul>
<li>
<p>A computer executes a program to complete user specified functions</p>
<ul>
<li>
<p>Program contains many instructions</p>
</li>
<li>
<p>Instruction execution includes several cycles, such as fetch cycle, execution cycle, indirect cycle, etc</p>
</li>
</ul>
</li>
<li>
<p><strong>Each cycle has a number of steps</strong></p>
<ul>
<li>
<p><strong>Called micro-operations</strong></p>
</li>
<li>
<p><strong>Each step does very little</strong></p>
</li>
<li>
<p><strong>Atomic operation of CPU</strong></p>
</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter15-1.png" title="/img/Computer Organization and Architecture/chapter15-1.png" data-thumbnail="/img/Computer Organization and Architecture/chapter15-1.png" data-sub-html="<h2>Constituent of program</h2>">
        
    </a><figcaption class="image-caption"><code>Constituent of program</code></figcaption>
    </figure>
<ul>
<li>
<p><strong>程序的执行是由若干个指令执行组成的</strong></p>
</li>
<li>
<p><strong>每个指令的执行就是一个指令周期</strong></p>
</li>
<li>
<p><strong>指令周期由若干个子周期组成，比如取指周期、执行周期等</strong></p>
</li>
<li>
<p><strong>每个子周期包含若干个更小的操作，这些操作称为微操作</strong></p>
</li>
</ul>
<h5 id="fetch">Fetch</h5>
<ul>
<li>
<p>Program Counter (PC)</p>
<ul>
<li>Holds address of next instruction to be fetched</li>
</ul>
</li>
<li>
<p>Memory Address Register (MAR)</p>
<ul>
<li>
<p>Connected to address bus</p>
</li>
<li>
<p>Specifies address for read or write op</p>
</li>
</ul>
</li>
<li>
<p>Memory Buffer Register (MBR)</p>
<ul>
<li>
<p>Connected to data bus</p>
</li>
<li>
<p>Holds data to write or last data read</p>
</li>
</ul>
</li>
<li>
<p>Instruction Register (IR)</p>
<ul>
<li>Holds last instruction fetched</li>
</ul>
</li>
</ul>
<hr>
<p><strong>Step1</strong></p>
<a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter15-2.png" title="/img/Computer Organization and Architecture/chapter15-2.png" data-thumbnail="/img/Computer Organization and Architecture/chapter15-2.png">
        
    </a>
<ul>
<li>
<p><strong>下一个指令的地址是放在PC里</strong></p>
</li>
<li>
<p><strong>MAR是与地址总线连接的唯一寄存器</strong></p>
</li>
<li>
<p><strong>取指的第一步是PC把下一个指令的地址给MAR</strong></p>
</li>
<li>
<p><strong>经过第一步之后，PC寄存器的内容复制到MAR寄存器中</strong></p>
</li>
</ul>
<hr>
<p><strong>Step2</strong></p>
<a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter15-3.png" title="/img/Computer Organization and Architecture/chapter15-3.png" data-thumbnail="/img/Computer Organization and Architecture/chapter15-3.png">
        
    </a>
<ul>
<li>
<p>MAR收到地址后，把地址放到地址总线上</p>
</li>
<li>
<p>控制单元发一个读命令到控制总线上</p>
</li>
<li>
<p>存储器收到读命令后，根据地址读出指令内容，并放到数据总线</p>
</li>
<li>
<p>数据总线上的数据读到MBR</p>
</li>
<li>
<p>PC中还需要递增一个指令长度，以得到下一个指令的地址</p>
</li>
</ul>
<hr>
<p><strong>Step3</strong></p>
<a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter15-4.png" title="/img/Computer Organization and Architecture/chapter15-4.png" data-thumbnail="/img/Computer Organization and Architecture/chapter15-4.png">
        
    </a>
<ul>
<li>
<p>MBR的内容传送给IR</p>
</li>
<li>
<p>传送完成后，MBR就可以释放，用于下一步操作</p>
</li>
<li>
<p>IR中保存的就是下一个需要执行的指令</p>
</li>
<li>
<p>通过这几个微操作，完成了取指</p>
</li>
</ul>
<hr>
<p><strong>Fetch sequence</strong></p>
<ul>
<li>
<p>取指周期实际上由三步、四个微操作组成。每个微操作都涉及到数据在寄存器之间的流动</p>
</li>
<li>
<p>如果数据的流动是独立的，这些操作可以在同一个时钟周期内完成</p>
</li>
<li>
<p>PC递增微操作，既可以在t2完成，也可以在t3完成</p>
</li>
</ul>
<hr>
<p><strong>Rules for Micro-operations grouping</strong></p>
<ul>
<li>
<p>Proper sequence must be followed</p>
<ul>
<li>MAR &lt;- (PC) must precede MBR &lt;- (memory)</li>
</ul>
</li>
<li>
<p>Conflicts must be avoided</p>
<ul>
<li>
<p>Must not read &amp; write same register at same time</p>
</li>
<li>
<p>MBR &lt;- (memory) &amp; IR &lt;- (MBR) must not be in same cycle</p>
</li>
</ul>
</li>
<li>
<p>Also: PC &lt;- (PC) +1 involves addition</p>
<ul>
<li>
<p>Use ALU</p>
</li>
<li>
<p>May need additional micro-operations</p>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>Indirect cycle</strong></p>
<ul>
<li>In indirect addressing, it is necessary to get the address of the operand from the memory first. This process is called indirect cycle</li>
</ul>
<hr>
<p><strong>Interrupt cycle</strong></p>
<ul>
<li>
<p>After instruction processing is completed, check whether there is an interrupt</p>
</li>
<li>
<p>Interrupt cycle needs to complete these operations</p>
<ul>
<li>
<p>The instruction address before the interrupt needs to be saved</p>
</li>
<li>
<p>Get the instruction address of the start of the interrupt handler to the PC</p>
</li>
</ul>
</li>
<li>
<p>After the PC gets the interrupt processing address, it enters the index retrieval cycle</p>
</li>
</ul>
<hr>
<p><strong>Execute cycle</strong></p>
<ul>
<li>
<p>Fetching, indirect and interruption cycle can be determined in advance</p>
<ul>
<li>Each cycle contains a fixed sequence of micro operations</li>
</ul>
</li>
<li>
<p>For execution cycle</p>
<ul>
<li>
<p>Different operation codes correspond to different operations</p>
</li>
<li>
<p>Each operation has a specific micro operation sequence</p>
</li>
</ul>
</li>
</ul>
<h4 id="flowchart-for-instruction-cycle">Flowchart for instruction cycle</h4>
<a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter15-5.png" title="/img/Computer Organization and Architecture/chapter15-5.png" data-thumbnail="/img/Computer Organization and Architecture/chapter15-5.png">
        
    </a>
<ul>
<li>
<p>取指周期后，看是否是间接寻址。如果是间接寻址，进入01间接周期，如果不是，进入执行周期。</p>
</li>
<li>
<p>间接周期后，读取地址，然后进入10执行周期</p>
</li>
<li>
<p>执行周期，根据操作码来确定做什么操作。然后判断是否有中断。如果有中断，进入11中断周期。如果没有，进入00取指周期。</p>
</li>
<li>
<p>中断周期，设置中断，然后进入中断处理程序的取指周期，继续取指</p>
</li>
</ul>
<hr>
<ul>
<li>
<p>Control of the Processor</p>
<ul>
<li>
<p>Functional Requirements</p>
</li>
<li>
<p>Control Signals</p>
</li>
<li>
<p>A Control Signals Example</p>
</li>
<li>
<p>Internal Processor Organization</p>
</li>
</ul>
</li>
</ul>
<h4 id="functional-requirement">Functional requirement</h4>
<ul>
<li>
<p>Micro-operations are the most basic function of the processor</p>
</li>
<li>
<p>Three elements of the controller include</p>
<ul>
<li>
<p>Basic elements of processor</p>
</li>
<li>
<p>Micro-operations that processor performs</p>
</li>
<li>
<p>How to control</p>
</li>
<li>
<p>ALU</p>
</li>
<li>
<p>Registers</p>
</li>
<li>
<p>Internal data paths</p>
</li>
<li>
<p>External data paths</p>
</li>
<li>
<p>Control Unit</p>
</li>
</ul>
</li>
</ul>
<h4 id="types-of-micro-operation">Types of micro-operation</h4>
<ul>
<li>
<p>Micro-operations can be divided into the following four categories</p>
<ul>
<li>
<p>Transfer data between registers</p>
</li>
<li>
<p>Transfer data from register to external</p>
</li>
<li>
<p>Transfer data from external to register</p>
</li>
<li>
<p>Perform arithmetic or logical ops</p>
</li>
</ul>
</li>
</ul>
<h4 id="functions-of-control-unit">Functions of control unit</h4>
<ul>
<li>
<p>Operation object and operation type have been determined</p>
</li>
<li>
<p>Function of the controller is to determine how to do it</p>
<ul>
<li>
<p>Sequencing</p>
</li>
<li>
<p>Execution</p>
</li>
<li>
<p>This is done using Control Signals</p>
</li>
</ul>
</li>
</ul>
<h4 id="model-of-control-unit">Model of control unit</h4>
<a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter15-6.png" title="/img/Computer Organization and Architecture/chapter15-6.png" data-thumbnail="/img/Computer Organization and Architecture/chapter15-6.png">
        
    </a>
<ul>
<li>
<p>控制器的输入包括：时钟信号，各种标志，指令寄存器中的指令，来自控制总线的控制信号(中断)</p>
</li>
<li>
<p>控制器的输出包括：CPU内部的控制信号，到控制总线的控制信号</p>
</li>
<li>
<p><strong>控制器内部就是如何根据输入，来生成控制信号</strong></p>
</li>
</ul>
<hr>
<p><strong>Control signals</strong></p>
<ul>
<li>
<p>Clock</p>
<ul>
<li>Provide clock signal for timing of controller</li>
<li>One micro-instruction (or set of parallel micro-instructions) per clock cycle</li>
</ul>
</li>
<li>
<p>Instruction register</p>
<ul>
<li>
<p>Op-code for current instruction</p>
</li>
<li>
<p>Addressing mode</p>
</li>
<li>
<p>Determines which micro-instructions are performed</p>
</li>
</ul>
</li>
<li>
<p>Flags</p>
<ul>
<li>
<p>State of CPU</p>
</li>
<li>
<p>Results of previous operations</p>
</li>
</ul>
</li>
<li>
<p>Control signal from control bus</p>
<ul>
<li>
<p>Interrupts</p>
</li>
<li>
<p>Acknowledgements</p>
</li>
</ul>
</li>
<li>
<p>output</p>
<ul>
<li>
<p>Within CPU</p>
<ul>
<li>
<p>Cause data movement</p>
</li>
<li>
<p>Activate specific functions</p>
</li>
</ul>
</li>
<li>
<p>Via control bus</p>
<ul>
<li>
<p>To memory，control read or write</p>
</li>
<li>
<p>To I/O modules</p>
</li>
</ul>
</li>
<li>
<p><strong>It generates three types of output control signals</strong></p>
<ul>
<li>
<p>Data paths: the signals control the internal flow of data</p>
</li>
<li>
<p>ALU: the signals control the operation of the ALU</p>
</li>
<li>
<p>System bus: the control unit sends these signals to the control lines of the system bus</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="internal-organization">Internal organization</h4>
<ul>
<li>
<p>CPU adopts single bus structure</p>
<ul>
<li>
<p>All components, including ALU and registers, are connected to the bus</p>
</li>
<li>
<p>A gate is set between each component and the bus to control the data transmission between the component and the bus</p>
</li>
</ul>
</li>
<li>
<p>Data transfer to and from external systems bus is controlled by the control signal</p>
</li>
<li>
<p>Temporary registers needed for proper operation of ALU</p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter15-7.png" title="/img/Computer Organization and Architecture/chapter15-7.png" data-thumbnail="/img/Computer Organization and Architecture/chapter15-7.png" data-sub-html="<h2>Internal processor organization</h2>">
        
    </a><figcaption class="image-caption"><code>Internal processor organization</code></figcaption>
    </figure>
<ul>
<li>
<p>各个寄存器都链接到内部总线上。寄存器和内部总线之间有个逻辑门，用于寄存器和内部总线的连接控制</p>
</li>
<li>
<p>ALU没有内部存储部件。如果ALU的操作涉及2个操作数的话，一个由内部总线得到，另一个必须通过其他的数据源来得到，不能都在内部总线上。需要增加一个Y寄存器，用于临时保存源操作数</p>
</li>
<li>
<p>ALU还需要有一个寄存器，来临时保存输出结果。这个结果不能总线上，因为如果放总线上的话，它又会当作ALU的输入</p>
</li>
</ul>
<h4 id="implementation-of-control-unit">Implementation of control unit</h4>
<ul>
<li>
<p>The control unit implementation can be done by two methods</p>
<ul>
<li>
<p>Hardwired implementation</p>
</li>
<li>
<p>Microprogrammed implementation</p>
</li>
</ul>
</li>
<li>
<p>Hardwired implementation: the control unit is a combinational circuit</p>
<ul>
<li>The input signals are transferred into a set of output control signals</li>
</ul>
</li>
<li>
<p>时钟发生器：产生时钟信号，并提供计数器</p>
</li>
<li>
<p>译码器：根据指令寄存器中的指令操作码，生成操作码对应的唯一输出，提供给输出控制单元</p>
</li>
<li>
<p>标志：为控制单元提供相关的标志信号</p>
</li>
<li>
<p>控制单元：是控制器的核心，负责产生控制信号</p>
</li>
</ul>
<h4 id="control-matrix">Control matrix</h4>
<ul>
<li>
<p>Programmable arrays may also be numerous</p>
</li>
<li>
<p>Large control matrices are implemented hierarchically for speed</p>
</li>
</ul>
<h4 id="problems-with-hard-wired">Problems With Hard Wired</h4>
<ul>
<li>
<p>Complex micro-operation logic</p>
</li>
<li>
<p>Difficult to design and test</p>
</li>
<li>
<p>Inflexible design</p>
</li>
<li>
<p>Difficult to add new instructions</p>
</li>
</ul>
<h4 id="summary">Summary</h4>
<ul>
<li>
<p>The instructions are divided into a sequence of stages</p>
</li>
<li>
<p>Fetch, indirect, execute, interrupt</p>
</li>
<li>
<p>Each stage is further divided into a sequence of microoperations</p>
<ul>
<li>T1, T2, T3, …</li>
</ul>
</li>
<li>
<p>Each micro-operation occupies one clock unit</p>
</li>
<li>
<p>The function of the control unit is to produce a sequence of timed control signals to control the data paths and ALU operations</p>
</li>
<li>
<p>The control unit is a combinational circuit that transfers inputs to a group of control signals</p>
<ul>
<li>
<p>Inputs: flags, instruction registers, clock, control signals from system bus</p>
</li>
<li>
<p>Outputs: control signals to system bus and within CPU</p>
</li>
</ul>
</li>
</ul>
<h3 id="microprogrammed-control">Microprogrammed Control</h3>
<h4 id="basic-concepts">Basic Concepts</h4>
<ul>
<li>
<p>Control unit can be implemented by a more flexible technique called microprogrammed control unit</p>
<ul>
<li>
<p>The logic of the control unit is specified by a microprogram</p>
</li>
<li>
<p>Each line in microprogram describes a group of micro-operations in one time，called microinstruction</p>
</li>
<li>
<p>Construct a control word corresponding to this microinstruction</p>
</li>
<li>
<p>The control word determines the opening or closing of all doors</p>
</li>
</ul>
</li>
<li>
<p>微指令中包括CPU内控制信号、系统总线控制信号、跳转条件、微指令地址</p>
</li>
<li>
<p>执行这条微指令的效果是，打开CPU内外所有为1的控制线，关闭所有为0的控制线</p>
</li>
<li>
<p>如果条件条件为假，自动执行下一个顺序的微指令</p>
</li>
<li>
<p>如果跳转条件为真，则执行“微指令地址”中对应的微指令</p>
</li>
</ul>
<p><strong>Micro-instruction Types</strong></p>
<ul>
<li>
<p><strong>horizontal microinstruction</strong></p>
<ul>
<li>
<p>水平微指令包括四个部分</p>
<ul>
<li>内部控制信号：CPU内的每一个控制线都有相应的1位</li>
<li>总线控制信号：每一个系统控制总线都有相应的1位</li>
<li>条件字段：指示转移发生条件的字段</li>
<li>微指令地址：转移的目标指令地址</li>
</ul>
</li>
<li>
<p>打开位值为1的控制线，关闭所有位值为0的控制线。执行一个或多个微操作</p>
</li>
<li>
<p>如果跳转条件为假，顺序执行下一个指令。如果跳转条件为真，执行“微指令地址” 指向的微指令</p>
</li>
<li>
<p><strong>Characteristic</strong></p>
<ul>
<li>
<p>Each control line inside the CPU and bus needs to have a separate control bit</p>
<ul>
<li>The width of the control word is very large</li>
</ul>
</li>
<li>
<p>Each line is a separate control bit</p>
<ul>
<li>Each control line can be controlled independently</li>
<li>More kinds of micro operations that can be supported</li>
</ul>
</li>
</ul>
</li>
<li>
<p>The control lines are controlled by one bit of the control word independently</p>
<ul>
<li>The coding of control signal is not compact</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>vertical microinstruction</strong></p>
<ul>
<li>
<p>垂直微指令也包括条件和跳转微指令地址，跟水平微指令类似</p>
</li>
<li>
<p>在控制方面，和水平微指令的每一位对应一个控制线不同，垂直微指令又做了一次编码</p>
</li>
<li>
<p>解决水平微指令的控制字太长的问题</p>
</li>
<li>
<p>编码后，由一个解码器再翻译成控制线的控制信号</p>
</li>
<li>
<p><strong>Characteristic</strong></p>
<ul>
<li>
<p>Width is narrow</p>
<ul>
<li>
<p>n control signals encoded into $\log_2 n$ bits($n \rightarrow 2^n$)</p>
</li>
<li>
<p>Limited number of micro operations supported</p>
</li>
</ul>
</li>
<li>
<p>Additional steps required</p>
<ul>
<li>External memory word decode is needed</li>
<li>Identify the exact control line being manipulated</li>
<li>Send control signal</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="micro-program-word-length">Micro-program Word Length</h4>
<ul>
<li>
<p><strong>Word length is an important factor in microprogram</strong></p>
</li>
<li>
<p><strong>Word length is determined by three factors</strong>\</p>
<ul>
<li>
<p><strong>Maximum number of simultaneous micro-operations supported</strong></p>
</li>
<li>
<p><strong>The way control information is represented or encoded</strong></p>
</li>
<li>
<p><strong>The way in which the next micro-instruction address is specified</strong></p>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>Compromise</strong></p>
<ul>
<li>
<p>Divide control signals into disjoint groups</p>
</li>
<li>
<p>Implement each group as separate field in memory word</p>
</li>
<li>
<p>Supports reasonable levels of parallelism without too much complexity</p>
</li>
</ul>
<h4 id="the-control-memory">The control memory</h4>
<ul>
<li>
<p>The control words are put into a special memory block called control memory, with each word having a unique address</p>
</li>
<li>
<p>The microinstructions are organized as different routines</p>
<ul>
<li>
<p>The microinstructions in each routine are executed sequentially</p>
</li>
<li>
<p>Each routine ends with a branch instruction points to the next routine</p>
</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter15-8.png" title="/img/Computer Organization and Architecture/chapter15-8.png" data-thumbnail="/img/Computer Organization and Architecture/chapter15-8.png" data-sub-html="<h2>Control memory</h2>">
        
    </a><figcaption class="image-caption"><code>Control memory</code></figcaption>
    </figure>
<ul>
<li>
<p>存储控制器中存储了取指例程、间接例程、中断例程、执行例程等，这些例程规定了在每个周期内需要执行的微操作序列</p>
</li>
<li>
<p>例程中还规定了在执行结束后转移到下面哪一个例程，也就是指定了周期的执行顺序</p>
</li>
<li>
<p>例如，取指周期后，可能会到间接周期，也可能到执行周期，需要根据取指周期来确定</p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter15-9.png" title="/img/Computer Organization and Architecture/chapter15-9.png" data-thumbnail="/img/Computer Organization and Architecture/chapter15-9.png" data-sub-html="<h2>Control Unit Microarchitecture</h2>">
        
    </a><figcaption class="image-caption"><code>Control Unit Microarchitecture</code></figcaption>
    </figure>
<ul>
<li>
<p><strong>Sequencing logic</strong></p>
</li>
<li>
<p><strong>Control address register</strong></p>
</li>
<li>
<p><strong>Control memory</strong></p>
</li>
<li>
<p><strong>Control buffer register</strong></p>
</li>
<li>
<p>控制存储器：存储微指令</p>
</li>
<li>
<p>控制地址寄存器：包含下一个将要被读取的微指令地址。类似于PC</p>
</li>
<li>
<p>控制缓冲寄存器：微指令由控制存储器读取之后，放到控制缓冲寄存器中。控制缓冲寄存器的左半部分直接和控制线连接，读取微指令直接生成控制信号，控制门的开或关</p>
</li>
<li>
<p>定序逻辑：负责为控制地址寄存器提供地址，并发出读命令</p>
</li>
</ul>
<h4 id="control-unit-function">Control Unit Function</h4>
<ul>
<li>
<p>Sequence logic unit issues read command</p>
<ul>
<li>
<p>Word specified in control address register is read into control buffer register</p>
</li>
<li>
<p>Control buffer register contents generates control signals and next address information</p>
</li>
</ul>
</li>
<li>
<p>Sequence logic loads new address into control address register based on next address information from control buffer register and ALU flags</p>
</li>
</ul>
<h4 id="next-address-decision">Next Address Decision</h4>
<ul>
<li>
<p>Sequencing logic needs to determine the next microinstruction</p>
<ul>
<li>At the end of each microinstruction, the next microinstruction address is loaded into the control address register</li>
</ul>
</li>
<li>
<p>Depending on ALU flags and control buffer register</p>
<ul>
<li>
<p>Next microinstruction in sequence</p>
</li>
<li>
<p>Jump to a new routine based on jump instructions</p>
</li>
<li>
<p>Jump to a machine instruction routine</p>
</li>
</ul>
</li>
</ul>
<h4 id="next-address">Next Address</h4>
<ul>
<li>
<p>Next microinstruction in sequence</p>
<ul>
<li>Add 1 to control address register</li>
</ul>
</li>
<li>
<p>Jump to new routine based on jump microinstruction</p>
<ul>
<li>Load address field of control buffer register into control address register</li>
</ul>
</li>
<li>
<p>Jump to machine instruction routine</p>
<ul>
<li>Load control address register based on opcode in IR</li>
</ul>
</li>
</ul>
<hr>
<ol>
<li>
<p>指令译码器是将指令寄存器中的操作码翻译成控制寄存器地址</p>
</li>
<li>
<p>控制地址寄存器到控制存储器中找到控制字，并放到控制缓冲寄存器中</p>
</li>
<li>
<p><strong>控制缓冲寄存器进行控制操作。如果是垂直微指令，则需要译码器进行译码后生成控制信号</strong></p>
</li>
<li>
<p>控制信号译码器用于垂直微指令，将控制字翻译成控制线的控制信号，发送到CPU内部和系统总线</p>
</li>
<li>
<p>对于垂直微指令，有一个附加逻辑和时间延迟</p>
</li>
<li>
<p>下一个微指令地址给定序逻辑，以确定执行哪一个微指令</p>
</li>
</ol>
<h4 id="simple-summary">Simple summary</h4>
<ul>
<li>
<p>All the control unit does is generate a set of control signals</p>
<ul>
<li>
<p>Control the opening and closing of each gate</p>
</li>
<li>
<p>Use one control bit to represent the control signal of a door</p>
</li>
<li>
<p>Control bits of all gates constitute control words</p>
</li>
</ul>
</li>
<li>
<p>Have a control word for each group of micro-operations in one time</p>
</li>
<li>
<p>The next microinstruction can be specified in the microinstruction and executed conditionally</p>
</li>
</ul>
<hr>
<ul>
<li>
<p>For machine code instruction</p>
<ul>
<li>
<p>It is generally divided into multiple cycles, such as fetch cycle, execution cycle, etc</p>
</li>
<li>
<p>Multiple microoperations need to be completed</p>
</li>
<li>
<p>Each microoperation corresponds to one control word</p>
</li>
<li>
<p>A group of control words realizes the control function of a machine code</p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p>Today’s large microprocessor</p>
<ul>
<li>
<p>Many instructions and associated register-level hardware</p>
</li>
<li>
<p>Many control points to be manipulated</p>
</li>
</ul>
</li>
<li>
<p>This results in control memory that</p>
<ul>
<li>
<p>Contains a large number of words，co-responding to the number of instructions to be executed</p>
</li>
<li>
<p>Has a wide word width，due to the large number of control points to be manipulated</p>
</li>
</ul>
</li>
</ul>
<h4 id="advantages-and-disadvantages">Advantages and Disadvantages</h4>
<ul>
<li>
<p>Advantages</p>
<ul>
<li>
<p>Simplifies design of control unit</p>
</li>
<li>
<p>Cheaper</p>
</li>
<li>
<p>Less error-prone</p>
</li>
</ul>
</li>
<li>
<p>Disadvantages</p>
<ul>
<li>
<p>Additional processing required</p>
</li>
<li>
<p>Slower</p>
</li>
</ul>
</li>
</ul>
<h4 id="microinstruction-sequencing">Microinstruction Sequencing</h4>
<ul>
<li>
<p>Microinstruction controller has two basic tasks</p>
<ul>
<li>
<p>Microinstruction sequencing： Get the next microinstruction from the control memory</p>
</li>
<li>
<p>Microinstruction execution : Through control word generates control signal for executing the micro instruction</p>
</li>
</ul>
</li>
<li>
<p>Must consider both together</p>
<ul>
<li>Affects instruction format and controller timing</li>
</ul>
</li>
</ul>
<h4 id="sequencing-techniques">Sequencing Techniques</h4>
<ul>
<li>
<p>Two problems must be considered</p>
<ul>
<li>
<p>Size of microinstructions</p>
</li>
<li>
<p>Address generation time</p>
</li>
</ul>
</li>
<li>
<p>Size of microinstructions</p>
<ul>
<li>The larger the microinstruction, the larger the control memory, and the more expensive</li>
<li>Size of microinstructions should be reduced</li>
</ul>
</li>
<li>
<p>Address generation time</p>
<ul>
<li>The requirement to execute microinstructions as quickly as possible</li>
</ul>
</li>
</ul>
<h5 id="address-generation-time">Address generation time</h5>
<ul>
<li>
<p>Determined by instruction register</p>
<ul>
<li>Once per cycle, after instruction is fetched</li>
</ul>
</li>
<li>
<p>Next sequential address</p>
<ul>
<li>Use in most cases</li>
</ul>
</li>
<li>
<p>Branch</p>
<ul>
<li>
<p>Both conditional and unconditional</p>
</li>
<li>
<p>Generally, there is a jump after 3-4 microinstructions</p>
</li>
<li>
<p>Very important</p>
</li>
</ul>
</li>
</ul>
<h5 id="sequencing-techniques-1">Sequencing Techniques</h5>
<ul>
<li>
<p>Based on current microinstruction, condition flags, contents of IR, generate control memory address of next microinstruction</p>
</li>
<li>
<p>The jump of microinstructions can be divided into three modes according to the address information format in the microinstructions</p>
<ul>
<li>
<p>Two address fields</p>
<ul>
<li>
<p>对于双地址字段模式，微指令中提供了2个地址字段</p>
</li>
<li>
<p>控制缓冲寄存器读取微指令后，第一部分产生控制信号，第二部分和第三部分是2个地址，这2个地址，加上指令寄存器的内容，连接到一个多路器中。多路器选择一个送到控制地址寄存器中</p>
</li>
<li>
<p>控制地址寄存器通过译码，产生下一个微指令的地址。地址选择的输入是由转移逻辑模块来完成的，它根据微指令中的控制部分，以及标志位，向多路器提供选择信号</p>
</li>
<li>
<p>双地址字段方式比较简单，微指令中有2个地址，需要更多的位</p>
</li>
</ul>
</li>
<li>
<p>Single address field</p>
<ul>
<li>
<p>单地址字段方式中，微指令中只有一个地址。下一个地址的选择方法是：</p>
<ul>
<li>
<p>地址字段中指定的地址</p>
</li>
<li>
<p>指令寄存器中的代码</p>
</li>
<li>
<p>下一个顺序地址</p>
</li>
</ul>
</li>
<li>
<p>下一个顺序地址是用上一次的控制地址寄存器中的地址+1来得到的</p>
</li>
</ul>
</li>
<li>
<p>Variable format</p>
<ul>
<li>
<p>可变格式提供两种不同格式的指令。用1位来标识当前是哪种格式。</p>
</li>
<li>
<p>在一种格式中，所有位都用于产生控制信号。所以，下一个微指令的地址，或者是下一顺序地址，或者是由指令寄存器来指定</p>
</li>
<li>
<p>另一种格式中，有一些位用于启动转移逻辑模块，其余的位来提供地址。这样就可以进行条件或者无条件转移</p>
</li>
<li>
<p>这种方法的缺点是转移微指令需要花费一个时钟周期</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="microinstruction-execution">Microinstruction Execution</h4>
<ul>
<li>
<p>Microinstruction execution is a periodic basic even</p>
</li>
<li>
<p>Each cycle is made up of two events</p>
<ul>
<li>
<p>Fetch</p>
</li>
<li>
<p>Execute</p>
</li>
</ul>
</li>
<li>
<p>Fetch</p>
<ul>
<li>Get the microinstruction from the control memory according to the generated microinstruction address</li>
</ul>
</li>
<li>
<p>Execute</p>
<ul>
<li>Execute microinstructions and generate control signals</li>
</ul>
</li>
</ul>
<h4 id="execution-effect">Execution effect</h4>
<ul>
<li>
<p>Effect is to generate control signals</p>
</li>
<li>
<p>Internal</p>
<ul>
<li>
<p>Control signals inside the processor</p>
</li>
<li>
<p>Control the internal components of the processor</p>
</li>
</ul>
</li>
<li>
<p>External</p>
<ul>
<li>
<p>Control signals to external control bus or other interface</p>
</li>
<li>
<p>Control disk read-write, I/O read-write etc</p>
</li>
</ul>
</li>
<li>
<p>With the function to generate next address</p>
</li>
</ul>
<h4 id="summary-1">Summary</h4>
<ul>
<li>
<p>A microprogrammed control unit is a relatively simple logic circuit that is capable of</p>
<ul>
<li>
<p>Sequencing through microinstructions</p>
</li>
<li>
<p>Generating control signals to execute each microinstruction</p>
</li>
</ul>
</li>
</ul>
]]></description>
</item>
<item>
    <title>Computer Organization and Architecture Instruction Level Parallelism and Superscalar Processors</title>
    <link>https://Jungle430.github.io/posts/computer-organization-and-architecture/computer-organization-and-architecture-instruction-level-parallelism-and-superscalar-processors/</link>
    <pubDate>Mon, 30 Jan 2023 16:28:39 &#43;0800</pubDate><author>1239946358@qq.com (Jungle)</author><guid>https://Jungle430.github.io/posts/computer-organization-and-architecture/computer-organization-and-architecture-instruction-level-parallelism-and-superscalar-processors/</guid>
    <description><![CDATA[<h1 id="computer-organization-and-architecture">Computer Organization and Architecture</h1>
<h2 id="instruction-level-parallelism-and-superscalar-processors">Instruction Level Parallelism and Superscalar Processors</h2>
<h3 id="outline">Outline</h3>
<ul>
<li>
<p>Overview of Superscalar</p>
</li>
<li>
<p>Design Issues of Superscalar</p>
</li>
<li>
<p>Superscalar in Pentium</p>
</li>
<li>
<p>Superscalar in ARM CORTEX-A8</p>
</li>
</ul>
<h3 id="overview-of-superscalar">Overview of Superscalar</h3>
<figure><a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter14-1.png" title="/img/Computer Organization and Architecture/chapter14-1.png" data-thumbnail="/img/Computer Organization and Architecture/chapter14-1.png" data-sub-html="<h2>Ideal pipeline</h2>">
        
    </a><figcaption class="image-caption"><code>Ideal pipeline</code></figcaption>
    </figure>
<ul>
<li>
<p>理想的指令流水线的执行过程</p>
</li>
<li>
<p>指令执行分为6个阶段，且不共享资源</p>
</li>
<li>
<p>每个时间单位都会有1个指令完成执行</p>
</li>
<li>
<p>指令数量足够多时，执行效率为原来的6倍</p>
</li>
</ul>
<hr>
<p><strong>Actual pipeline</strong></p>
<ul>
<li>
<p>Not all instructions require the same steps</p>
<ul>
<li>Some pipeline stages are idle</li>
</ul>
</li>
<li>
<p>Running time of different pipeline stages is different</p>
<ul>
<li>running time of some pipeline stages is wasted</li>
</ul>
</li>
<li>
<p>Instructions are not independent of each other</p>
<ul>
<li>Poor operation of the pipeline</li>
</ul>
</li>
</ul>
<h4 id="problem-about-pipeline">Problem about pipeline</h4>
<ul>
<li>
<p>The pipeline pauses due to dependencies between instructions, which is called pipeline risk</p>
</li>
<li>
<p>There are three types of dependencies</p>
<ul>
<li>
<p>Data dependence</p>
</li>
<li>
<p>Control dependence</p>
</li>
<li>
<p>resource dependence</p>
</li>
</ul>
</li>
</ul>
<h4 id="question">Question</h4>
<ul>
<li>
<p>Is instruction pipelining truly parallel?</p>
<ul>
<li>
<p>Yes: There are indeed multiple instructions in the pipeline being processed at the same time</p>
</li>
<li>
<p>No: multiple instructions do not enter the pipeline at the same time</p>
</li>
</ul>
</li>
<li>
<p>How to further improve the execution efficiency of instructions?</p>
<ul>
<li>
<p>Optimize pipeline: super pipeline</p>
</li>
<li>
<p>True instruction level parallelism: superscalar pipelining</p>
</li>
</ul>
</li>
</ul>
<h4 id="superpipeline">Superpipeline</h4>
<ul>
<li>
<p>In an ordinary pipeline, each clock cycle can complete processing of one pipeline stage</p>
</li>
<li>
<p>Many pipeline stages need less than half a clock cycle</p>
</li>
<li>
<p>Superpipeline</p>
<ul>
<li>
<p>Double internal clock rate is adopted for instruction scheduling</p>
</li>
<li>
<p>Double internal clock speed gets two tasks per external clock cycle</p>
</li>
</ul>
</li>
<li>
<p>Get twice the instruction throughput</p>
</li>
</ul>
<a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter14-2.png" title="/img/Computer Organization and Architecture/chapter14-2.png" data-thumbnail="/img/Computer Organization and Architecture/chapter14-2.png">
        
    </a>
<ul>
<li>
<p>四阶段流水线，指令划分为4个阶段</p>
</li>
<li>
<p>普通流水线中，每个阶段需要1个时钟周期来完成。最高能达到4倍的指令执行效率，每个时钟周期可以输出1个指令的执行结果</p>
</li>
<li>
<p>超级流水线。通过采用双倍内部时钟的方式，每0.5个外部时钟周期，就能完成1个指令阶段的执行。最高能达到8倍的执行效率</p>
</li>
</ul>
<h5 id="limit-of-superpipeline">Limit of Superpipeline</h5>
<ul>
<li>
<p>The effect is similar to that of increasing the main frequency</p>
</li>
<li>
<p><strong>It is still not really instruction level parallelism</strong></p>
</li>
<li>
<p>The overall performance is limited by the clock cycle and the length of time the instruction phase executes</p>
<ul>
<li>Long execution phases affect overall performance</li>
</ul>
</li>
<li>
<p><strong>Another technology-superscalar</strong></p>
</li>
</ul>
<h4 id="vector-and-scalar">Vector and Scalar</h4>
<ul>
<li>
<p>Scalar</p>
<ul>
<li>
<p>Also called “vector free”. Some physical quantities have only numerical value, but no direction. Some of them are positive or negative</p>
</li>
<li>
<p>A single number used to represent a single attribute of a thing</p>
</li>
<li>
<p>For example: temperature, length</p>
</li>
</ul>
</li>
<li>
<p>Vector</p>
<ul>
<li>
<p>Originally refers to a quantity with size and direction</p>
</li>
<li>
<p>A group of orderly arranged numbers used to demarcate the quantitative characteristics of things</p>
</li>
<li>
<p>For example: the position of a point in the plane coordinate system$ (x, y) $</p>
</li>
</ul>
</li>
</ul>
<h5 id="scalar-instruction">Scalar instruction</h5>
<ul>
<li>
<p>The instructions that do not have vector processing functions and only operate on a single quantity, namely a scalar quantity, are called scalar instructions</p>
</li>
<li>
<p>Most instructions are scalar</p>
</li>
</ul>
<h5 id="vector-instruction">Vector instruction</h5>
<ul>
<li>
<p>The basic operating object is a vector, that is, a group of numbers arranged in order</p>
</li>
<li>
<p>The instruction determines the address of the vector operand and directly or implicitly specifies vector parameters such as increment, vector length, etc</p>
</li>
<li>
<p>The vector instruction specifies that the processor processes vector according to the same operation, which can effectively improve the operation speed</p>
</li>
<li>
<p>Some mainframes are equipped with vector operation instruction systems with complete functions</p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter14-3.png" title="/img/Computer Organization and Architecture/chapter14-3.png" data-thumbnail="/img/Computer Organization and Architecture/chapter14-3.png" data-sub-html="<h2>Superscalar</h2>">
        
    </a><figcaption class="image-caption"><code>Superscalar</code></figcaption>
    </figure>
<ul>
<li>
<p>超标量采用了2个独立的流水线</p>
</li>
<li>
<p>每个流水线都可以再进行指令的并行运行</p>
</li>
<li>
<p>能够并行执行每个阶段的2个指令</p>
</li>
<li>
<p>在稳定运行的状态下，可以达到8倍的执行效率</p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter14-4.png" title="/img/Computer Organization and Architecture/chapter14-4.png" data-thumbnail="/img/Computer Organization and Architecture/chapter14-4.png" data-sub-html="<h2>Ceneral Superscalar organization</h2>">
        
    </a><figcaption class="image-caption"><code>Ceneral Superscalar organization</code></figcaption>
    </figure>
<ul>
<li>
<p>包含了2个整数运算单元，2个浮点数运算单元，一个存储单元</p>
</li>
<li>
<p>整数运算单元中，允许有2个指令并行执行，浮点数运算单元也允许2个浮点指令同时运行。与此同时，1个存储器操作也可以并行来执行</p>
</li>
<li>
<p>这个结构中，同时允许5个指令并行执行</p>
</li>
</ul>
<h4 id="key-problem-of-superscalar">Key problem of superscalar</h4>
<ul>
<li>
<p>Superscalar implementations raise a number of complex design issues related to the instruction pipeline</p>
<ul>
<li>
<p>First, the relevance of the pipeline itself still exists</p>
</li>
<li>
<p>Multiple pipelines bring more complex correlation problems</p>
</li>
</ul>
</li>
<li>
<p>The compiler is required to have more complex optimization techniques to achieve greater instruction level parallelism</p>
</li>
</ul>
<h5 id="application-of-superscalar">Application of superscalar</h5>
<ul>
<li>
<p><strong>Superscalar technology itself is proposed and developed with the development of RISC technology</strong></p>
</li>
<li>
<p>RISC processors also tend to use superscalar technology</p>
</li>
<li>
<p><strong>Although RISC machine lends itself readily to superscalar techniques, the superscalar approach can be used on either a RISC or CISC architecture</strong></p>
</li>
<li>
<p><strong>Superscalar approach has now become the standard method for implementing high-performance microprocessors</strong></p>
</li>
</ul>
<h4 id="factors-limiting-parallelism">Factors limiting parallelism</h4>
<ul>
<li>
<p>Instruction level parallelism</p>
<ul>
<li>The degree to which program instructions can be executed in parallel</li>
</ul>
</li>
<li>
<p>Compiler capabilities</p>
<ul>
<li>The compiler can maximize instruction level parallelism of programs</li>
</ul>
</li>
<li>
<p>Hardware techniques</p>
<ul>
<li>Hardware capability supports parallel operation of instructions</li>
</ul>
</li>
</ul>
<h4 id="limitations">Limitations</h4>
<ul>
<li>
<p>The most important reason for limiting instruction level parallelism is the correlation between instructions in the program</p>
</li>
<li>
<p>The dependencies between instructions include</p>
<ul>
<li>
<p>True data dependency</p>
</li>
<li>
<p>Output dependency</p>
</li>
<li>
<p>Anti-dependency</p>
</li>
<li>
<p>Procedural dependency</p>
</li>
<li>
<p>Resource conflicts</p>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>True Data Dependency</strong></p>
<a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter14-5.png" title="/img/Computer Organization and Architecture/chapter14-5.png" data-thumbnail="/img/Computer Organization and Architecture/chapter14-5.png">
        
    </a>
<ul>
<li>
<p>I0和i1能够同时进行取指和解码</p>
</li>
<li>
<p><strong>但是由于i1取的操作数是i0的结果，所以必须要等到i0执行完之后，i1才能进行取指</strong></p>
</li>
<li>
<p>第二条指令存在一个时钟周期的延迟</p>
</li>
<li>
<p><strong>先写后读，也称为“写后读相关性”</strong></p>
</li>
<li>
<p><strong>这种相关性和指令的执行顺序严格相关，是真实的相关性</strong></p>
</li>
</ul>
<hr>
<p><strong>Procedural dependency</strong></p>
<a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter14-6.png" title="/img/Computer Organization and Architecture/chapter14-6.png" data-thumbnail="/img/Computer Organization and Architecture/chapter14-6.png">
        
    </a>
<ul>
<li>
<p>分支前和分支后的指令不能并行执行</p>
</li>
<li>
<p>如果指令非定长，则必须对指令进行解码，才能确定取多长的指令</p>
</li>
<li>
<p><strong>如果使用的是变长指令，在取后续指令之前，前一个指令必须要部分译码，否则下一个指令不知道从内存的哪个位置去取，这阻止了同时取指的操作</strong></p>
</li>
<li>
<p>超标量更适合RISC架构的理由之一，因为RISC的指令都是定长的，不会有这种相关性</p>
</li>
</ul>
<hr>
<p><strong>Resource conflict</strong></p>
<ul>
<li>
<p>资源冲突，也称为资源相关性</p>
</li>
<li>
<p>指令i0和i1在执行过程中，都需要用到同一个功能单元，所以他们不能并行执行，只能串行处理。这里浪费了一个时钟周期</p>
</li>
<li>
<p>资源冲突和数据相关性的表现差不多，但是资源冲突可以通过复制资源来解决，例如在前面讲到的增加干衣机</p>
</li>
</ul>
<h3 id="design-issues-of-superscalar">Design Issues of Superscalar</h3>
<h4 id="parallelism">Parallelism</h4>
<ul>
<li>
<p><strong>Factors limiting parallelism</strong></p>
<ul>
<li>
<p><strong>Instruction level parallelism</strong></p>
</li>
<li>
<p><strong>Compiler capabilities</strong></p>
</li>
<li>
<p><strong>Hardware techniques</strong></p>
</li>
</ul>
</li>
<li>
<p>Instruction level parallelism</p>
<ul>
<li>
<p>Instructions have the characteristics of parallel execution</p>
</li>
<li>
<p>Instructions in a sequence are independent</p>
</li>
<li>
<p>Execution can be overlapped</p>
</li>
<li>
<p>Governed by data and procedural dependency</p>
</li>
</ul>
</li>
</ul>
<h5 id="machine-parallelism">Machine Parallelism</h5>
<ul>
<li>
<p>Machine Parallelism</p>
<ul>
<li>
<p>Ability to take advantage of instruction level parallelism</p>
</li>
<li>
<p>Governed by number of parallel pipelines</p>
</li>
<li>
<p>The ability to find independent instructions and obtain instruction level parallelism</p>
</li>
</ul>
</li>
<li>
<p>Instructions that can be executed in parallel</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Load R1 &lt;- R2(23)
</span></span><span class="line"><span class="cl">Add R3 &lt;- R3, &#34;1&#34;
</span></span><span class="line"><span class="cl">Add R4 &lt;- R4, R2
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>Instructions that cannot be executed in parallel</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Add R3 &lt;- R3, &#34;1&#34;
</span></span><span class="line"><span class="cl">Add R4 &lt;- R3, R2
</span></span><span class="line"><span class="cl">Store[R4] &lt;- R0
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="instruction-issue">Instruction issue</h4>
<ul>
<li>
<p><strong>Instruction issue： the process of starting instructions to be executed by the functional unit of the processor</strong></p>
<ul>
<li>Instruction issue occurs when instruction moves from the decode stage of the pipeline to the first execute stage of the pipeline</li>
</ul>
</li>
<li>
<p><strong>In order to improve the parallelism, it is necessary to use a reasonable issue order, instead of the original order</strong></p>
</li>
<li>
<p>In essence, instruction emission is a strategy to find instructions that can enter the pipeline and be executed</p>
</li>
</ul>
<h5 id="order-about-instruction-issue">Order about instruction issue</h5>
<ul>
<li>
<p>Three sequences are involved in the command sending process</p>
<ul>
<li>
<p>Order in which instructions are fetched</p>
</li>
<li>
<p>Order in which instructions are executed</p>
</li>
<li>
<p>Order in which instructions change registers and memory</p>
</li>
</ul>
</li>
<li>
<p>The one constraint on the processor is that the result must be correct</p>
</li>
<li>
<p>Instruction issue policy refers to the protocol used to start the execution of the command</p>
</li>
</ul>
<h5 id="instruction-issue-policy">Instruction issue policy</h5>
<ul>
<li>
<p><strong>The original instruction stream itself has dependencies</strong></p>
</li>
<li>
<p>To improve the parallelism of execution, the processor may change the order in which instructions are executed</p>
</li>
<li>
<p>The more sophisticated the processor, the less it is bound by a strict relationship between these orderings</p>
</li>
<li>
<p><strong>There are three issue policy</strong></p>
<ul>
<li>
<p><strong>In-order issue with in-order completion</strong></p>
</li>
<li>
<p><strong>In-order issue with out-of-order completion</strong></p>
</li>
<li>
<p><strong>Out-of order issue with out-of –order completion</strong></p>
</li>
</ul>
</li>
</ul>
<h6 id="in-order-issuein-order-completion">In-order issue/in-order completion</h6>
<ul>
<li>
<p>Issue instructions in the order they occur</p>
</li>
<li>
<p>Write the results in the same order to complete the execution of instructions</p>
</li>
<li>
<p><strong>Very inefficient，even scalar pipeline will not use policy</strong></p>
</li>
<li>
<p>In Superscalar pipeline</p>
<ul>
<li>
<p>May fetch more than one instruction</p>
</li>
<li>
<p><strong>To ensure orderly completion, when the functional units conflict, or the execution of the functional units requires multiple cycles, instruction issue must wait</strong></p>
</li>
</ul>
</li>
</ul>
<a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter14-7.png" title="/img/Computer Organization and Architecture/chapter14-7.png" data-thumbnail="/img/Computer Organization and Architecture/chapter14-7.png">
        
    </a>
<ul>
<li>
<p><strong>超标量处理器有2个独立的流水线，能够同时取2个指令</strong></p>
</li>
<li>
<p><strong>有3个执行单元，以及2个写回的单元</strong></p>
</li>
<li>
<p>I1需要2个周期完成执行；I3和I4需要同时使用某个功能单元，导致出现冲突；I5依赖于I4的结果；I5和I6需要同时使用某个功能单元，导致出现冲突</p>
</li>
<li>
<p>成对取指并送到译码单元进行译码。I1需要花费2个时钟周期执行。所以I3和I4需要在第四个周期开始执行。由于I3和I4资源冲突，所以I3和I4需要顺序执行。I5需要依赖I4的结果，并且I5和I6存在资源冲突，所以I5和I6需要串行执行</p>
</li>
<li>
<p>8个指令，总共需要8个时钟周期才能完成</p>
</li>
<li>
<p>由于指令执行的时间不一样，所以如果同时发射的指令给执行单元，需要等全部执行完成之后，才能进行下一次发射</p>
</li>
<li>
<p>如果指令间存在数据依赖关系，需要停止调度行为，等具备条件之后，才能进行指令发射</p>
</li>
</ul>
<hr>
<h6 id="in-order-issueout-of-order-completion">In-order issue/out-of-order completion</h6>
<a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter14-8.png" title="/img/Computer Organization and Architecture/chapter14-8.png" data-thumbnail="/img/Computer Organization and Architecture/chapter14-8.png">
        
    </a>
<ul>
<li>
<p>I1和I2同时发射到执行单元，由于I2只需要1个周期完成，所以I2可以先完成。I3可以和I1同时执行，并进入写的阶段</p>
</li>
<li>
<p>I4由于和I3资源冲突，所以需要等I3完成之后才能执行。I5依赖于I4的结果，所以也需要等待I4，同理I6需要等待I5</p>
</li>
<li>
<p>整体上需要7个周期完成指令的执行</p>
</li>
</ul>
<hr>
<p><strong>Output (write-write) dependency</strong></p>
<ul>
<li>In the process of out of sequence completion, the execution order is different from the original order, which may lead to output dependency problems</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">R3 = R3 + R5 ;(l1)
</span></span><span class="line"><span class="cl">R4 = R3 + 1  ;(l2)
</span></span><span class="line"><span class="cl">R3 = R5 + 1  ;(l3)
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>Analyze
<ul>
<li>I2 depends on result of I1 - data dependency</li>
<li>If I3 completes before I1, the result from I1 will be wrong - output (write-write) dependency</li>
</ul>
</li>
</ul>
<hr>
<p><strong>How?</strong></p>
<ul>
<li>
<p><strong>Adopt dynamic scheduling strategy</strong></p>
</li>
<li>
<p>Idea: Move the dependent instructions out of the way of independent ones (s.t. independent ones can execute)</p>
<ul>
<li>Rest areas for dependent instructions: Reservation stations</li>
</ul>
</li>
<li>
<p>Monitor the source “values” of each instruction in the resting area</p>
</li>
<li>
<p>When all source “values” of an instruction are available, “fire” (i.e. dispatch) the instruction</p>
<ul>
<li>Instructions dispatched in <strong>data-flow order，not control-flow</strong></li>
</ul>
</li>
<li>
<p>Benefit</p>
<ul>
<li>
<p>Latency tolerance: Allows independent instructions to execute and complete in the presence of a long latency operation</p>
</li>
<li>
<p>Reasonably schedule instructions with dependencies</p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p><strong>Problem about In-order issue</strong></p>
</li>
<li>
<p>When decoding instructions, if there are related points or conflicting points, the decoding needs to stop</p>
</li>
<li>
<p>In this way, subsequent instructions cannot be decoded</p>
</li>
<li>
<p>At this time, the processor cannot check whether any instruction is independent and can be executed on the pipeline</p>
</li>
</ul>
<hr>
<h6 id="out-of-order-issueout-of-order-completion">Out-of-order issue/out-of-order completion</h6>
<ul>
<li>
<p>Solution: decouple decode from execution</p>
</li>
<li>
<p>Decode</p>
<ul>
<li>
<p>Decode stage can continuously fetch and decode</p>
</li>
<li>
<p>Decoded instruction is put into the buffer</p>
</li>
<li>
<p>As long as the buffer is not full, fetching and decoding can continue</p>
</li>
</ul>
</li>
<li>
<p>Execution</p>
<ul>
<li>
<p>When the functional unit is available, transmit the executable instructions to execute</p>
</li>
<li>
<p>Since the instruction has been decoded, the processor can first identify whether the instruction can be executed</p>
</li>
</ul>
</li>
</ul>
<a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter14-9.png" title="/img/Computer Organization and Architecture/chapter14-9.png" data-thumbnail="/img/Computer Organization and Architecture/chapter14-9.png">
        
    </a>
<ul>
<li>第一个周期，I1和I2进行解码，完成解码后进入发射缓冲区。执行单元为空，I1和I2被发射出去执行</li>
<li>第二个周期，I3和I4进行解码，完成解码后进入发射缓冲区。由于I3和I4共用执行单元，I3发射出去进行执行</li>
<li>第三个周期，I5和I6进行解码，完成解码后进入发射缓冲区。此时，I3执行完了，所以I4可以发射了。同时由于I5和I4有数据相关性，所以I5不能发射，于是把I6发射出去执行</li>
<li>第四个周期，没有指令需要解码</li>
<li>第五个周期，没有指令需要解码。此时发射缓冲区只有I5。I6执行完成，可以发射I5指令。I5在第五个时钟周期完成执行，并在第六个时钟周期完成写入操作</li>
<li>整个过程需要6个时钟周期。比之前的又缩短了1个周期</li>
</ul>
<h6 id="anti-dependencywrite-after-read">Anti-dependency(Write-after-read)</h6>
<ul>
<li>
<p>Out-of-order issue/out-of-order completion also need to comply with restrictions</p>
</li>
<li>
<p>Anti correlation occurs</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">R3 = R3 + R5 ;l1
</span></span><span class="line"><span class="cl">R4 = R3 + 1  ;l2
</span></span><span class="line"><span class="cl">R3 = R5 + 1  ;l3
</span></span><span class="line"><span class="cl">R7 = R3 + R4 ;l4
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>Analyze
<ul>
<li>I3 can not complete before I2 starts as I2 needs a value in R3 and I3 changes R3</li>
</ul>
</li>
</ul>
<hr>
<p><strong>Dependency Analyzing</strong></p>
<ul>
<li>
<p>True data dependency reflects the real dependency between data</p>
</li>
<li>
<p>In essence, anti dependency and output dependency are caused by register conflict</p>
<ul>
<li>Register contents may not reflect the correct ordering from the program</li>
</ul>
</li>
<li>
<p>Instruction issue stops, pipeline stall</p>
<ul>
<li>Processor pauses for one cycle</li>
</ul>
</li>
<li>
<p>This situation is more serious when register optimization technology is used</p>
<ul>
<li>
<p>Register optimization technology maximizes the use of registers to improve performance</p>
</li>
<li>
<p>Register conflicts will be more significant</p>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>Register renaming</strong></p>
<ul>
<li>
<p>Registers are dynamically allocated by hardware</p>
</li>
<li>
<p>When an instruction with a register as the destination operand is executed, a new register is allocated</p>
</li>
<li>
<p><strong>The instruction that accesses the original register after this instruction must be modified to the newly allocated register to maintain consistency</strong></p>
</li>
<li>
<p>Avoid dependencies caused by register conflicts</p>
</li>
</ul>
<hr>
<ul>
<li><strong>Original</strong></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">R3 = R3 + R5 ;I1
</span></span><span class="line"><span class="cl">R4 = R3 + 1  ;I2
</span></span><span class="line"><span class="cl">R3 = R5 + 1  ;I3
</span></span><span class="line"><span class="cl">R7 = R3 + R4 ;I4
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>I1和I2存在真实数据相关性</p>
</li>
<li>
<p>I3和I4存在真实数据相关性</p>
</li>
<li>
<p>I3和I2存在反相关性，读后写</p>
</li>
<li>
<p>I3和I1存在输出相关性，写后写</p>
</li>
<li>
<p><strong>Register renaming</strong></p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">R3b = R3a + R5a ;l1
</span></span><span class="line"><span class="cl">R4b = R3b + 1   ;l2
</span></span><span class="line"><span class="cl">R3c = R5a + 1   ;l3
</span></span><span class="line"><span class="cl">R7 = R3c + R4b  ;l4
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>采用寄存器重命名的规则，I1的R3修改成R3b，I3中的R3，修改成R3c。</p>
</li>
<li>
<p><strong>I3和I2之间的反相关性没有了，I3和I1之间的输出相关性也没有了，I3可以立即发射</strong></p>
</li>
<li>
<p><strong>真实数据相关性无法通过寄存器重命名来解决</strong></p>
</li>
</ul>
<h4 id="analysis-of-three-technologies---">Analysis of three technologies ! ! !</h4>
<ul>
<li>
<p><strong>Techniques for improving performance in superscalar processors</strong></p>
<ul>
<li>
<p><strong>Duplication of Resources</strong></p>
</li>
<li>
<p><strong>Out of order issue</strong></p>
</li>
<li>
<p><strong>Renaming</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>Resources are the foundation</strong></p>
<ul>
<li>Sufficient resources to execute multiple pipelines</li>
</ul>
</li>
<li>
<p><strong>Out of order issue is the method</strong></p>
<ul>
<li>Provide executable instructions through disordered transmissionRenaming is a guarantee</li>
</ul>
</li>
<li>
<p><strong>Renaming is a guarantee</strong></p>
<ul>
<li>Rename mechanism reduces the correlation between instructions</li>
</ul>
</li>
</ul>
<h4 id="about-instruction-window">About instruction window</h4>
<ul>
<li>
<p>Out of order issue: register window is used to cache instructions after decoding</p>
</li>
<li>
<p>Through the register window, the processor can identify independent instructions that can be placed in the execution segment</p>
</li>
<li>
<p><strong>If the instruction window is very small, the probability of successful recognition is very low</strong></p>
</li>
<li>
<p><strong>The instruction window needs to be large enough to find independent instructions and use the hardware more effectively</strong></p>
</li>
<li>
<p><strong>Need instruction window large enough (more than 8)</strong></p>
</li>
</ul>
<hr>
<p><strong>Effect of technology</strong></p>
<figure><a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter14-10.png" title="/img/Computer Organization and Architecture/chapter14-10.png" data-thumbnail="/img/Computer Organization and Architecture/chapter14-10.png" data-sub-html="<h2>Without Procedural Dependencies</h2>">
        
    </a><figcaption class="image-caption"><code>Without Procedural Dependencies</code></figcaption>
    </figure>
<ul>
<li>
<p>Base：不复制任何功能单元</p>
</li>
<li>
<p>+Id/st：增加了装入/存储单元</p>
</li>
<li>
<p>+alu：增加了ALU单元</p>
</li>
<li>
<p>+both：增加了ALU和Id/st</p>
</li>
<li>
<p>不考虑过程相关性</p>
</li>
<li>
<p>没有采用寄存器重命名，增加硬件执行效果并不明显。而采用寄存器重命名后，增加了ALU会明显提高加速比</p>
</li>
<li>
<p>从发射窗口的角度来看，窗口数量从8个增加到16个，效果就很明显。但从16个到32个，效果稍差一些</p>
</li>
<li>
<p><strong>资源复制、乱序发射、寄存器重命名三者相互影响</strong></p>
</li>
</ul>
<h4 id="consideration-of-control-dependence">Consideration of control dependence</h4>
<ul>
<li>
<p>Also called branch hazard</p>
</li>
<li>
<p>When branching instructions, it is not possible to determine which instruction to execute after the branch</p>
</li>
<li>
<p>In the pipeline, after prefetching the wrong instruction, it is necessary to discard and re fetch the instruction, which causes the pipeline to fail to run with full load</p>
</li>
</ul>
<p><strong>Methods</strong></p>
<ul>
<li>
<p>Processing method of control dependence</p>
<ul>
<li>
<p>Multiple Streams</p>
</li>
<li>
<p>Prefetch Branch Target</p>
</li>
<li>
<p>Loop buffer</p>
</li>
<li>
<p>Branch prediction</p>
</li>
<li>
<p>Delayed branching</p>
</li>
</ul>
</li>
<li>
<p>Goal: Keep the pipeline running full</p>
</li>
</ul>
<p><strong>About delayed branch</strong></p>
<ul>
<li>
<p>Delayed branching is often used in RIS</p>
</li>
<li>
<p>Calculate result of branch before unusable instructions pre-fetched</p>
<ul>
<li>
<p>Instructions that are not affected by branches are immediately followed by branch</p>
</li>
<li>
<p>Keeps pipeline full while fetching new instruction stream</p>
</li>
</ul>
</li>
<li>
<p>Not as good for superscalar</p>
<ul>
<li>Multiple instructions need to execute in delay slot</li>
<li>Instruction dependence problems</li>
<li>Often use branch prediction</li>
</ul>
</li>
</ul>
<p><strong>Superscalar execution</strong></p>
<ul>
<li>
<p>静态程序通过取指和分支预测，形成动态的指令流</p>
</li>
<li>
<p>指令流经过处理器的相关性检查，会去掉不必要的相关性，比如反相关和输出相关。然后将指令放到执行窗口中，等待执行</p>
</li>
<li>
<p>在执行窗口中的指令，根据真实数据相关性来排序。处理器根据真实数据相关性和资源可用性，来发射指令到执行单元进行执行</p>
</li>
<li>
<p>最后的执行结果需要有一个提交的步骤。因为指令不是按照原有的顺序来执行的，同时分支预测和推测执行使得有些执行的结果需要丢弃</p>
</li>
</ul>
<hr>
<ul>
<li>
<p>Simultaneously fetch multiple instructions</p>
<ul>
<li>
<p>Multiple fetching and decoding</p>
</li>
<li>
<p>Branch prediction logic</p>
</li>
</ul>
</li>
<li>
<p>Logic to determine true dependencies involving register values</p>
<ul>
<li>Determine instruction position of true correlation</li>
</ul>
</li>
<li>
<p>Dealing with unnecessary dependencies</p>
<ul>
<li>Anti-dependency and output dependency</li>
</ul>
</li>
<li>
<p>Mechanisms to initiate multiple instructions in parallel</p>
<ul>
<li>
<p>Instruction window</p>
</li>
<li>
<p>Out of order issue logic</p>
</li>
</ul>
</li>
<li>
<p>Resources for parallel execution of multiple instructions</p>
<ul>
<li>The system has sufficient resources</li>
</ul>
</li>
<li>
<p>Mechanisms for committing process state in correct order</p>
<ul>
<li>Submit results according to the order of instructions</li>
</ul>
</li>
</ul>
<h4 id="summary">Summary</h4>
<ul>
<li>
<p><strong>Resources are the foundation</strong></p>
<ul>
<li><strong>Machine parallelism</strong></li>
</ul>
</li>
<li>
<p><strong>Out of order issue is the method</strong></p>
<ul>
<li><strong>Instruction level parallelism</strong></li>
</ul>
</li>
<li>
<p><strong>Renaming is a guarantee</strong></p>
<ul>
<li><strong>Methods of improving instruction level parallelism</strong></li>
</ul>
</li>
<li>
<p>Through superscalar pipeline, multiple pipelines can run at the same time to achieve truly parallel operation at the instruction level</p>
</li>
</ul>
]]></description>
</item>
<item>
    <title>Computer Organization and Architecture Reduced Instruction Set Computers</title>
    <link>https://Jungle430.github.io/posts/computer-organization-and-architecture/computer-organization-and-architecture-reduced-instruction-set-computers/</link>
    <pubDate>Sun, 29 Jan 2023 16:34:59 &#43;0800</pubDate><author>1239946358@qq.com (Jungle)</author><guid>https://Jungle430.github.io/posts/computer-organization-and-architecture/computer-organization-and-architecture-reduced-instruction-set-computers/</guid>
    <description><![CDATA[<h1 id="computer-organization-and-architecture">Computer Organization and Architecture</h1>
<h2 id="reduced-instruction-set-computers">Reduced Instruction Set Computers</h2>
<h3 id="outline">Outline</h3>
<ul>
<li>
<p>Register and instruction architecture</p>
</li>
<li>
<p>Reduced Instruction Set Architecture</p>
</li>
<li>
<p>The Use of a Large Register File</p>
</li>
<li>
<p>Compiler-Based Register Optimization</p>
</li>
<li>
<p><code>RISC</code> Pipelining</p>
</li>
<li>
<p><code>RISC</code> Versus <code>CISC</code> Controversy</p>
</li>
</ul>
<h3 id="register-and-instruction-architecture">Register and instruction architecture</h3>
<p><strong>Major advanced in computers</strong></p>
<ul>
<li>
<p><strong>The family concept</strong></p>
<ul>
<li>
<p>IBM System/360 1964，DEC PDP-8</p>
</li>
<li>
<p><strong>Separates architecture from implementation</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>Microprogrammed control unit</strong></p>
<ul>
<li>
<p>Idea by Wilkes 1951,Produced by IBM S/360 1964</p>
</li>
<li>
<p><strong>Easier controller design and implementation</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>Cache</strong></p>
<ul>
<li>
<p>IBM S/360 model 85 1969</p>
</li>
<li>
<p><strong>Greatly improves the performance of computer</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>Microprocessors</strong></p>
<ul>
<li>
<p>Intel 4004 1971</p>
</li>
<li>
<p><strong>Reduced the size of the computer</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>Pipelining</strong></p>
<ul>
<li>
<p><strong>Introducing parallelism into instruction execution</strong></p>
</li>
<li>
<p><strong>Greatly improves instruction throughput</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>Multiple processors</strong></p>
<ul>
<li>
<p><strong>Multiple processors combine to form a new architecture</strong></p>
</li>
<li>
<p><strong>Further improve the processing capacity of the computer</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>RISC</strong></p>
<ul>
<li>
<p>Major challenges to traditional CPU</p>
</li>
<li>
<p>It has been widely used</p>
</li>
<li>
<p>Learn from RISC and be widely used in different fields</p>
</li>
</ul>
</li>
<li>
<p>Solid State RAM</p>
<ul>
<li>Access speed is much faster than mechanical hard disk</li>
<li>Greatly improves the computer’s I/O performance</li>
</ul>
</li>
</ul>
<h4 id="register-and-isas">Register and ISAs</h4>
<ul>
<li>
<p>Accumulators</p>
<ul>
<li>
<p>Early stored-program computers had <strong>one</strong> register</p>
</li>
<li>
<p>Very inconvenient to use</p>
</li>
<li>
<p>Requires a memory-based operand-addressing mode in instruction</p>
</li>
</ul>
</li>
</ul>
<p>Example</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ADD 200
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p><strong>Add the accumulator to the word in memory at address 200</strong></p>
</li>
<li>
<p>Place the sum back in the accumulator</p>
</li>
</ul>
<hr>
<ul>
<li>
<p>Next step, more registers…</p>
<ul>
<li>
<p>Dedicated registers</p>
<ul>
<li>
<p>separate accumulators for multiply or divide instructions</p>
</li>
<li>
<p>op-of-stack pointer</p>
</li>
</ul>
</li>
<li>
<p>Extended Accumulator</p>
<ul>
<li>Increase bits of register</li>
<li>Increase the number of registers</li>
</ul>
</li>
</ul>
</li>
<li>
<p>More flexible</p>
</li>
</ul>
<hr>
<ul>
<li>
<p>Next step, more registers…</p>
<ul>
<li>General-purpose registers
<ul>
<li>Registers can be used for any purpose E.g. MIPS, ARM, x86</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Instruction architecture</p>
<ul>
<li>
<p><em>Register-memory</em> architectures</p>
<ul>
<li><strong>One operand may be in memory</strong> (i.e. 80386 processors)</li>
</ul>
</li>
<li>
<p><em>Register-register</em> architectures (load-store)</p>
<ul>
<li><strong>All operands must be in registers</strong> E.g. MIPS, ARM</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="comparison-of-processors">Comparison of processors</h4>
<ul>
<li>
<p>指令数量、长度、寻址方式等方面，CISC明显高于RISC</p>
</li>
<li>
<p>RISC和超标量的通用寄存器数量比CISC要多</p>
</li>
<li>
<p>RISC和超标量一般采用硬布线控制，所以没有配置控制存储器</p>
</li>
</ul>
<h3 id="reduced-instruction-set-architecture">Reduced Instruction Set Architecture</h3>
<h4 id="cisc">CISC</h4>
<ul>
<li>
<p><strong>CISC&ndash;Complex Instruction Set Computer</strong></p>
</li>
<li>
<p>With the development of computer technology, an instruction set design concept is proposed</p>
</li>
</ul>
<hr>
<ul>
<li>
<p>The gap between high-level programming languages and instruction sets is growing</p>
<ul>
<li>
<p><strong>Need more complex compilers to translate high-level languages</strong></p>
</li>
<li>
<p><strong>A high-level language statement requires multiple instructions to complete，low execution efficiency</strong></p>
</li>
</ul>
</li>
<li>
<p>CISC proposed by instruction set designer</p>
<ul>
<li>
<p><strong>Provides more types of instructions, and even uses a single instruction to implement complex high-level language statements</strong></p>
</li>
<li>
<p><strong>Provide more addressing modes to meet the needs of high-level languages for various addressing</strong></p>
</li>
</ul>
</li>
</ul>
<h5 id="characteristics-of-cisc">Characteristics of CISC</h5>
<ul>
<li>
<p>There are many kinds of instruction opcodes</p>
<ul>
<li>The opcode of X86 is 1-2 bytes</li>
</ul>
</li>
<li>
<p>Variable instruction length</p>
<ul>
<li>The instruction length of X86 is 1-16 bytes</li>
</ul>
</li>
<li>
<p>Various addressing modes</p>
<ul>
<li><strong>X86 has 9 addressing modes</strong>, such as base address proportional index band offset</li>
</ul>
</li>
</ul>
<h5 id="ideal-effect-of-cisc">Ideal effect of CISC</h5>
<ul>
<li>
<p><strong>Compilers are easy to write</strong></p>
<ul>
<li>
<p>The instruction set provides many types of instructions</p>
</li>
<li>
<p>The compiler can use the most appropriate instructions to translate statements in high-level languages. Less instructions after compilation and less space</p>
</li>
<li>
<p>The instruction set provides rich addressing modes</p>
</li>
<li>
<p>Meet the requirements of high-level language for flexible addressing mode</p>
</li>
</ul>
</li>
<li>
<p>Improve the execution efficiency of high-level language statements</p>
<ul>
<li>
<p>It used to require multiple instructions to complete statements in a high-level language, but now it can be completed with one instruction, and some high-level language statements can be implemented at the hardware level</p>
</li>
<li>
<p>Instruction level addressing mode to help implement complex instructions</p>
</li>
</ul>
</li>
</ul>
<h5 id="instruction-execution-characteristics">Instruction execution characteristics</h5>
<ul>
<li>
<p>Operations performed</p>
<ul>
<li>Functions that can be completed by CPU and interaction with memory</li>
</ul>
</li>
<li>
<p>Operands used</p>
<ul>
<li>Type and frequency of operands，which determine the organization and addressing mode of the storage system</li>
</ul>
</li>
<li>
<p>Execution sequencing</p>
<ul>
<li>Control function and pipeline organization</li>
</ul>
</li>
</ul>
<h6 id="operations">Operations</h6>
<ul>
<li>
<p>It is best to optimize the most used and time-consuming statements</p>
</li>
<li>
<p>Assignments</p>
<ul>
<li>Movement of data</li>
</ul>
</li>
<li>
<p>Condition(Loop and IF)</p>
<ul>
<li>Sequence control</li>
</ul>
</li>
<li>
<p>Procedure call-return</p>
<ul>
<li>Very time consuming</li>
</ul>
</li>
<li>
<p><strong>过程调用和返回是典型的高级语言程序中最耗时的操作</strong></p>
</li>
<li>
<p><strong>循环语句、条件语句和幅值语句也占很大的比重</strong></p>
</li>
</ul>
<hr>
<ul>
<li>Operands
<ul>
<li>
<p>主要是局部标量变量</p>
</li>
<li>
<p>优化方向应集中于本地变量的存储和访问</p>
</li>
</ul>
</li>
</ul>
<h5 id="procedure-calls">Procedure calls</h5>
<ul>
<li>
<p><strong>Very time consuming</strong></p>
<ul>
<li>
<p>Depends on number of parameters passed</p>
</li>
<li>
<p>Depends on level of nesting</p>
</li>
</ul>
</li>
<li>
<p>Characteristics</p>
<ul>
<li>
<p>Number of parameter is mostly less than 6</p>
</li>
<li>
<p>Most variables are local</p>
</li>
<li>
<p>Most programs do not do a lot of calls followed by lots of returns</p>
</li>
</ul>
</li>
<li>
<p>It further explains that operand access is highly localized</p>
</li>
</ul>
<h5 id="summary">Summary</h5>
<ul>
<li>
<p>Assignment statement</p>
<ul>
<li>
<p>high proportion, valuable to improve efficiency</p>
</li>
<li>
<p>Need to access cache or storage</p>
</li>
<li>
<p>Use register access to reduce memory access and improve efficiency</p>
</li>
</ul>
</li>
<li>
<p>Condition and procedure calls</p>
<ul>
<li>
<p>time consuming, high proportion, valuable to improve efficiency</p>
</li>
<li>
<p>Influence the execution of the pipeline</p>
</li>
<li>
<p>Design a better pipeline to reduce the impact of transfer statements on the water line</p>
</li>
</ul>
</li>
</ul>
<p><strong>单纯依靠提供接近于高级语言的指令并不一定能提高典型语句的执行效率</strong></p>
<hr>
<ul>
<li>
<p><strong>Ideal 1 of CISC: Compilers are easy to write</strong></p>
</li>
<li>
<p>Implementation method: complex instruction</p>
</li>
<li>
<p>Compiler simplification?</p>
<ul>
<li>
<p>Because of strict requirements of instruction design，compiler needs high-level language strictly meet the instruction</p>
</li>
<li>
<p>The compiler needs to optimize machine instructions to reduce the length of generated machine code and meet the requirements of pipeline operation. This is also difficult to achieve for complex instructions Optimization more difficult</p>
</li>
</ul>
</li>
<li>
<p><strong>Ideal 2 of CISC: smaller programs</strong></p>
</li>
<li>
<p>Implementation method: mores instruction</p>
</li>
<li>
<p>Smaller programs?</p>
<ul>
<li>
<p>Program looks using less memory</p>
</li>
<li>
<p>Memory is now cheap</p>
</li>
<li>
<p>May not occupy less bits, just look shorter in symbolic form</p>
</li>
<li>
<p>More instructions require longer op-codes</p>
</li>
<li>
<p>CISC has no fewer machine instructions than RISC</p>
</li>
</ul>
</li>
<li>
<p><strong>Ideal 3 of CISC: high efficiency</strong></p>
</li>
<li>
<p>Implementation method: more instructions and more addressing mode</p>
</li>
<li>
<p>Faster programs?</p>
<ul>
<li>
<p>Compiler bias towards use of simpler instructions</p>
</li>
<li>
<p>CISC need more complex control unit</p>
</li>
<li>
<p>Microprogram control store larger</p>
</li>
<li>
<p>Simple instructions take longer to execute</p>
</li>
</ul>
</li>
</ul>
<h5 id="conclusion">Conclusion</h5>
<ul>
<li>
<p>The goal CISC hopes to achieve is actually contradictory to the way CISC realizes it</p>
</li>
<li>
<p>Target: improve operational efficiency by optimizing the most frequently used and time-consuming functions</p>
</li>
<li>
<p>Following methods may be better choices</p>
<ul>
<li>
<p>More registers to reduce memory access</p>
</li>
<li>
<p>Careful design of pipeline to improve the efficiency of the pipeline</p>
</li>
<li>
<p>Careful designed simple instruction set to improve the efficiency of instruction execution</p>
</li>
</ul>
</li>
</ul>
<h4 id="risc">RISC</h4>
<ul>
<li>
<p>RISC: Reduced Instruction Set Computer</p>
</li>
<li>
<p>Key features</p>
<ul>
<li>
<p><strong>Large number of general purpose registers</strong></p>
</li>
<li>
<p><strong>Compiler technology to optimize register use</strong></p>
</li>
<li>
<p><strong>Limited and simple instruction set</strong></p>
</li>
<li>
<p><strong>Emphasis on optimising the instruction pipeline</strong></p>
</li>
</ul>
</li>
</ul>
<p><strong>Main contributors of RISC</strong></p>
<ul>
<li>
<p>John Cocke: IBM</p>
<ul>
<li>Influences: Known as “the father of RISC Architecture”. Turing Award Recipient and National Medal of Science</li>
</ul>
</li>
<li>
<p>Dave Patterson: UC Berkeley</p>
<ul>
<li>Influences: Sun SPARC from his achievements</li>
</ul>
</li>
<li>
<p>John L. Hennessy: Stanford</p>
<ul>
<li>Influences: In 1984, MIPS (Microprocessor without interlocked pipelined stages) was founded</li>
</ul>
</li>
</ul>
<h5 id="typical-features-of-risc">Typical features of RISC</h5>
<ul>
<li>
<p><strong>Simplified instruction set</strong></p>
<ul>
<li>
<p><strong>Standardized, fixed length</strong> instruction format (ARM instructions are all 32-bit)</p>
</li>
<li>
<p><strong>Limited operation types, only 8-bit operation code</strong></p>
</li>
<li>
<p><strong>Fetching and decoding instruction become easier</strong></p>
</li>
<li>
<p>One instruction per machine cycle</p>
</li>
<li>
<p>Hardwired design (no microcode)</p>
</li>
</ul>
</li>
<li>
<p>Use registers whenever possible</p>
<ul>
<li>
<p>Except for load/save instructions, other instructions are for register operations</p>
</li>
<li>
<p><strong>Data operations can only be performed in registers</strong></p>
</li>
<li>
<p><strong>Memory access has only three addressing modes</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>Better pipeline design</strong></p>
<ul>
<li>
<p>Instruction pipeline is carefully designed to better meet the impact of conditional branches and procedure calls on the flow pipeline</p>
</li>
<li>
<p><strong>Each instruction is conditionally executed, which can reduce branches</strong></p>
</li>
</ul>
</li>
</ul>
<h5 id="influence-of-risc-concept">Influence of RISC concept</h5>
<ul>
<li>
<p><strong>RISC&rsquo;s design concept gave birth to a series of new computer architectures</strong></p>
<ul>
<li>Simplified pipeline design on RISC instruction set is becoming more and more attractive</li>
</ul>
</li>
<li>
<p><strong>RISC and CISC learn from each other</strong></p>
<ul>
<li>
<p>Make up for the disadvantage of CISC pipeline implementation</p>
</li>
<li>
<p>RISC is also learning from CISC, and both sides are learning from each other</p>
</li>
</ul>
</li>
<li>
<p><strong>Current situation</strong></p>
</li>
<li>
<p>With the development of architecture and microelectronics technology, the so-called disadvantage of CISC in structure is gradually reduced</p>
</li>
<li>
<p>RISC&rsquo;s theory of superiority has gradually died down, and RISC camp has been losing ground</p>
</li>
</ul>
<blockquote>
<p>Focus on the design and implementation of micro structures and physics, and explore the possibilities buried in operating systems, compilers and upper applications</p>
</blockquote>
<h5 id="summary-1">Summary</h5>
<ul>
<li>
<p>The number of available registers greatly influenced the <strong>instruction set architecture (ISA)</strong></p>
</li>
<li>
<p>Complex Instruction Set Computers were very complex</p>
</li>
<li>
<p><strong>CISC was necessary</strong></p>
<ul>
<li>
<p>The processor of X86 architecture dominates the server and desktop market</p>
</li>
<li>
<p>X86 draws many advantages from RISC</p>
</li>
</ul>
</li>
<li>
<p><strong>RISC is still widely concerned and applied</strong></p>
<ul>
<li>
<p><strong>ARM occupies a major share of the embedded market</strong></p>
</li>
<li>
<p><strong>Mobile phones, tablets PC and various sensors in daily life mostly adopt ARM architecture</strong></p>
</li>
<li>
<p><strong>ARM borrows a bit from both RISC and CISC</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="the-use-of-a-large-register-file">The Use of a Large Register File</h3>
<ul>
<li>
<p>Target: Keep frequently accessed operands in registers</p>
</li>
<li>
<p>Software solution</p>
<ul>
<li>
<p>Require compiler to allocate registers</p>
</li>
<li>
<p>Allocate based on most used variables in a given time</p>
</li>
<li>
<p>Requires sophisticated program analysis</p>
</li>
</ul>
</li>
<li>
<p>Hardware solution</p>
<ul>
<li>
<p>Have more registers</p>
</li>
<li>
<p>Thus more variables will be in registers</p>
</li>
</ul>
</li>
</ul>
<h4 id="how-and-problem">How and problem?</h4>
<ul>
<li>
<p>Limited number of registers requires reasonable use, and the locality principle provides the possibility</p>
<ul>
<li>
<p>Store local scalar variables in registers</p>
</li>
<li>
<p>Reduces memory access</p>
</li>
</ul>
</li>
<li>
<p><strong>Every procedure (function) call changes locality</strong></p>
<ul>
<li>
<p>Parameters must be passed</p>
</li>
<li>
<p>Results must be returned</p>
</li>
<li>
<p>Variables from calling programs must be restored</p>
</li>
</ul>
</li>
</ul>
<h4 id="register-windows">Register windows</h4>
<ul>
<li>
<p><strong>Characteristics of procedure call</strong></p>
<ul>
<li>
<p><strong>Only few parameters</strong></p>
</li>
<li>
<p><strong>Limited range of depth of call</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>Divide the available registers into several small registers set</strong></p>
<ul>
<li>
<p><strong>Calls switch to a different set of registers</strong></p>
</li>
<li>
<p><strong>Returns switch back to a previously used set of registers</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>Set of registers called register windows</strong></p>
</li>
</ul>
<hr>
<ul>
<li>
<p><strong>Three areas within a register set</strong></p>
<ul>
<li>
<p><strong>Parameter registers</strong></p>
</li>
<li>
<p><strong>Local registers</strong></p>
</li>
<li>
<p><strong>Temporary registers</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>Temporary registers from one set overlap parameter registers from the next</strong></p>
<ul>
<li><strong>This allows parameter passing without moving data</strong></li>
</ul>
</li>
<li>
<p><strong>At any time, only one register window is visible</strong></p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter13-1.png" title="/img/Computer Organization and Architecture/chapter13-1.png" data-thumbnail="/img/Computer Organization and Architecture/chapter13-1.png" data-sub-html="<h2>Overlapping register windows</h2>">
        
    </a><figcaption class="image-caption"><code>Overlapping register windows</code></figcaption>
    </figure>
<ul>
<li>
<p>本级的临时变量寄存器和下一级的参数寄存器在物理上是同一个，在传递参数时，不需要移动数据</p>
</li>
<li>
<p>程序中过程的调用和返回的数量不确定，所以寄存器窗口应该足够多，以保证所有的过程调用都能用到</p>
</li>
<li>
<p>由于寄存器的数量有限，只能保证少数最近的过程能够使用寄存器。更早的过程调用还是需要保存到存储器中。当嵌套深度减少的时候，再将数据从存储器恢复到寄存器中</p>
</li>
<li>
<p>这种方式称为<strong>环形缓冲窗口</strong></p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter13-2.png" title="/img/Computer Organization and Architecture/chapter13-2.png" data-thumbnail="/img/Computer Organization and Architecture/chapter13-2.png" data-sub-html="<h2>Circular buffer diagram</h2>">
        
    </a><figcaption class="image-caption"><code>Circular buffer diagram</code></figcaption>
    </figure>
<ul>
<li>
<p><strong>寄存器窗口以一种部分重叠的形式形成一个环形。当环形寄存器窗口都充满了后，再有过程调用，把最早的寄存器窗口保存到存储器</strong></p>
</li>
<li>
<p>调用时，移动当前窗口指针以显示当前活动的寄存器窗口</p>
</li>
<li>
<p><strong>如果所有窗口都在使用中，将生成一个中断，并将最早的窗口（调用嵌套中最远的窗口）保存到内存中</strong></p>
</li>
<li>
<p>保存的窗口指针标识最近保存在内存中的窗口</p>
</li>
<li>
<p>当过程返回的时候，CWP会回退一个。当CWP回退到和SWP一样的时候，就会引起一个中断，导致保存到存储器中的寄存器窗口恢复</p>
</li>
<li>
<p>嵌套层数不会太深，所以一般不会保存到存储器中</p>
</li>
</ul>
<h4 id="global-variables">Global variables</h4>
<ul>
<li>
<p>Allocated by the compiler to memory</p>
<ul>
<li>
<p><strong>Inefficient for frequently accessed variables</strong></p>
</li>
<li>
<p><strong>Frequent access to memory, low efficiency</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>A set of registers for global variables</strong></p>
<ul>
<li>
<p><strong>compiler determines which global variables can be placed in global registers</strong></p>
</li>
<li>
<p><strong>Replacement is also determined by the compiler</strong></p>
</li>
</ul>
</li>
</ul>
<h4 id="registers-v-cache">Registers v cache</h4>
<ul>
<li>
<p>Cache</p>
<ul>
<li>Inserting cache between processor and memory can solve the problem of speed difference</li>
</ul>
</li>
<li>
<p>Register</p>
<ul>
<li>organized in the form of windows, which is similar to a small fast buffer. It stores a subset of all variables that may be used many times</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p>寄存器组中保存的是所有局部标量变量。cache保存的是最近使用过的标量变量</p>
</li>
<li>
<p>寄存器组中保存的是个别的变量。cache中保存的是内存中的一个块</p>
</li>
<li>
<p>寄存器组方案中，需要编译器来决定全局变量的保存。cache中则是根据最近使用原则进行管理</p>
</li>
<li>
<p>寄存器的数据保存或者恢复，依赖的是过程调用嵌套的深度。cache根据替换算法进行替换</p>
</li>
<li>
<p>寄存器组采用的是寄存器寻址。cache采用的是内存寻址</p>
</li>
</ul>
<hr>
<ul>
<li>
<p>The register saves time because all local scalar variables are retained</p>
<ul>
<li>Not efficient use of space, because not all procedures will need the full window space allocated to them</li>
</ul>
</li>
<li>
<p>The cache may make more efficient use of space because it stores necessary data dynamically</p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter13-3.png" title="/img/Computer Organization and Architecture/chapter13-3.png" data-thumbnail="/img/Computer Organization and Architecture/chapter13-3.png" data-sub-html="<h2>Register access</h2>">
        
    </a><figcaption class="image-caption"><code>Register access</code></figcaption>
    </figure>
<ul>
<li>
<p>要访问基于窗口的寄存器组中的一个标量变量，需要给出窗口号和一个寄存器号</p>
</li>
<li>
<p>通过一个相对简单的译码器，就可以得到对应的寄存器，读出这个数据</p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter13-4.png" title="/img/Computer Organization and Architecture/chapter13-4.png" data-thumbnail="/img/Computer Organization and Architecture/chapter13-4.png" data-sub-html="<h2>Cache access</h2>">
        
    </a><figcaption class="image-caption"><code>Cache access</code></figcaption>
    </figure>
<ul>
<li>
<p>对于cache访问，需要生成一个完整的地址，操作的复杂度和寻址方式有关</p>
</li>
<li>
<p>进行对比，看数据是否命中</p>
</li>
<li>
<p>如果命中，就可以读取数据</p>
</li>
<li>
<p>如果没有命中，那么就需要先替换cache行，然后才能得到数据</p>
</li>
</ul>
<h3 id="compiler-based-register-optimization">Compiler-Based Register Optimization</h3>
<ul>
<li>
<p><strong>HLL programs have no explicit references to registers</strong></p>
</li>
<li>
<p><strong>Optimizing use is up to compiler</strong></p>
<ul>
<li>
<p>Assign symbolic or virtual register to each candidate variable</p>
</li>
<li>
<p>Map symbolic registers to real registers</p>
</li>
<li>
<p>Symbolic registers that do not overlap can share real registers</p>
</li>
<li>
<p>If you run out of real registers，some variables use memory</p>
</li>
</ul>
</li>
<li>
<p><strong>The essence is to judge which data needs to be put in the register at any time</strong></p>
</li>
</ul>
<h4 id="graph-coloring">Graph coloring</h4>
<ul>
<li>
<p>Symbol registers is more than register</p>
</li>
<li>
<p>determine which symbol registers can use the actual registers</p>
</li>
<li>
<p><strong>Using Graph Coloring of topology</strong></p>
<ul>
<li>
<p>Given a graph of nodes and edges</p>
</li>
<li>
<p>Assign a colour to each node</p>
</li>
<li>
<p>Adjacent nodes have different colours</p>
</li>
<li>
<p>Use minimum number of colours</p>
</li>
</ul>
</li>
<li>
<p>Nodes are symbolic registers</p>
</li>
<li>
<p>Two registers that are live in the same program fragment are joined by an edge</p>
</li>
<li>
<p>Try to colour the graph with <em>n</em> colours, where <em>n</em> is the number of real registers</p>
</li>
<li>
<p>Nodes that can not be coloured are placed in memory</p>
</li>
</ul>
<hr>
<p><strong>Graph colouring approach</strong></p>
<a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter13-5.png" title="/img/Computer Organization and Architecture/chapter13-5.png" data-thumbnail="/img/Computer Organization and Architecture/chapter13-5.png">
        
    </a>
<ul>
<li>
<p>构造无向图：A和BC在时间上有重叠，A和BC有连线；B和所有的节点都有时间重叠，B和所有的节点都有连线。C和ABD有时间上的重叠，C和ABD有连线</p>
</li>
<li>
<p>从A开始，给A赋一个灰色，B和C必须要和A不一样，并且B和C也不能一样，给B附一个顺斜杠，C赋一个反斜杠。D节点和BC相连，和A不相连，D点可以用灰色。E节点和BD相连，E可以用C的颜色。F和BED相连，而BDE分别是正斜杠、灰色和反斜杠，F必须要用到第四个颜色</p>
</li>
<li>
<p>如果物理寄存器只有3个的话，那么F就需要保存到存储器中了，通过加载和保存来处理</p>
</li>
</ul>
<h4 id="large-register-vs-compiler">Large Register vs Compiler</h4>
<ul>
<li>
<p>When the number of registers is small, the effect will be better by optimizing the registers</p>
</li>
<li>
<p>When the number of registers is large, the effect of register optimization will not be very good</p>
</li>
<li>
<p>Optimization of registers is mainly for the case of a small number of registers</p>
</li>
</ul>
<h3 id="risc-pipelining">RISC Pipelining</h3>
<ul>
<li>
<p>Most instructions are register to register</p>
</li>
<li>
<p>Two phases of execution</p>
<ul>
<li>
<p>I: Instruction fetch</p>
</li>
<li>
<p>E: Execute</p>
<ul>
<li>ALU operation with register input and output</li>
</ul>
</li>
</ul>
</li>
<li>
<p>For load and store</p>
<ul>
<li>
<p>I: Instruction fetch</p>
</li>
<li>
<p>E: Execute: Calculate memory address</p>
</li>
<li>
<p>D: Register to memory or memory to register operation</p>
</li>
</ul>
</li>
</ul>
<a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter13-6.png" title="/img/Computer Organization and Architecture/chapter13-6.png" data-thumbnail="/img/Computer Organization and Architecture/chapter13-6.png">
        
    </a>
<a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter13-7.png" title="/img/Computer Organization and Architecture/chapter13-7.png" data-thumbnail="/img/Computer Organization and Architecture/chapter13-7.png">
        
    </a>
<ul>
<li>
<p>图a是没有采用流水线技术，完全按照顺序来执行</p>
</li>
<li>
<p><strong>图b是采用两阶段流水线的执行情况。由于同时只能有1个存储器访问，取指和存储会冲突，导致取指会延后一个时钟周期</strong></p>
</li>
<li>
<p>存储器的访问限制导致了时钟周期的浪费</p>
</li>
<li>
<p>如果存储支持2个访问，可以用三阶段流水线</p>
</li>
<li>
<p>指令相关性：Add rC$\leftarrow$rA+rB，指令需要的操作数为rA和rB。而第二条指令要到第四个时钟周期才能得到rB。所以要插入一个空指令NOOP</p>
</li>
<li>
<p>指令执行阶段，通常涉及到寄存器的读和ALU的操作，把E阶段进一步分为E1和E2。其中E1阶段完成寄存器的读，而E2阶段则完成ALU操作和寄存器的写操作</p>
</li>
<li>
<p>使用四阶段流水线来提高效率。但同样需要考虑相关性问题</p>
</li>
</ul>
<h4 id="optimization-of-pipelining">Optimization of Pipelining</h4>
<ul>
<li>
<p>Dependency of data and branch will disrupt the pipeline and affect the efficiency</p>
</li>
<li>
<p>Two methods: Delayed branch, Loop Unrolling</p>
</li>
<li>
<p>Delayed branch</p>
<ul>
<li>
<p>Branch instruction affects only the instructions that follow it</p>
</li>
<li>
<p>This following instruction is the delay slot</p>
</li>
<li>
<p><strong>Arrange a useful instruction to replace the NOOP instruction</strong></p>
</li>
</ul>
</li>
</ul>
<h4 id="delayed-branch">delayed branch</h4>
<ul>
<li>
<p><strong>Calculate result of branch before unusable instructions pre-fetched</strong></p>
<ul>
<li>
<p><strong>Instructions that are not affected by branches are immediately followed by branch</strong></p>
</li>
<li>
<p><strong>Keeps pipeline full while fetching new instruction stream</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>Not as good for superscalar</strong></p>
<ul>
<li>
<p>Multiple instructions need to execute in delay slot</p>
</li>
<li>
<p>Instruction dependence problems</p>
</li>
<li>
<p>Often use branch prediction</p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p>Problem: How do you find instructions to fill the delay slots?</p>
<ul>
<li>
<p>Branch must be independent of delay slot instructions</p>
</li>
<li>
<p>Unconditional branch: Easier to find instructions to fill the delay slot</p>
</li>
<li>
<p>Conditional branch: Condition computation should not depend on instructions in delay slots → difficult to fill the delay slot</p>
</li>
</ul>
</li>
</ul>
<h4 id="advantage">Advantage</h4>
<ul>
<li>
<p>Keeps the pipeline full with useful instructions in a simple way assuming</p>
<ul>
<li>
<p>Number of delay slots = number of instructions to keep the pipeline full before the branch resolves</p>
</li>
<li>
<p>All delay slots can be filled with useful instructions</p>
</li>
</ul>
</li>
</ul>
<h4 id="disadvantage">Disadvantage</h4>
<ul>
<li>
<p>Not easy to fill the delay slots (even with a 2-stage pipeline)</p>
<ul>
<li>
<p>Number of delay slots increases with pipeline depth, superscalar execution width</p>
</li>
<li>
<p>Number of delay slots should be variable with variable latency operations</p>
</li>
</ul>
</li>
</ul>
<h4 id="another-method-loop-unrolling">Another method-Loop Unrolling</h4>
<ul>
<li>
<p>Replicate body of loop a number of times</p>
<ul>
<li>Iterate loop fewer times</li>
<li>Reduces loop overhead</li>
<li>Increases instruction parallelism</li>
</ul>
</li>
<li>
<p>During the execution of the loop body, because of the locality principle, some data can be used for many times, which can reduce the number of times to access the</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fortran" data-lang="fortran"><span class="line"><span class="cl"><span class="k">do </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">end do</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>原始的循环是要做一个一维数组的变化。循环体中有一个语句需要执行</p>
</li>
<li>
<p>把这个循环体进行拆解，变成了2个语句，一个循环体执行了2个迭代操作</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fortran" data-lang="fortran"><span class="line"><span class="cl"><span class="k">do </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">end do</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>2个指令可以并行进行。原来每次循环需要访问3次存储器，现在相当于2次循环只需要访问4次存储器，降低了存储器访问的次数</li>
</ul>
<h3 id="risc-versus-cisc-controversy">RISC Versus CISC Controversy</h3>
<ul>
<li>
<p>Not clear cut</p>
<ul>
<li>
<p>RISC designs may benefit from the inclusion of some CISC features and that</p>
</li>
<li>
<p>CISC designs may benefit from the inclusion of some RISC features</p>
</li>
</ul>
</li>
<li>
<p>Many designs borrow from both philosophies</p>
<ul>
<li>
<p>PowerPC are no longer “pure” RISC</p>
</li>
<li>
<p>Pentium II and later Pentium models do incorporate some RISC characteristics</p>
</li>
</ul>
</li>
</ul>
]]></description>
</item>
<item>
    <title>Computer Organization and Architecture Processor Structure and Function</title>
    <link>https://Jungle430.github.io/posts/computer-organization-and-architecture/computer-organization-and-architecture-processor-structure-and-function/</link>
    <pubDate>Sat, 28 Jan 2023 14:20:25 &#43;0800</pubDate><author>1239946358@qq.com (Jungle)</author><guid>https://Jungle430.github.io/posts/computer-organization-and-architecture/computer-organization-and-architecture-processor-structure-and-function/</guid>
    <description><![CDATA[<h1 id="computer-organization-and-architecture">Computer Organization and Architecture</h1>
<h2 id="processor-structure-and-function">Processor Structure and Function</h2>
<h3 id="outline">Outline</h3>
<ul>
<li>
<p>Processor Organization</p>
</li>
<li>
<p>Register Organization</p>
</li>
<li>
<p>Instruction Cycle</p>
</li>
<li>
<p>Instruction Pipelining</p>
</li>
</ul>
<h3 id="processor-organization">Processor Organization</h3>
<ul>
<li>
<p>A CPU must be able to</p>
<ul>
<li>
<p>Fetch instruction from memory</p>
</li>
<li>
<p>Decode the instruction to determine what action to do</p>
</li>
<li>
<p>Fetch data</p>
</li>
<li>
<p>Process data</p>
</li>
<li>
<p>Write data</p>
</li>
</ul>
</li>
</ul>
<a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter12-1.png" title="/img/Computer Organization and Architecture/chapter12-1.png" data-thumbnail="/img/Computer Organization and Architecture/chapter12-1.png">
        
    </a>
<ul>
<li>
<p>CPU必须要能够暂时保存一些数据，以对数据进行处理</p>
</li>
<li>
<p>CPU需要记住下一个指令的位置，这样才能在当前指令执行完成之后，能到找到下一个指令</p>
</li>
<li>
<p>处理过程中需要能够保存指令和数据</p>
</li>
<li>
<p><strong>CPU包括ALU，CU，还需要有一组存储部件——寄存器</strong></p>
</li>
<li>
<p>CPU通过一组系统总线和计算机的其他部件进行连接。系统总线包括控制总线、数据总线和地址总线</p>
</li>
</ul>
<a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter12-2.png" title="/img/Computer Organization and Architecture/chapter12-2.png" data-thumbnail="/img/Computer Organization and Architecture/chapter12-2.png">
        
    </a>
<ul>
<li>
<p><strong>CPU的内部总线把ALU、寄存器和CU连在一起，完成数据在寄存器和ALU的传送</strong></p>
</li>
<li>
<p>控制单元对寄存器、内部总线和ALU进行控制，控制各个部件按照指令要求完成相应的处理</p>
</li>
<li>
<p>在ALU内部，还包括各种更小的组件，例如状态标志，移位器，求补器，以及算术和布尔逻辑等</p>
</li>
</ul>
<h3 id="register-organization">Register Organization</h3>
<ul>
<li>
<p>CPU must have some working space (temporary storage)</p>
<ul>
<li>Called registers</li>
</ul>
</li>
<li>
<p>Number and function vary between processor designs</p>
</li>
<li>
<p><strong>One of the major design decisions</strong></p>
</li>
<li>
<p><strong>Top level of memory hierarchy</strong></p>
</li>
</ul>
<hr>
<ul>
<li>
<p><strong>Registers in the CPU Including two types</strong></p>
<ul>
<li>
<p><strong>User-visible registers</strong></p>
</li>
<li>
<p><strong>Reduce access to main memory and improve instruction processing efficiency by optimizing the use of registers</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>Control and status registers</strong></p>
<ul>
<li>
<p><strong>Used by control unit</strong></p>
</li>
<li>
<p><strong>Control the operation of the CPU and the execution of the program by the privileged operating system</strong></p>
</li>
</ul>
</li>
</ul>
<h4 id="user-visible-registers">User-visible registers</h4>
<ul>
<li>
<p>User visible registers can be divided into four categories according to its purpose</p>
<ul>
<li>
<p><strong>General purpose: assigned to various purposes</strong></p>
</li>
<li>
<p><strong>Data: for data retention only</strong></p>
</li>
<li>
<p><strong>Address: used for some addressing mode</strong></p>
</li>
<li>
<p><strong>Condition codes: also called flag register, it stores some flags of operation results</strong></p>
</li>
</ul>
</li>
</ul>
<h5 id="general-purpose-registers">General purpose registers</h5>
<ul>
<li>
<p>True general purpose</p>
<ul>
<li>Registers and opcodes are orthogonal in the instruction set</li>
<li>Registers can be arbitrarily matched with opcodes</li>
</ul>
</li>
<li>
<p><strong>Restricted general registers</strong></p>
<ul>
<li><strong>Specially used for floating point number or stack operation</strong></li>
</ul>
</li>
<li>
<p>In some cases, general registers can be used for addressing</p>
<ul>
<li>Register indirect addressing</li>
<li>Displacement addressing</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p>Data register</p>
<ul>
<li><strong>It can only be used for store data, not for addressing</strong></li>
<li><strong>Accumulator</strong></li>
</ul>
</li>
<li>
<p><strong>Addressing register</strong></p>
<ul>
<li>
<p><strong>Used for a specific addressing mode</strong></p>
</li>
<li>
<p><strong>Segment pointer</strong></p>
</li>
<li>
<p><strong>Index register</strong></p>
</li>
<li>
<p><strong>Stack pointer</strong></p>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>General or Specialized</strong></p>
<ul>
<li>
<p>Whether registers are general or special affects the design of instruction sets</p>
</li>
<li>
<p><strong>Specialized</strong></p>
<ul>
<li>
<p><strong>Opcode can implicitly use a register group or a register</strong></p>
</li>
<li>
<p><strong>Smaller instructions</strong></p>
</li>
<li>
<p><strong>Less flexibility</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>General purpose</strong></p>
<ul>
<li>
<p><strong>Increase flexibility and programmer options</strong></p>
</li>
<li>
<p><strong>Increase instruction size &amp; complexity</strong></p>
</li>
</ul>
</li>
<li>
<p>More registers require more bits to specify registers in instructions</p>
</li>
<li>
<p>Fewer registers require more memory access</p>
</li>
<li>
<p>Too many registers does not reduce memory references remarkably and takes up processor real estate</p>
<ul>
<li>Between 8-32 is appropriate</li>
</ul>
</li>
<li>
<p><strong>Using register files with RISC makes use of using more registers</strong></p>
</li>
</ul>
<hr>
<ul>
<li>
<p>Address register: large enough to hold full address</p>
</li>
<li>
<p>Data address: large enough to hold full word</p>
</li>
<li>
<p><strong>Sometimes combine two data registers to hold double length data</strong></p>
<ul>
<li><strong>In C language, there is a double integer and a long integer, both of which are two words long</strong></li>
</ul>
</li>
</ul>
<hr>
<p><strong>Condition code registers</strong></p>
<ul>
<li>
<p><strong>Also called flag registers, some of which are visible to users</strong></p>
</li>
<li>
<p><strong>After operating,CPU set the condition bit according to the result</strong></p>
<ul>
<li>
<p>After arithmetic operation, positive, negative, zero or overflow may occur</p>
</li>
<li>
<p>These conditions will be set in</p>
</li>
</ul>
</li>
<li>
<p>Programs are allowed to read the condition code and perform</p>
</li>
<li>
<p>Condition code cannot be modified by the program</p>
</li>
</ul>
<hr>
<p><strong>Control &amp; status registers</strong></p>
<ul>
<li>
<p>Four registers are essential to instruction execution</p>
<ul>
<li>
<p>Program Counter (PC)</p>
</li>
<li>
<p>Instruction Register (IR)</p>
</li>
<li>
<p>Memory Address Register (MAR)</p>
</li>
<li>
<p>Memory Buffer Register (MBR)</p>
</li>
</ul>
</li>
<li>
<p>Not all processors have MAR and MBR. However, the system still needs registers similar to these two registers</p>
</li>
</ul>
<hr>
<p><strong>Program status word</strong></p>
<ul>
<li>
<p>The PSW contains status information</p>
</li>
<li>
<p>The flags include</p>
<ul>
<li>
<p>Sign, zero, carry, equal, overflow</p>
</li>
<li>
<p>interrupt enable/disable</p>
</li>
<li>
<p>Supervisor: indicates whether the CPU is executing in supervisor or user mode</p>
</li>
</ul>
</li>
<li>
<p><strong>Supervisor mode</strong></p>
<ul>
<li>
<p>Not available to user programs</p>
</li>
<li>
<p>Used by operating system(<strong>System call</strong>)</p>
</li>
<li>
<p>Certain privileged instructions can be executed only in supervisor mode</p>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>Other status and control registers</strong></p>
<ul>
<li>
<p>Other additional status and control registers</p>
<ul>
<li>
<p>Pointer register to process control block</p>
</li>
<li>
<p>Interrupt vector register in vector interrupt computer</p>
</li>
<li>
<p>System stack pointer</p>
</li>
<li>
<p>Page table pointer register in virtual memory</p>
</li>
<li>
<p>I/O operation related registers</p>
</li>
</ul>
</li>
<li>
<p>Control and status registers design elements</p>
<ul>
<li>Need to support the operating system</li>
<li>Storage location in registers and memory</li>
</ul>
</li>
</ul>
<h3 id="instruction-cycle">Instruction Cycle</h3>
<ul>
<li>
<p><strong>Instruction cycle includes fetching cycle and execution cycle</strong></p>
</li>
<li>
<p><strong>In execution cycle, first decode to get the operation type of the instruction</strong></p>
</li>
<li>
<p><strong>If instruction has operands, get the operand specifier in the instruction</strong></p>
<ul>
<li>
<p><strong>Immediate</strong></p>
</li>
<li>
<p><strong>Register</strong></p>
</li>
<li>
<p><strong>Direct addressing: memory access once</strong></p>
</li>
<li>
<p><strong>Indirect addressing: may requires more memory accesses</strong></p>
<ul>
<li><strong>Also called “indirect cycle”</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>Instruction cycle with indirect</strong></p>
<div class="mermaid" id="id-1"></div>
<ul>
<li>
<p>指令周期包括取指周期和执行周期，还可能包括间接周期和中断周期</p>
</li>
<li>
<p>取指后，通过译码确定是否包含需要间接寻址的操作数，如果有，进入间接周期</p>
</li>
<li>
<p>当前指令执行完成之后，检查是否有中断。如果有，进入中断周期</p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter12-3.png" title="/img/Computer Organization and Architecture/chapter12-3.png" data-thumbnail="/img/Computer Organization and Architecture/chapter12-3.png" data-sub-html="<h2>Instruction Cycle(with Interrupts - State Diagram)</h2>">
        
    </a><figcaption class="image-caption">Instruction Cycle(with Interrupts - State Diagram)</figcaption>
    </figure>
<ul>
<li>
<p>指令周期中，先取指，然后进行指令操作译码</p>
</li>
<li>
<p>如果涉及到操作数，进行操作数地址计算，然后取操作数</p>
</li>
<li>
<p>之后进行数据操作。操作结果如果要保存到存储器中，需要计算操作数的地址，然后保存</p>
</li>
<li>
<p>在这条指令执行完成之后，检测是否有中断。如果没有中断，继续执行下一条指令。如果有中断，就按照中断的处理规则，进行中断处理</p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter12-4.png" title="/img/Computer Organization and Architecture/chapter12-4.png" data-thumbnail="/img/Computer Organization and Architecture/chapter12-4.png" data-sub-html="<h2>Indirect cycle</h2>">
        
    </a><figcaption class="image-caption">Indirect cycle</figcaption>
    </figure>
<ul>
<li>
<p>间接寻址过程中，由于操作数地址需要通过计算得到，所以在取操作数的过程中，可能会存在多次访问存储器的情况</p>
</li>
<li>
<p>取操作数和存结果的过程中，都可能会存在间接周期</p>
</li>
</ul>
<hr>
<p><strong>Data flow (instruction fetch)</strong></p>
<ul>
<li>
<p>Depends on CPU design</p>
</li>
<li>
<p>Fetch inn general</p>
<ul>
<li>
<p>PC contains address of next instruction</p>
</li>
<li>
<p>Address moved to MAR</p>
</li>
<li>
<p>Address placed on address bus</p>
</li>
<li>
<p>Control unit requests memory read</p>
</li>
<li>
<p>Result placed on data bus, copied to MBR, then to IR</p>
</li>
<li>
<p>Meanwhile PC incremented by 1</p>
</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter12-5.png" title="/img/Computer Organization and Architecture/chapter12-5.png" data-thumbnail="/img/Computer Organization and Architecture/chapter12-5.png" data-sub-html="<h2>Data flow(fetch diagram)</h2>">
        
    </a><figcaption class="image-caption"><code>Data flow(fetch diagram)</code></figcaption>
    </figure>
<ul>
<li>
<p>刚开始，下一个地址在PC中</p>
</li>
<li>
<p>地址给MAR</p>
</li>
<li>
<p>地址放到数据总线上</p>
</li>
<li>
<p>控制单元发起读控制</p>
</li>
<li>
<p>存储器把数据，也就是指令内容，放到数据总线上</p>
</li>
<li>
<p>MBR读取数据总线内容，然后把指令给IR</p>
</li>
<li>
<p>控制单元还需要让PC+1，指向下一个指令</p>
</li>
</ul>
<hr>
<ul>
<li>
<p>IR is examined</p>
</li>
<li>
<p><strong>If there is no indirect addressing, enter the execution cycle</strong></p>
</li>
<li>
<p><strong>If indirect addressing, indirect cycle is performed</strong></p>
<ul>
<li>
<p>Rightmost N bits of MBR transferred to MAR</p>
</li>
<li>
<p>Control unit requests memory read</p>
</li>
<li>
<p>Result (address of operand) moved to MBR</p>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>Data flow (execute)</strong></p>
<ul>
<li>
<p>May take many forms</p>
</li>
<li>
<p>Depends on instruction being executed</p>
</li>
<li>
<p>May include</p>
<ul>
<li>
<p>Memory read/write</p>
</li>
<li>
<p>Input/Output</p>
</li>
<li>
<p>Register transfers</p>
</li>
<li>
<p>ALU operations</p>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>Data flow (interrupt)</strong></p>
<ul>
<li>
<p>Simple and predictable</p>
</li>
<li>
<p><strong>Current PC saved to allow resumption after interrupt</strong></p>
<ul>
<li>
<p>Contents of PC copied to MBR</p>
</li>
<li>
<p>Special memory location (e.g. stack pointer) loaded to MAR</p>
</li>
<li>
<p>MBR written to memory</p>
</li>
</ul>
</li>
<li>
<p><strong>PC loaded with address of interrupt handling routine</strong></p>
</li>
<li>
<p>Interrupt handler first instruction fetched</p>
</li>
</ul>
<h3 id="instruction-pipelining">Instruction Pipelining</h3>
<p><strong>Why need pipeline?</strong></p>
<ul>
<li>
<p>Development of computer application requires continuous improvement of processing capacity</p>
</li>
<li>
<p>The development of integrated circuit, clock frequency, registers, cache, etc. have reduced the instruction processing time and improved the processing ability</p>
</li>
<li>
<p><strong>More and more difficult to solve problems by simply relying on the performance of hardware</strong></p>
</li>
<li>
<p><strong>The goal is the execution efficiency of instructions</strong></p>
</li>
<li>
<p><strong>Better organization is needed to improve the efficiency of instruction execution</strong></p>
</li>
</ul>
<hr>
<p><strong>What is pipeline? ！ ！ ！</strong></p>
<ul>
<li>
<p><strong>The working mode of factory assembly line is used for reference</strong></p>
<ul>
<li>
<p><strong>Divide the execution of instructions into several stages</strong></p>
</li>
<li>
<p><strong>Different stages of multiple instructions can be processed in parallel</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>Although execution time of each instruction is not shortened, the execution time of a group of instructions is shortened due to the parallel method</strong></p>
</li>
<li>
<p><strong>This is the basic idea of instruction pipeline</strong></p>
</li>
</ul>
<h4 id="prefetch">Prefetch</h4>
<ul>
<li>
<p>Before pipelining, next instruction is taken after current instruction is executed</p>
</li>
<li>
<p>With pipelining, more than one instruction in different stages of the pipeline</p>
</li>
<li>
<p>How to get instructions is a problem</p>
<ul>
<li>
<p><strong>Fetch accessing main memory</strong></p>
</li>
<li>
<p><strong>Execution usually does not access memory</strong></p>
</li>
<li>
<p><strong>Fetch next instruction during execution of current instruction</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>Called instruction prefetch</strong></p>
</li>
</ul>
<hr>
<p><strong>Advantage</strong></p>
<ul>
<li>
<p>During execution of an instruction, a new instruction has entered the pipeline</p>
</li>
<li>
<p><strong>After current instruction is executed, it can be executed immediately</strong></p>
<ul>
<li>
<p>Next instruction has finished fetching</p>
</li>
<li>
<p><strong>Save time for fetching</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>Accessing memory is required for fetching</strong></p>
<ul>
<li>
<p>If cache hits, take it directly</p>
</li>
<li>
<p>If cache missing, access memory</p>
</li>
</ul>
</li>
<li>
<p>In fact, the instruction cycle is divided into more detailed stages, more pipeline stages, and more overlapping and efficient instruction execution stages</p>
</li>
</ul>
<hr>
<p><strong>Which instruction is Prefetched?</strong></p>
<ul>
<li>
<p>Which instruction is appropriate for prefetching?</p>
</li>
<li>
<p><strong>Next instruction of the current instruction?</strong></p>
<ul>
<li>
<p><strong>If it is executed sequentially, no problem</strong></p>
</li>
<li>
<p><strong>If there is a transition, the next instruction needs to be determined according to the conditions</strong></p>
</li>
<li>
<p><strong>Hard to predict</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>Does a misprediction in prefetching affect correctness?</strong></p>
<ul>
<li>
<p><strong>No, prefetched data at a “mis-predicted” address is simply not used</strong></p>
</li>
<li>
<p><strong>There is no need for state recovery</strong></p>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>Basics characteristics</strong></p>
<ul>
<li>
<p>In modern systems, prefetching is usually done in cache block granularity</p>
</li>
<li>
<p>Prefetching is a technique that can reduce both</p>
<ul>
<li>
<p>Miss rate</p>
</li>
<li>
<p>Miss latency</p>
</li>
</ul>
</li>
<li>
<p><strong>Prefetching can be done by</strong></p>
<ul>
<li><strong>Hardware</strong></li>
<li><strong>Compiler</strong></li>
<li><strong>Programmer</strong></li>
</ul>
</li>
</ul>
<h4 id="prefetching-the-four-questions">Prefetching: the four questions</h4>
<ul>
<li>
<p>What</p>
<ul>
<li>What addresses to prefetch</li>
</ul>
</li>
<li>
<p>When</p>
<ul>
<li>When to initiate a prefetch request</li>
</ul>
</li>
<li>
<p>Where</p>
<ul>
<li>Where to place the prefetched data</li>
</ul>
</li>
<li>
<p>How</p>
<ul>
<li>Software, hardware, execution-based, cooperative</li>
</ul>
</li>
</ul>
<h4 id="two-stage-instruction-pipeline">Two stage instruction pipeline</h4>
<a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter12-6.png" title="/img/Computer Organization and Architecture/chapter12-6.png" data-thumbnail="/img/Computer Organization and Architecture/chapter12-6.png">
        
    </a>
<ul>
<li>
<p>简单的指令过程就是串行处理，取指-执行-取指-执行，效率低</p>
</li>
<li>
<p>采用两阶段流水线后，在当前指令的执行过程中，进行下一个指令的取指</p>
</li>
<li>
<p>如果当前指令执行完成后，下一个指令不是预取的，需要重新取指</p>
</li>
<li>
<p>取指和执行指令的时间重叠，节省了时间</p>
</li>
<li>
<p>但是由于取指和执行指令的时间需要不一样，所以执行速度不能翻倍</p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter12-7.png" title="/img/Computer Organization and Architecture/chapter12-7.png" data-thumbnail="/img/Computer Organization and Architecture/chapter12-7.png" data-sub-html="<h2>Instruction pipelining</h2>">
        
    </a><figcaption class="image-caption"><code>Instruction pipelining</code></figcaption>
    </figure>
<ul>
<li>
<p>两阶段流水线的执行过程</p>
</li>
<li>
<p><strong>上一条指令的执行阶段和下一条指令的取指阶段在时间上是重叠的</strong></p>
</li>
<li>
<p>每个指令的总体执行时间没有缩短，部指令的执行时间缩短了</p>
</li>
<li>
<p>如果取指和执行时间相同，那么流水线的执行时间是串行执行的一半，性能提升一倍</p>
</li>
</ul>
<h4 id="improved-performance">Improved performance</h4>
<ul>
<li>
<p><strong>But not doubled</strong></p>
<ul>
<li>
<p><strong>Fetch usually shorter than execution</strong></p>
</li>
<li>
<p>Instruction execution process is complex and time-consuming</p>
</li>
<li>
<p><strong>Execution time determines the improvement effect</strong></p>
</li>
</ul>
</li>
<li>
<p>Jump or branch instruction</p>
<ul>
<li>
<p><strong>means that prefetched instructions are not the required instructions</strong></p>
</li>
<li>
<p><strong>Get the actual instructions according to the results</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>Add more stages to improve performance</strong></p>
</li>
</ul>
<h4 id="improve-concurrency">improve concurrency</h4>
<ul>
<li>
<p>Goal: More concurrency → Higher instruction throughput</p>
</li>
<li>
<p><strong>Method: When an instruction is using some resources in its processing phase, process other instructions on idle resources</strong></p>
<ul>
<li>
<p>Fetch next instruction when an instruction is being decoded</p>
</li>
<li>
<p>Decode an instruction when an instruction is being executed</p>
</li>
<li>
<p>Execute the next instruction when current instruction is accessing memory</p>
</li>
<li>
<p>When an instruction is writing its result into the register file, access data memory for the next instruction</p>
</li>
</ul>
</li>
</ul>
<h4 id="summary">Summary</h4>
<ul>
<li>
<p>Analogy: “Assembly line processing” of instructions</p>
</li>
<li>
<p>Pipeline the execution of multiple instructions</p>
<ul>
<li>
<p><strong>Divide the instruction processing cycle into distinct “stages” of processing</strong></p>
</li>
<li>
<p>Ensure there are enough hardware resources to process one instruction in each stage</p>
</li>
<li>
<p>Process a different instruction in each stage</p>
</li>
<li>
<p>Instructions are executed in the order of program</p>
</li>
</ul>
</li>
<li>
<p><strong>Benefit: Increases instruction processing throughput</strong></p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter12-8.png" title="/img/Computer Organization and Architecture/chapter12-8.png" data-thumbnail="/img/Computer Organization and Architecture/chapter12-8.png" data-sub-html="<h2>execution of four independent add</h2>">
        
    </a><figcaption class="image-caption">execution of four independent add</figcaption>
    </figure>
<ul>
<li>
<p>加法指令流水线</p>
</li>
<li>
<p>整个指令分为4个阶段：取指，译码，执行，写结果，均为t</p>
</li>
<li>
<p>采用4阶段流水线，每个阶段完全独立，n个指令，需要$nt+3t$的时间</p>
</li>
<li>
<p>基本上是$\frac {1}{4}$的时间</p>
</li>
</ul>
<h4 id="in-practice">In practice</h4>
<a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter12-9.png" title="/img/Computer Organization and Architecture/chapter12-9.png" data-thumbnail="/img/Computer Organization and Architecture/chapter12-9.png">
        
    </a>
<ul>
<li>
<p>烘干衣服需要2个时间单位，这样，如果完全串行，需要20个时间单位</p>
</li>
<li>
<p>采用流水线后，有等待烘干机的时间</p>
</li>
<li>
<p>4件衣服需要11个时间单位</p>
</li>
<li>
<p>理论上的速度为非流水线的$2.5$倍</p>
</li>
<li>
<p><strong>最慢的步骤决定了整个系统的吞吐量</strong></p>
</li>
</ul>
<h5 id="how">How</h5>
<a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter12-10.png" title="/img/Computer Organization and Architecture/chapter12-10.png" data-thumbnail="/img/Computer Organization and Architecture/chapter12-10.png">
        
    </a>
<ul>
<li>
<p>烘干机成为整个系统的瓶颈</p>
</li>
<li>
<p>补充资源，配置2个烘干机</p>
</li>
<li>
<p>下一个衣服洗完后，不需要等待上一个衣服的烘干，用另一台烘干机</p>
</li>
<li>
<p>关键环节增加资源，使得整个吞吐量回到之前的情况</p>
</li>
<li>
<p>代价就是配置额外的资源</p>
</li>
</ul>
<h4 id="goal">Goal</h4>
<ul>
<li>
<p>Increase instruction throughput with little increase in cost</p>
<ul>
<li>
<p><strong>Process instructions in the order required by the program</strong></p>
</li>
<li>
<p><strong>Hardware cost cannot be increased too much</strong></p>
</li>
<li>
<p>Instruction throughput can be greatly increased</p>
</li>
</ul>
</li>
</ul>
<h4 id="an-ideal-pipeline">An ideal pipeline</h4>
<ul>
<li>
<p><strong>Repetition of identical operations</strong></p>
<ul>
<li>
<p><strong>Same operation, different operation objects</strong></p>
</li>
<li>
<p>Automobiles of the same model can be produced on one assembly line</p>
</li>
<li>
<p><strong>Different operations require different steps, which affects the operation of the pipeline</strong></p>
</li>
<li>
<p>The production of automobiles and motorcycles requires different steps and cannot be put on the same assembly line</p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p><strong>Operating objects are independent of each other</strong></p>
<ul>
<li>
<p><strong>There is no dependency between each operation object</strong></p>
</li>
<li>
<p>For example, there is no relationship between cars produced on the assembly line</p>
</li>
<li>
<p><strong>Operating objects with sequential dependencies affect each other during parallel operations</strong></p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p>A complete operation can be decomposed into several sub operations</p>
<ul>
<li>
<p><strong>Each sub operation takes the same time</strong></p>
</li>
<li>
<p><strong>Each sub operation requires independent resources and does not share resources</strong></p>
</li>
<li>
<p>If sub operation requires different time, some sub operations must wait</p>
</li>
<li>
<p>Resource sharing leads to resource contention</p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p>For the pipeline design of instructions, we divide the execution of instructions into six stages</p>
<ul>
<li>
<p><strong>Fetch instruction(FI)</strong></p>
</li>
<li>
<p><strong>Decode instruction(DI)</strong></p>
</li>
<li>
<p><strong>Calculate operands(CO)</strong></p>
</li>
<li>
<p><strong>Fetch operands(FO)</strong></p>
</li>
<li>
<p><strong>Execute instructions(EI)</strong></p>
</li>
<li>
<p><strong>Write result(WO)</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>Overlap these operations</strong></p>
</li>
</ul>
<h4 id="timing-of-pipeline">Timing of pipeline</h4>
<a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter12-11.png" title="/img/Computer Organization and Architecture/chapter12-11.png" data-thumbnail="/img/Computer Organization and Architecture/chapter12-11.png">
        
    </a>
<ul>
<li>
<p>理想的指令流水线的执行过程</p>
</li>
<li>
<p><strong>指令执行分为6个阶段，相互之间不共享资源</strong></p>
</li>
<li>
<p>按照流水线的方式来执行，从第六个时间单位开始，每个时间单位都会有1个指令完成执行</p>
</li>
<li>
<p>指令数量足够多时，执行效率为原来的6倍</p>
</li>
</ul>
<h4 id="summary-1">Summary</h4>
<ul>
<li>
<p>The total execution time for each individual instruction is not changed by pipelining</p>
<ul>
<li>It still takes an instruction cycle to make it all the way through the processor</li>
</ul>
</li>
<li>
<p>Pipelining doesn&rsquo;t speed up instruction execution time</p>
</li>
<li>
<p>It does speed up program execution time by increasing the number of instructions finished per unit time</p>
</li>
</ul>
<h4 id="branch-in-a-pipeline">Branch in a pipeline</h4>
<a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter12-12.png" title="/img/Computer Organization and Architecture/chapter12-12.png" data-thumbnail="/img/Computer Organization and Architecture/chapter12-12.png">
        
    </a>
<ul>
<li>
<p>指令1和2的执行都是正常的</p>
</li>
<li>
<p>指令3在时间片8时，需要跳转到指令15的执行</p>
</li>
<li>
<p>指令4-7已经完成的处理作废</p>
</li>
<li>
<p>需要重新开始指令15的取指</p>
</li>
<li>
<p><strong>第9到第12时间片，没有指令完成执行，称为分支惩罚</strong></p>
</li>
<li>
<p><strong>分支越多，分支惩罚就越多，整个程序的指令吞吐率就越低</strong></p>
</li>
</ul>
<hr>
<p><strong>Six stage instruction pipeline</strong></p>
<a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter12-13.png" title="/img/Computer Organization and Architecture/chapter12-13.png" data-thumbnail="/img/Computer Organization and Architecture/chapter12-13.png">
        
    </a>
<ul>
<li>
<p>第一步是取指，之后是指令译码，并计算操作数地址</p>
</li>
<li>
<p><strong>此时，需要判断指令是否是无条件转移，如果是，那么更新PC，并清空流水线，继续开始取指</strong></p>
</li>
<li>
<p><strong>如果不转移，正常执行指令，取操作数，然后执行指令，并写操作数</strong></p>
</li>
<li>
<p><strong>判断是否进行分支，或者是否有中断。如果是，那么和无条件分支一样，更改PC，清空流水线，继续往下执行后续指令</strong></p>
</li>
</ul>
<h4 id="other-factors">Other factors</h4>
<ul>
<li>
<p>Data transmission between different parts takes time</p>
</li>
<li>
<p>Theoretically, the more stages, the higher the efficiency of instruction execution</p>
<ul>
<li>
<p>The more stages are divided, the more complex the control between stages will be</p>
</li>
<li>
<p><strong>Latching delay, buffering between phases takes a certain time</strong></p>
</li>
<li>
<p>Need reasonable design</p>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>Speedup factors with instruction pipelining</strong></p>
<ul>
<li>假定总共需要执行n条指令，采用的流水线段数为k，那么使用指令流水线相对于不使用流水线的加速比的定义是</li>
</ul>
<p>$$
S_k=\frac {nk}{k+n-1}
$$</p>
<ul>
<li>
<p>随着指令数的增加，加速比趋向于流水线的阶段</p>
</li>
<li>
<p>指令数越多，加速比越接近理论上的加速比。而随着段数的增加，加速比增加缓慢</p>
</li>
<li>
<p>流水线段数能带来更好的潜在加速比，但同时也带来很多问题。比如分支时需要清空流水线，段间延时也需要考虑</p>
</li>
</ul>
<h4 id="analysis-of-instruction-pipeline">Analysis of instruction pipeline</h4>
<ul>
<li>What are the characteristics of an ideal pipeline?
<ul>
<li>
<p>Repetition of identical operations</p>
</li>
<li>
<p>Operating objects are independent of each other</p>
</li>
<li>
<p>A complete operation can be decomposed into several sub operations</p>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>Identical operations … NOT!</strong></p>
<ul>
<li>
<p><strong>different instructions → not all need the same stages</strong></p>
</li>
<li>
<p>Forcing different instructions to go through the same pipe stages</p>
</li>
<li>
<p><strong>Some pipeline stages are idle</strong></p>
</li>
<li>
<p><strong>Leading to a waste of time, called external fragmentation</strong></p>
</li>
</ul>
<hr>
<p><strong>Independent operations &hellip; NOT!</strong></p>
<ul>
<li>
<p><strong>instructions are not independent of each other</strong></p>
</li>
<li>
<p>Need to detect and resolve inter-instruction dependencies to ensure the pipeline provides correct results</p>
</li>
<li>
<p>Pipeline stalls frequently due to branch</p>
</li>
<li>
<p>Poor operation of the pipeline</p>
</li>
</ul>
<hr>
<p><strong>Uniform sub-operations &hellip; NOT!</strong></p>
<ul>
<li>
<p><strong>different pipeline stages → not the same latency</strong></p>
</li>
<li>
<p>Need to force each stage to be controlled by the same clock</p>
</li>
<li>
<p><strong>Some pipe stages are too fast but all take the same clock cycle time</strong></p>
</li>
<li>
<p><strong>These wasted time are called internal fragmentation</strong></p>
</li>
</ul>
<hr>
<h4 id="issues-in-pipeline-design">Issues in pipeline design</h4>
<ul>
<li>
<p>Reasonably divide the stages of instructions</p>
<ul>
<li>
<p><strong>How many stages is the instruction cycle divided into?</strong></p>
</li>
<li>
<p>what is done in each stage</p>
</li>
</ul>
</li>
<li>
<p>Handling exceptions, interrupts</p>
</li>
<li>
<p>Keeping the pipeline correct, moving, and full</p>
<ul>
<li>
<p>Data dependences</p>
</li>
<li>
<p>Control dependences</p>
</li>
<li>
<p>Resource conflict</p>
</li>
<li>
<p>Long-latency (or multi-cycle) operations</p>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>Causes of pipeline stalls</strong></p>
<ul>
<li>
<p><strong>Pipeline stall: A condition when the pipeline stops moving</strong></p>
</li>
<li>
<p>Causes of stall</p>
<ul>
<li>Resource contention</li>
<li>Dependences between instructions, including data dependence and control dependence</li>
<li>Long-latency (multi-cycle) operations</li>
</ul>
</li>
</ul>
<hr>
<p><strong>Dependences and Their Types</strong></p>
<ul>
<li>
<p>Also called “hazard” or “pipeline bubble”</p>
</li>
<li>
<p>Dependences dictate ordering requirements between instructions</p>
</li>
<li>
<p>Two types</p>
<ul>
<li>
<p>Data dependence</p>
</li>
<li>
<p>Control dependence</p>
</li>
</ul>
</li>
<li>
<p><strong>Resource contention is sometimes called resource dependence</strong></p>
</li>
<li>
<p><strong>When dependency occurs, the pipeline will be suspended, which is called pipeline adventure</strong></p>
</li>
</ul>
<h4 id="resource-hazards">Resource hazards</h4>
<ul>
<li>
<p><strong>Two (or more) instructions in pipeline need same resource</strong></p>
<ul>
<li>
<p><strong>Executed in serial rather than parallel for part of pipeline</strong></p>
</li>
<li>
<p><strong>Also called <em>structural hazard</em></strong></p>
</li>
</ul>
</li>
<li>
<p>It is caused by unreasonable structure or insufficient resources</p>
<ul>
<li>Such as using the same register</li>
</ul>
</li>
<li>
<p><strong>The solution is generally to increase available resources, such as adding a dryer in the previous example</strong></p>
</li>
</ul>
<p><strong>Example</strong></p>
<a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter12-14.png" title="/img/Computer Organization and Architecture/chapter12-14.png" data-thumbnail="/img/Computer Organization and Architecture/chapter12-14.png">
        
    </a>
<ul>
<li>
<p>第3个时钟周期，$I_1$需要读取内存取操作数，同时$I_3$也需要取指</p>
</li>
<li>
<p>两个指令读需要读存储器，发生资源冲突</p>
</li>
<li>
<p>$I_3$需要空一个时钟周期，等到第4个时钟周期的时候，才去取指</p>
</li>
<li>
<p>因为资源冲突而浪费了1个时钟周期</p>
</li>
<li>
<p>如果只有一个$ALU$，执行指令也可能会冲突</p>
</li>
</ul>
<h4 id="handling-resource-contention">Handling resource contention</h4>
<ul>
<li>
<p><strong>Solution 1: Eliminate the cause of contention</strong></p>
<ul>
<li>
<p>Duplicate the resource or increase its throughput</p>
</li>
<li>
<p>E.g., use separate instruction and data memories (caches)</p>
</li>
<li>
<p>E.g., use multiple ports for memory structures</p>
</li>
</ul>
</li>
<li>
<p><strong>Solution 2: Detect the resource contention and stall one</strong></p>
<ul>
<li>Need to decide which one to stop</li>
</ul>
</li>
</ul>
<h4 id="data-hazards">Data hazards</h4>
<ul>
<li>
<p>Conflict in access of an operand</p>
<ul>
<li>E.g. ,both instructions access a particular memory or register operand</li>
</ul>
</li>
<li>
<p><strong>If two instructions are executed serially in strict order, that is one instruction executes after the finish of the previous instruction execution. No problem</strong></p>
</li>
<li>
<p><strong>If in a pipeline, operand value could be updated so as to produce different result from strict sequential execution</strong></p>
</li>
<li>
<p><strong>Data Hazard is caused by the conflict of access to the same operand location</strong></p>
</li>
</ul>
<hr>
<h4 id="types-of-data-hazard">Types of data hazard</h4>
<ul>
<li>
<p>Types of data dependences：</p>
<ul>
<li>
<p><strong>read after write</strong></p>
<ul>
<li><strong>Called “True dependence ”</strong></li>
</ul>
</li>
<li>
<p><strong>write after read</strong></p>
<ul>
<li><strong>Called “Anti dependence ”</strong></li>
</ul>
</li>
<li>
<p><strong>write after write</strong></p>
<ul>
<li><strong>Called “Output dependence”</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="true-dependency">True dependency</h5>
<ul>
<li>
<p><strong>Read after write (RAW), or true dependency</strong></p>
<ul>
<li>
<p><strong>An instruction modifies a register or memory location</strong></p>
</li>
<li>
<p><strong>Succeeding instruction reads data in that location</strong></p>
</li>
<li>
<p><strong>Hazard occurs if read takes place before write complete</strong></p>
</li>
<li>
<p><strong>What needs to be read by succeeding instruction is the modified data</strong></p>
</li>
<li>
<p><strong>After the pipeline is adopted, the read data becomes the data before writing</strong></p>
</li>
</ul>
</li>
</ul>
<a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter12-15.png" title="/img/Computer Organization and Architecture/chapter12-15.png" data-thumbnail="/img/Computer Organization and Architecture/chapter12-15.png">
        
    </a>
<ul>
<li>
<p>第一个指令需要写$r_3$</p>
</li>
<li>
<p>第二个指令需要读$r_3$</p>
</li>
<li>
<p>第二个指令<strong>必须要等第一个指令执行完成之后并写了</strong>$r_3$，才能完成读操作数的指令，否则读取的$r_3$不是需要的数</p>
</li>
</ul>
<h5 id="anti-dependence">Anti dependence</h5>
<ul>
<li>
<p><strong>Write after read (WAR), or anti-dependency</strong></p>
</li>
<li>
<p><strong>An instruction reads a register or memory location</strong></p>
</li>
<li>
<p><strong>Succeeding instruction writes to location</strong></p>
</li>
<li>
<p><strong>Hazard occur if write completes before read takes place</strong></p>
</li>
<li>
<p><strong>The data of the first instruction read operation is incorrect</strong></p>
</li>
</ul>
<a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter12-16.png" title="/img/Computer Organization and Architecture/chapter12-16.png" data-thumbnail="/img/Computer Organization and Architecture/chapter12-16.png">
        
    </a>
<ul>
<li>
<p>第一个指令读$r_1$</p>
</li>
<li>
<p>第二个指令写$r_1$</p>
</li>
<li>
<p>如果先执行了第二个指令，那么结果也不正确</p>
</li>
<li>
<p>在超标量中会出现这种情况</p>
</li>
</ul>
<h5 id="output-dependence">Output dependence</h5>
<ul>
<li>
<p><strong>Write after write (WAW), or output dependency</strong></p>
<ul>
<li>
<p><strong>Two instructions both write to same location</strong></p>
</li>
<li>
<p><strong>Hazard if writes take place in reverse of order intended sequence</strong></p>
</li>
<li>
<p><strong>The data to be stored is the data written by the second instruction</strong></p>
</li>
<li>
<p><strong>In the pipeline, the data actually saved is the data written by the first instruction</strong></p>
</li>
<li>
<p><strong>Data of memory or register is not required</strong></p>
</li>
</ul>
</li>
</ul>
<a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter12-17.png" title="/img/Computer Organization and Architecture/chapter12-17.png" data-thumbnail="/img/Computer Organization and Architecture/chapter12-17.png">
        
    </a>
<ul>
<li>
<p>第一个执行写$r_3$</p>
</li>
<li>
<p>第三个指令也写$r_3$</p>
</li>
<li>
<p>如果第三个指令先执行了，也结果不正确</p>
</li>
<li>
<p>在超标量中会出现这种情况</p>
</li>
</ul>
<h4 id="how-1">How?</h4>
<ul>
<li>
<p>True dependences always need to be obeyed because they constitute true dependence on a value</p>
</li>
<li>
<p><strong>True dependences always need to be obeyed because they constitute true dependence on a value</strong></p>
</li>
<li>
<p><strong>Anti and output dependences exist due to limited number of architectural registers</strong></p>
<ul>
<li><strong>They are dependence on a name, not a value</strong></li>
</ul>
</li>
<li>
<p><strong>Without special hardware and specific avoidance algorithms, results in inefficient pipeline usage</strong></p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter12-18.png" title="/img/Computer Organization and Architecture/chapter12-18.png" data-thumbnail="/img/Computer Organization and Architecture/chapter12-18.png" data-sub-html="<h2>Data hazard diagram</h2>">
        
    </a><figcaption class="image-caption"><code>Data hazard diagram</code></figcaption>
    </figure>
<ul>
<li>
<p>在第五个时钟周期，加法指令写EAX</p>
</li>
<li>
<p>第四个时钟周期，减法要用EAX</p>
</li>
<li>
<p>如果第二个指令不等待，那取的EAX还是最早的EAX，不是加法的结果</p>
</li>
<li>
<p>所以减法指令需要停顿2个时钟周期，到第六个时钟周期才会去取操作数</p>
</li>
<li>
<p>浪费了2个时钟周期</p>
</li>
</ul>
<h4 id="method-of-handle">Method of handle</h4>
<ul>
<li>
<p>True dependences are more interesting</p>
<ul>
<li><strong>Actual interdependence between data，requires waiting</strong></li>
</ul>
</li>
<li>
<p><strong>Anti and output dependences are easier to handle</strong></p>
<ul>
<li>
<p><strong>It’s all about writing</strong></p>
</li>
<li>
<p><strong>Use more registers</strong></p>
</li>
<li>
<p><strong>Use different registers to eliminate possible correlation</strong></p>
</li>
</ul>
</li>
<li>
<p>Some fundamental ways of handling true dependences</p>
<ul>
<li>
<p>Detect and wait until value is available in register file</p>
</li>
<li>
<p>Detect and eliminate the dependence at the software level</p>
<ul>
<li>
<p>Register renaming</p>
</li>
<li>
<p>Discussed later</p>
</li>
</ul>
</li>
<li>
<p>Predict the needed value(s), execute “speculatively”, and verify</p>
</li>
</ul>
</li>
</ul>
<h4 id="control-dependence">Control dependence</h4>
<ul>
<li>
<p>Also called “control hazard”“branch hazard”</p>
</li>
<li>
<p>A Special Case of Data Dependence</p>
</li>
<li>
<p>Occurs when the pipeline makes a wrong judgment on branch transfer</p>
</li>
<li>
<p>Brings instructions into pipeline that must subsequently be discarded</p>
</li>
<li>
<p>The pipeline cannot run with full load</p>
</li>
</ul>
<h5 id="solve">solve</h5>
<ul>
<li>
<p><strong>Multiple Streams</strong></p>
</li>
<li>
<p><strong>Prefetch Branch Target</strong></p>
</li>
<li>
<p><strong>Loop buffer</strong></p>
</li>
<li>
<p><strong>Branch prediction</strong></p>
</li>
<li>
<p><strong>Delayed branching</strong></p>
</li>
</ul>
<h6 id="multiple-streams">Multiple streams</h6>
<ul>
<li>
<p>Have two pipelines for each branch</p>
<ul>
<li>Prefetch each branch into a separate pipeline</li>
</ul>
</li>
<li>
<p>Finally, determine which pipeline to use according to the branching conditions</p>
</li>
<li>
<p>Shortcoming</p>
<ul>
<li>
<p>Leads to bus &amp; register contention</p>
</li>
<li>
<p>Multiple branches lead to further pipelines being needed</p>
</li>
</ul>
</li>
</ul>
<h6 id="prefetch-branch-target">Prefetch branch target</h6>
<ul>
<li>Target of branch is prefetched in addition to instructions following branch</li>
<li>It is not executed after prefetching, but fetching and decoding</li>
<li>Keep target until branch is executed</li>
<li>It can save the time of fetching and decoding</li>
<li>Used by IBM 360/91</li>
</ul>
<h6 id="loop-buffer">Loop buffer</h6>
<ul>
<li>
<p>Very fast memory</p>
</li>
<li>
<p>Contains n instructions taken in the most recent order</p>
</li>
<li>
<p>When a branch may occur, first check whether the transfer target is in the buffer</p>
</li>
<li>
<p><strong>Very good for small loops or jumps</strong></p>
</li>
</ul>
<h6 id="branch-prediction">Branch prediction</h6>
<ul>
<li>
<p>There are two types of branch predictions</p>
<ul>
<li>
<p>Static branch predictions: the branch does not depend on the execution history</p>
</li>
<li>
<p>Dynamic branch prediction: the branch depends on the execution history</p>
</li>
</ul>
</li>
<li>
<p>Static branching</p>
<ul>
<li>
<p>Predict never taken</p>
</li>
<li>
<p>Predict always taken</p>
</li>
<li>
<p>Predict by Opcode</p>
</li>
</ul>
</li>
<li>
<p>Dynamic branching</p>
<ul>
<li>
<p>Taken/not taken switch</p>
</li>
<li>
<p>Branch history table</p>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>Static branch prediction</strong></p>
<ul>
<li>
<p><strong>Predict never taken</strong></p>
<ul>
<li>
<p><strong>Assume that jump will not happen</strong></p>
</li>
<li>
<p><strong>Always fetch next instruction</strong></p>
</li>
<li>
<p><strong>68020 &amp; VAX 11/780</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>Predict always taken</strong></p>
<ul>
<li>
<p><strong>Assume that jump will happen</strong></p>
</li>
<li>
<p><strong>Always fetch target instruction</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>“Predict always taken ” are most used</strong></p>
</li>
<li>
<p>Predict by Opcode</p>
<ul>
<li>
<p>Some instructions are more likely to result in a jump than others</p>
</li>
<li>
<p>Can get up to 75% success</p>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>Dynamic branch prediction</strong></p>
<ul>
<li>
<p><strong>Record the history of conditional branch instructions in a program</strong></p>
</li>
<li>
<p>Taken/not taken switch: One or more bits are used to indicate recent history of the instruction</p>
<ul>
<li>
<p><strong>The branching decision is depended on these bits</strong></p>
</li>
<li>
<p><strong>Based on previous history</strong></p>
</li>
<li>
<p><strong>Good for loops</strong></p>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>Branch history table</strong></p>
<ul>
<li>
<p>If Predict branch，target address can only be obtained by decoding instructions</p>
<ul>
<li>
<p>A waiting time is required</p>
</li>
<li>
<p>How to improve efficiency?</p>
</li>
</ul>
</li>
<li>
<p>A storage area called branch target buffer is designed</p>
<ul>
<li>
<p>Also called branch history table</p>
</li>
<li>
<p>It records information related to branch transfer, including branch instruction address, transfer history bit, and target address information</p>
</li>
</ul>
</li>
<li>
<p>Target address information</p>
<ul>
<li>
<p>Can be target instruction</p>
<ul>
<li>
<p>Use this instruction directly</p>
</li>
<li>
<p>Less time</p>
</li>
<li>
<p>It will take up more space</p>
</li>
</ul>
</li>
<li>
<p>Can be the target instruction address</p>
<ul>
<li>
<p>Less space</p>
</li>
<li>
<p>More time</p>
</li>
</ul>
</li>
<li>
<p>Whether to save time or space depends on the specific situation</p>
</li>
</ul>
</li>
</ul>
<h4 id="branch-history-table">Branch history table</h4>
<a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter12-19.png" title="/img/Computer Organization and Architecture/chapter12-19.png" data-thumbnail="/img/Computer Organization and Architecture/chapter12-19.png">
        
    </a>
<ul>
<li>
<p>预测转移后，指令预取的时候，先去转移历史表中查询</p>
<ul>
<li>
<p>如果有的话，根据指令状态进行预测，可能是目标地址，或者是下一顺序地址</p>
</li>
<li>
<p>如果不匹配，顺序取下一个指令</p>
</li>
</ul>
</li>
<li>
<p>分支指令执行时，根据实际是否发生了转移，更新转移历史表中的状态位</p>
</li>
<li>
<p>如果条件分支指令不在表中的时候，需要把指令加到这个表中，同时需要替换到当前表中的一项。替换方法可以采用很多种方法，<strong>类似于cache的替换策略</strong></p>
</li>
<li>
<p>转移历史表动态自动维护</p>
</li>
</ul>
<hr>
<p><strong>Correlation-based prediction</strong></p>
<ul>
<li>
<p>The execution effect of the branch history table in the loop statement is good</p>
</li>
<li>
<p>In more complex structures, branch instruction directly correlates with that of related branches instruction</p>
</li>
<li>
<p><strong>A method called Correlation-based branch history is proposed</strong></p>
<ul>
<li><strong>Create a global branch history table</strong></li>
<li><strong>Predict by combining global and current branch instructions</strong></li>
</ul>
</li>
</ul>
<hr>
<p><strong>Delayed Branch</strong></p>
<ul>
<li>
<p>A method of instruction rearrangement</p>
</li>
<li>
<p><strong>Delayed branches need to calculate the impact of branches and determine which instructions are not affected before prefetching unwanted instructions</strong></p>
<ul>
<li>
<p><strong>Execute such an instruction immediately after the branch instruction</strong></p>
</li>
<li>
<p><strong>The execution of this instruction keeps the pipeline in a full rotation state, and the clock cycle will not be wasted due to waiting</strong></p>
</li>
</ul>
</li>
</ul>
]]></description>
</item>
</channel>
</rss>
