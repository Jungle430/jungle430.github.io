<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Database Systems - 标签 - Jungle&#39;s Blog</title>
        <link>https://Jungle430.github.io/tags/database-systems/</link>
        <description>Database Systems - 标签 - Jungle&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>junglece430@gmail.com (Jungle)</managingEditor>
            <webMaster>junglece430@gmail.com (Jungle)</webMaster><lastBuildDate>Mon, 08 Apr 2024 20:02:45 &#43;0800</lastBuildDate><atom:link href="https://Jungle430.github.io/tags/database-systems/" rel="self" type="application/rss+xml" /><item>
    <title>CMU 15-445 Lecture #06: Buffer Pools</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter6/</link>
    <pubDate>Mon, 08 Apr 2024 20:02:45 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter6/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-06-buffer-pools">Lecture #06: Buffer Pools</h2>
<h3 id="introduction">Introduction</h3>
<ul>
<li>DBMS需要负责管理数据在内存和磁盘之间移动，大多数情况下数据不能在磁盘中被处理，而是需要加载到内存中，处理完成后再写回磁盘，这个过程就需要Buffer Pools来进行管理，使得DBMS的其他部分可以像在内存中处理所有数据那样进行操作</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter6-1.png" title="/img/CMU 15-445 Database Systems/chapter6-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter6-1.png" data-sub-html="<h2>Buffer Pool模型</h2>">
        
    </a><figcaption class="image-caption">Buffer Pool模型</figcaption>
    </figure>
<ul>
<li>一个DBMS需要考虑下面的两个方面
<ul>
<li><strong>Spatial Control</strong>: refers to where pages are physically written on disk. The goal of spatial control is to keep pages
that are used together often as physically close together as possible on disk to possibly help with prefetching and
other optimizations.(写磁盘的时候把需要经常一起用的页尽量写到磁盘的一块地方，这样下次用也能够一把加载到Buffer Pool里面)</li>
<li><strong>Temporal Control</strong>: is deciding when to read pages into memory and when to write them to disk. Temporal control
aims to minimize the number of stalls from having to read data from disk.(何时写回磁盘，对于一些热点写数据没有必要写一次刷一次盘，完全可以写好多次刷一次磁盘，因为刷盘的代价太大了)</li>
</ul>
</li>
</ul>
<h3 id="locks-vs-latches">Locks vs. Latches</h3>
<ul>
<li>
<p>英语和概念性的问题</p>
</li>
<li>
<p><strong>Locks</strong>: A lock is a higher-level, logical primitive that protects the contents of a database (e.g., tuples, tables, databases)
from other transactions. Database systems can expose to the user which locks are being held as queries are run. Locks
need to be able to roll back changes.(逻辑上面的锁，比如行锁/表锁/库锁，不关心底层实现，用于理论上面的讨论，为了防止死锁，一般这种锁都可以回滚)</p>
</li>
<li>
<p><strong>Latches</strong>: A latch is a low-level protection primitive that the DBMS uses for the critical sections in its internal data
structures (e.g., hash tables, regions of memory). Latches are held for only the duration of the operation being made.
Latches do not need to be able to roll back changes. This is often implemented by simple language primitives like
mutexs and/or conditional variables.(Locks的具体实现，比如数据竞争的区域是哪，用互斥锁还是信号量，悲观锁还是乐观锁)</p>
</li>
</ul>
<h3 id="buffer-pool">Buffer Pool</h3>
<ul>
<li>
<p>It is organized as an array of fixed-size pages. Each array entry is called a frame. 缓存池的本质就是内存里面的一块固定的数组，这个里面的一个元素就叫frame了，但是其实和page是一个东西</p>
</li>
<li>
<p><strong>page directory</strong>:在数据库的磁盘上还维护了一个page directory，这个东西存的就是页id到页在磁盘物理位置的映射，所以说这个如果修改了必须写回到磁盘上，这样DBMS重新启动的时候才能找到，他也通常回一直在内存里面，因为你找页必须要先通过page directory去找页的物理位置</p>
</li>
<li>
<p><strong>Buffer Pool Meta-data</strong>:缓存池必须要存储一些meta-data，从而保证正确性和提高缓存池的效率，常见的一些meta-data</p>
<ul>
<li>
<p><strong>page table</strong>:这个是内存中的一个hash表，它的映射是页面id $\rightarrow$ 这个页在缓存池中的帧位置，因为页在缓存池里面的顺序和磁盘中的顺序往往不一致，所以需要page table来做这个额外的间接层，除了页在缓存池中的位置，page table还维护了其他meta-data，比如一个脏标志（说明这个页是不是脏页），引用计数器（有哪几个事务在用它），这个和page directory的一个大的区别就是他不用记在磁盘上</p>
</li>
<li>
<p><strong>dirty-flag</strong>:这个就是上面page table维护的一个页的meta-data之一，当有线程对buffer pool中的某个页面进行修改的时候这个标志会被设置，这提醒这个页在被踢出buffer pool的时候必须要刷盘</p>
</li>
<li>
<p><strong>Pin/reference counter</strong>:这个也是上面page table维护的一个页的meta-data之一，主要是记录有几个线程正在访问该页，线程必须在访问该页之前增加counter，如果counter &gt; 0，那么该页就无法被驱逐，counter不会管理并发事务那些东西，如果当前缓冲池的所有页都无法被踢，而且已经满，就会抛出OOM(out-of-memory)的错误</p>
</li>
</ul>
</li>
<li>
<p><strong>Memory Allocation Policies</strong></p>
<ul>
<li>
<p>Memory in the database is allocated for the buffer pool according to two policies</p>
</li>
<li>
<p><strong>Global policies</strong>: 考虑所有事务，来找到分配内存的最佳决策</p>
</li>
<li>
<p><strong>local policies</strong>:做出决策的时候只考虑单个事务，即使他不适合整个工作负载，本地策略将帧分配给特定的事务，而不考虑并发事务的行为。但是，它仍然支持事务之间共享帧</p>
</li>
<li>
<p>Most systems use a combination of both global and local policies.</p>
</li>
</ul>
</li>
</ul>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #05: Storage Models &amp; Compression</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter5/</link>
    <pubDate>Mon, 08 Apr 2024 10:31:51 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter5/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-05-storage-models--compression">Lecture #05: Storage Models &amp; Compression</h2>
<h3 id="database-workloads">DataBase WorkLoads</h3>
<ul>
<li>
<p><strong>On-Line Transaction Processing(OLTP)</strong>:Fast operations that only read/update a small amount of data each time.</p>
<ul>
<li>快速操作，事务简单，读/写数据量很小</li>
<li>通常处理的写操作多于读操作</li>
<li>例子：银行转一次钱</li>
<li>往往意味着高并发，比如支付宝，微信支付</li>
</ul>
</li>
<li>
<p><strong>On-Line Analytical Processing(OLAP):</strong> Complex queries that read of a lot of data to computer aggregates</p>
<ul>
<li>一般是公司要对某一段时间的所有数据进行统计分析的时候使用</li>
<li>事务复杂，且要读大量的数据，从现有的大量数据中分析派生出新的数据</li>
<li>典型代表：数仓，深度学习的数据收集（比如常见的深度学习模型的训练）</li>
</ul>
</li>
<li>
<p><strong>Hybrid(混合) Transaction + Analytical Processing(HTAP):</strong> OLTP+OLAP together on the same database instance</p>
<ul>
<li>希望这个数据库两种事务都能应对（兼顾）</li>
<li>很像之前讲的disk和memory的结合体（</li>
</ul>
</li>
<li>
<p>公司方案:<strong>BIFURCATED ENVIRONMENT</strong>：OLTP和OLAP分别布置</p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-1.png" title="/img/CMU 15-445 Database Systems/chapter5-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-1.png" data-sub-html="<h2>OLTP负责对用户的事务处理，在流量低的时候将数据整合到数仓里面，分析师再过来操作数仓进行数据分析</h2>">
        
    </a><figcaption class="image-caption">OLTP负责对用户的事务处理，在流量低的时候将数据整合到数仓里面，分析师再过来操作数仓进行数据分析</figcaption>
    </figure>
<ul>
<li>
<p>HTAP或许能避免上面<strong>BIFURCATED ENVIRONMENT</strong>(要准备两套数据库，而且数据还要从这两套系统中来回迁移)的问题，但是也有可能是两头都跑不好</p>
</li>
<li>
<p>行存的模型适合OLTP，列存(DSM)的模型适合OLAP</p>
</li>
<li>
<p>现在很多主流数据库也会加入列存引擎来处理OLAP的事务</p>
</li>
</ul>
<h3 id="storage-models">Storage Models</h3>
<ul>
<li>这部分主要讲数据库的数据在磁盘上面不同的物理布局，对于不同的场景，不同的布局会有不一样的效果</li>
</ul>
<hr>
<ul>
<li>
<p><strong>N-Ary Storage Model (NSM)</strong></p>
<ul>
<li>
<p><u>The DBMS stores (almost) all attributes for a single tuple contiguously in a single page</u>(一个元组里面是所有属性，连续地存储在一个页中)</p>
</li>
<li>
<p>Also known as a “<strong>row store</strong>”（国内叫“行存”）</p>
</li>
<li>
<p>非常适合OLTP的工作负载，读的东西少，但是一直在频繁的写数据，行存的模型对写数据很友好</p>
</li>
<li>
<p>NSM数据库页面大小通常是硬件页面的常数倍(m $\times$ 4KB)：Oracle(4KB),Postgres(8KB),MySQL(16KB)</p>
</li>
</ul>
</li>
<li>
<p><strong>NSM: PHYSICAL ORGANIZATION</strong></p>
<ul>
<li>
<p>无论是定长还是不定长度，这个NSM都是用的之前的slotted page的存储模型，元组就连续的存储在页里面，再加上一个slot array来做标定，header来存储头部必要的一些信息</p>
</li>
<li>
<p>DBMS区分物理元组的唯一标识：<strong>record id</strong>(page#,slot#)，注意这个<strong>record id</strong>是页标识+槽标识构造的，不是数据库主键/唯一键，一定要区分!</p>
</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-2.png" title="/img/CMU 15-445 Database Systems/chapter5-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-2.png" data-sub-html="<h2>slotted page的物理存储模型</h2>">
        
    </a><figcaption class="image-caption">slotted page的物理存储模型</figcaption>
    </figure>
<ul>
<li><strong>NSM</strong>性能上的缺点
<ul>
<li>进行OLAP的操作的时候会有很多无用的数据，浪费效率</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-3.png" title="/img/CMU 15-445 Database Systems/chapter5-3.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-3.png" data-sub-html="<h2>OLAP往往是所有行的扫描，但是只要其中的几列数据，其他列的数据是无用的，但是DBMS就要为此扫描所有页，大量的I/O造成了效率低下</h2>">
        
    </a><figcaption class="image-caption">OLAP往往是所有行的扫描，但是只要其中的几列数据，其他列的数据是无用的，但是DBMS就要为此扫描所有页，大量的I/O造成了效率低下</figcaption>
    </figure>
<ul>
<li><strong>NSM:SUMMARY</strong>
<ul>
<li><strong>Advantages</strong>
<ul>
<li>Fast inserts, updates, and deletes</li>
<li>Good for queries that need the entire tuple(OLTP)</li>
<li>Can use index-oriented physical storage for clustering</li>
</ul>
</li>
<li><strong>Disadvantages</strong>
<ul>
<li>Not good for scanning large portions of the table and/or a subset of the attributes</li>
<li>Terrible memory locality for OLAP access patterns.(数据分散到了多个页，属性列不是连续的)</li>
<li>Not ideal for compression because of multiple value domains within a single page.(压缩数据靠的是数据的相似性，同一列的数据相似性才高，但是NSM是按行存不同列的数据，每一页数据的相似性很低，很难压缩)</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p><strong>Decomposition Storage Model (DSM)</strong></p>
<ul>
<li>The DBMS stores a single attribute for all tuples contiguously in a block of data.</li>
<li>Also known as a “<strong>column store</strong>”(国内叫“列存”)</li>
<li>非常适合OLAP的工作负载，大量的读取数据，而且往往都要的是某一列属性</li>
<li>DBMS这个时候主要就负责读写的时候拆分和组合属性</li>
</ul>
</li>
<li>
<p><strong>DSM: PHYSICAL ORGANIZATION</strong></p>
<ul>
<li>
<p>Store attributes and metadata (e.g.nulls) in separate arrays of fixedlength values.(固定长度的属性最好存储，数组完美匹配)</p>
</li>
<li>
<p>唯一标识：偏移量</p>
</li>
<li>
<p>难的是处理变长属性，需要在前面在加上一个id数据来做为标识，这样其实造成了数据冗余（id存了好几次）</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-6.png" title="/img/CMU 15-445 Database Systems/chapter5-6.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-6.png" data-sub-html="<h2>属性定长和不定长的两种存储方式</h2>">
        
    </a><figcaption class="image-caption">属性定长和不定长的两种存储方式</figcaption>
    </figure>
</li>
<li>
<p>Maintain a separate file per attribute with a dedicated header area for metadata about the entire column.(一个属性一个文件，加上Header来处理元数据)</p>
</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-4.png" title="/img/CMU 15-445 Database Systems/chapter5-4.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-4.png" data-sub-html="<h2>DSM的文件结构</h2>">
        
    </a><figcaption class="image-caption">DSM的文件结构</figcaption>
    </figure>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-5.png" title="/img/CMU 15-445 Database Systems/chapter5-5.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-5.png" data-sub-html="<h2>OLAP下只需要找对应属性的页，不需要像NSM那样全页扫描</h2>">
        
    </a><figcaption class="image-caption">OLAP下只需要找对应属性的页，不需要像NSM那样全页扫描</figcaption>
    </figure>
<ul>
<li>
<p><strong>DSM:SUMMARY</strong></p>
<ul>
<li><strong>Advantages</strong>
<ul>
<li>Reduces the amount wasted I/O per query because the DBMS only reads the data that it needs.</li>
<li>Faster query processing because of increased locality and cached data reuse.（属性上面的局部性 &gt; 行的局部性）</li>
<li>Better data compression (more on this in a few slides).</li>
</ul>
</li>
<li><strong>Disadvantages</strong>
<ul>
<li>Slow for point queries, inserts, updates, and deletes because of tuple splitting/stitching/reorganization.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>OBSERVATION</strong></p>
<ul>
<li>OLAP往往也要面临JOIN这样的操作，但是DSM的存储模型在JOIN上面的操作不是很优秀</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p><strong>PAX STORAGE MODEL</strong></p>
<ul>
<li>
<p>Partition Attributes Across (PAX) is a <strong>hybrid storage model</strong> that vertically partitions attributes within a database page.</p>
</li>
<li>
<p>The goal is to get the benefit of <strong>faster processing on columnar storage while retaining</strong> the spatial locality benefits of <strong>row storage</strong>.（保留行存优势地前提下，在列处理上面提速来匹配OLAP操作）</p>
</li>
</ul>
</li>
<li>
<p><strong>PAX: PHYSICAL ORGANIZATION</strong></p>
<ul>
<li>水平地将行划分为组，然后将这组的属性进行列存</li>
<li>每个页的Header里面会标明这个页里面每一组的偏移量
<ul>
<li>如果这个文件不可变，Header就存到页脚</li>
</ul>
</li>
<li>每一组都会有自己的<strong>metadata header</strong>(比如标明那一行那个属性是null，其他有关这个组的信息)</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-7.png" title="/img/CMU 15-445 Database Systems/chapter5-7.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-7.png" data-sub-html="<h2>PAX的物理结构</h2>">
        
    </a><figcaption class="image-caption">PAX的物理结构</figcaption>
    </figure>
<h3 id="database-compression">Database Compression</h3>
<ul>
<li>
<p>When a DBMS uses compression, it is always lossless because people don’t like losing data. Any kind of lossy compression must be performed at the application level.（数据库只能做无损压缩，有损压缩只能在应用程序里面做，数据库是绝对不给做的）</p>
</li>
<li>
<p><strong>COMPRESSION GRANULARITY</strong>（压缩的力度）</p>
</li>
</ul>
<h3 id="naïve-compression">NAÏVE COMPRESSION</h3>
<ul>
<li>
<p><strong>Block-Level</strong>：压缩同一个表里面的元组块</p>
</li>
<li>
<p>使用通用的算法来压缩数据</p>
</li>
<li>
<p>压缩的范围仅限于提供的数据</p>
</li>
<li>
<p>LZO (1996), LZ4 (2011), Snappy (2011),Oracle OZIP (2014), Zstd (2015)</p>
</li>
</ul>
<p>需要考虑的因素</p>
<ul>
<li>计算的开销</li>
<li>压缩和解压的速度</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-8.png" title="/img/CMU 15-445 Database Systems/chapter5-8.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-8.png" data-sub-html="<h2>MySQL INNODB的解压过程，把压缩好的数据读到缓存池再解压</h2>">
        
    </a><figcaption class="image-caption">MySQL INNODB的解压过程，把压缩好的数据读到缓存池再解压</figcaption>
    </figure>
<ul>
<li>这个模式的一个弊端就是每次读写数据的时候都先要做解码，效率很低</li>
<li>另一个思路：能不能不解码，而是对查询的数据使用算法变换，然后操作压缩后的数据</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-9.png" title="/img/CMU 15-445 Database Systems/chapter5-9.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-9.png" data-sub-html="<h2>这个就是上面的想法，把SQL中的数据进行变换，然后直接操作压缩的数据</h2>">
        
    </a><figcaption class="image-caption">这个就是上面的想法，把SQL中的数据进行变换，然后直接操作压缩的数据</figcaption>
    </figure>
<h3 id="columnar-compression">COLUMNAR COMPRESSION</h3>
<ul>
<li>
<p><strong>Column-Level</strong>：压缩属性值的列(DSM-only)，也叫<strong>COLUMNAR COMPRESSION</strong>（柱状压缩）</p>
</li>
<li>
<p><strong>Run-length Encoding</strong></p>
<ul>
<li>将单个列中的相同值改为三元组
<ul>
<li>属性的值</li>
<li>该值在这一列的起始位置</li>
<li>该值的元素个数</li>
</ul>
</li>
<li>适合的情景是该列对属性进行智能排序，这样可以获取最大化压缩的机会</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-10.png" title="/img/CMU 15-445 Database Systems/chapter5-10.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-10.png" data-sub-html="<h2>Run-length Encoding算法演示</h2>">
        
    </a><figcaption class="image-caption">Run-length Encoding算法演示</figcaption>
    </figure>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-11.png" title="/img/CMU 15-445 Database Systems/chapter5-11.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-11.png" data-sub-html="<h2>如果只有GROUP BY的操作，那么压缩的会更好</h2>">
        
    </a><figcaption class="image-caption">如果只有GROUP BY的操作，那么压缩的会更好</figcaption>
    </figure>
<ul>
<li><strong>Bit-Packing Encoding</strong>
<ul>
<li>如果整数属性的值很小，那么二进制前面的几位就可以不要</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-12.png" title="/img/CMU 15-445 Database Systems/chapter5-12.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-12.png" data-sub-html="<h2>bit packing压缩方案</h2>">
        
    </a><figcaption class="image-caption">bit packing压缩方案</figcaption>
    </figure>
<ul>
<li><strong>PATCHING/MOSTLY ENCODING</strong>
<ul>
<li>当属性中的大多数值小于对应类型的最大值时，使用更小的数据类型来对其进行存储，对于少数数值很大的值仍然使用原来的数据类型来进行存储</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-13.png" title="/img/CMU 15-445 Database Systems/chapter5-13.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-13.png" data-sub-html="<h2>int32-&gt;int8，Header会标定一下那个数据还是用的int32</h2>">
        
    </a><figcaption class="image-caption">int32-&gt;int8，Header会标定一下那个数据还是用的int32</figcaption>
    </figure>
<ul>
<li>
<p><strong>Bit-map Encoding</strong></p>
<ul>
<li>
<p>对于一些属性，它的值就那些（比如枚举）</p>
</li>
<li>
<p>那直接用位运算存几个bit里面就完全够了</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-14.png" title="/img/CMU 15-445 Database Systems/chapter5-14.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-14.png" data-sub-html="<h2>一共只有Y和N，那直接用两位bit就够了</h2>">
        
    </a><figcaption class="image-caption">一共只有Y和N，那直接用两位bit就够了</figcaption>
    </figure>
</li>
<li>
<p>但是从上面的图上面来看这个模式没有完全压榨二进制位运算的空间（比如只能用01和10，00和11都浪费了），所以在一些情况下压缩不如不压缩</p>
</li>
</ul>
</li>
<li>
<p><strong>Delta Encoding</strong></p>
<ul>
<li>
<p>记录和上一列的差别，不记录实际数据</p>
</li>
<li>
<p>基础值内联到表里面或者单独查询，有这个基础值下面的值都能推断出来了</p>
</li>
<li>
<p>配合<strong>Run-Length-Encoding</strong>压缩效果会更好</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-15.png" title="/img/CMU 15-445 Database Systems/chapter5-15.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-15.png" data-sub-html="<h2>先Delta Encoding再Run-Length-Encoding</h2>">
        
    </a><figcaption class="image-caption">先Delta Encoding再Run-Length-Encoding</figcaption>
    </figure>
</li>
</ul>
</li>
<li>
<p><strong>DICTIONARY COMPRESSION</strong></p>
<ul>
<li>
<p>Replace frequent values with smaller fixed-length codes and then maintain a mapping (dictionary) from the codes to the original values(搞一个K-V的映射，然后把原来数据的V换成长度更小的K)</p>
</li>
<li>
<p>Most widely used native compression scheme in DBMSs.</p>
</li>
<li>
<p>理想的字典查询是希望在单点查询和范围查询上面都有良好的性能</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-16.png" title="/img/CMU 15-445 Database Systems/chapter5-16.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-16.png" data-sub-html="<h2>建一个Hash表，然后压缩原表</h2>">
        
    </a><figcaption class="image-caption">建一个Hash表，然后压缩原表</figcaption>
    </figure>
</li>
<li>
<p>字典需要有两个功能</p>
<ul>
<li>Eecode/Locate：给了Key要能编码</li>
<li>Decode/Extract：给了Value能解压成Key</li>
<li><strong>所以即使上面会用Hash这个词，但是这个结构不能靠Hash函数来实现（Hash只能正着算，不能反向算）</strong></li>
</ul>
</li>
<li>
<p>字典还要保序，不能说编完码之后你原表的数据顺序就变了，因为你要考虑范围查找这种东西</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-17.png" title="/img/CMU 15-445 Database Systems/chapter5-17.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-17.png" data-sub-html="<h2>如果保序，范围查找对SQL里面的key做一次Hash就可以操作压缩后的数据了</h2>">
        
    </a><figcaption class="image-caption">如果保序，范围查找对SQL里面的key做一次Hash就可以操作压缩后的数据了</figcaption>
    </figure>
</li>
<li>
<p>字典压缩还有一个好处就是如果查询中有DISTINCT这种关键字，那么不需要进行全表扫描，直接去字典里面扫描一遍Value就够了</p>
</li>
<li>
<p>数据结构的选择</p>
<ul>
<li>Array
<ul>
<li>一个数组包含可变长度的字符串，一个数组包含指向映射到前面数组字符串的指针</li>
<li>更新成本很高，只能用在不可变文件中</li>
</ul>
</li>
<li>Hash Table
<ul>
<li>快速，紧凑</li>
<li>无法进行范围查询和前缀查询</li>
</ul>
</li>
<li>B+ Tree
<ul>
<li>比Hash Table要慢，而且占用更多的内存</li>
<li>支持范围查询和前缀查询</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #04: Database Storage (Part II)</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter4/</link>
    <pubDate>Mon, 25 Mar 2024 21:32:28 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter4/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-04-database-storage-part-ii">Lecture #04: Database Storage (Part II)</h2>
<h3 id="log-structured-storage">Log-Structured Storage</h3>
<ul>
<li>
<p>Slotted-Page(页+槽)的存储结构遇到的一些问题</p>
<ul>
<li><strong>Fragmentation</strong>:删除元组可能会在页中留下空白</li>
<li><strong>Useless Disk I/O</strong>:更新一组数据，但是你要把这个数据所在的页从磁盘load到内存里面</li>
<li><strong>Random Disk I/O</strong>:如果说你随机更新了很多数据，那么可能需要从磁盘load好多页到内存，时间会变得非常慢</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>另一种解决思路:<strong>Log-Structured Storage</strong></li>
</ul>
<blockquote>
<p>Log-structured Storage is based on the Log-Structured File System (LSFS) by Rosenblum and Ousterhout’92 and Log-structured Merge Trees (LSM Tree) by O’Neil, Cheng</p>
<p>LSM-tree也是数据库里面一个重要的知识点</p>
</blockquote>
<ul>
<li>DBMS不存储元组，而是只存储元组更改的记录，DBMS将新的日志添加到内存缓冲区中，不检查之前记录，然后按照更改数据写回到磁盘里面(这个顺序写盘就能解决上面的<strong>Random Disk I/O</strong>问题)，</li>
<li>这种模式对于写数据库的操作来说速度很快（直接写一个log刷回到盘里面就行了），这个在K-V数据库里面很流行</li>
<li>读记录的时候则需要从最旧的顺序扫描日志文件，从而获取元组的最新内容，为了提高效率，log也会使用索引来加快查找速度</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter4-1.png" title="/img/CMU 15-445 Database Systems/chapter4-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter4-1.png" data-sub-html="<h2>log&#43;索引</h2>">
        
    </a><figcaption class="image-caption">log+索引</figcaption>
    </figure>
<ul>
<li>
<p><strong>Compaction</strong></p>
</li>
<li>
<p>如果就一直记录日志，那么磁盘肯定有一天会不够写，所以DBMS需要定期压缩日志，压缩后的日志甚至不用按照时间戳排序，而是按照id排序（找的更快）</p>
</li>
<li>
<p>按层压缩（<strong>Level Compaction</strong>）</p>
<ul>
<li>代表:RocksDB(RocksDB第一/二/三层文件)</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter4-2.png" title="/img/CMU 15-445 Database Systems/chapter4-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter4-2.png" data-sub-html="<h2>Level0的两个文件内部可以压缩，但是如果update A在文件一，delete A在文件二，那这两条数据就没法合并压缩了</h2>">
          
      </a><figcaption class="image-caption">Level0的两个文件内部可以压缩，但是如果update A在文件一，delete A在文件二，那这两条数据就没法合并压缩了</figcaption>
      </figure>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter4-3.png" title="/img/CMU 15-445 Database Systems/chapter4-3.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter4-3.png" data-sub-html="<h2>解决方案：直接读取这两个文件中的日志，一起压缩到Level1的一个新文件里面</h2>">
          
      </a><figcaption class="image-caption">解决方案：直接读取这两个文件中的日志，一起压缩到Level1的一个新文件里面</figcaption>
      </figure>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter4-4.png" title="/img/CMU 15-445 Database Systems/chapter4-4.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter4-4.png" data-sub-html="<h2>这种情况可以一直递归压缩</h2>">
          
      </a><figcaption class="image-caption">这种情况可以一直递归压缩</figcaption>
      </figure>
<ul>
<li>RocksDB最多能压缩到第七层</li>
<li>读取的时候就从0层开始读，读不到就再读下一层</li>
</ul>
</li>
<li>
<p>通用压缩（<strong>Universal Compaction</strong>）</p>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter4-5.png" title="/img/CMU 15-445 Database Systems/chapter4-5.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter4-5.png" data-sub-html="<h2>不用分层，能合并就合并</h2>">
          
      </a><figcaption class="image-caption">不用分层，能合并就合并</figcaption>
      </figure>
</li>
</ul>
<hr>
<ul>
<li><strong>Log-Structured Storage</strong>的利弊
<ul>
<li>快速的顺序写入，对于需要频繁更改的数据库来说效率提示很多</li>
<li>读取可能很慢（要读很多日志）</li>
<li>压缩日志的代价很大</li>
<li>受制于写入放大（一个逻辑写入可能有多个物理写入，比如UPDATE ALL STUDENT age TO age + 1，对于这种语句到它的日志里面要写一堆）</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter4-6.png" title="/img/CMU 15-445 Database Systems/chapter4-6.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter4-6.png" data-sub-html="<h2>Log-Structured Storage代表数据库</h2>">
        
    </a><figcaption class="image-caption">Log-Structured Storage代表数据库</figcaption>
    </figure>
<h3 id="index-organized-storage">Index-Organized Storage</h3>
<ul>
<li>加入额外的索引存储，从而提高查找的速度</li>
</ul>
<h3 id="data-representation">Data Representation</h3>
<blockquote>
<p>There are five high level datatypes that can be stored in tuples: <strong>integers, variable-precision numbers, fixedpoint precision numbers, variable length values, and dates/times.</strong></p>
</blockquote>
<ul>
<li>
<p>元组中的数据本质就是字节数组，你要规定如何存储和解释这些字节，从而存储你的信息</p>
<ul>
<li>
<p>字节对齐的问题</p>
<ul>
<li><strong>Padding</strong>:在属性后添加空位，确保元组对其</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter4-7.png" title="/img/CMU 15-445 Database Systems/chapter4-7.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter4-7.png" data-sub-html="<h2>属性长度不够，后面填充字节码</h2>">
            
        </a><figcaption class="image-caption">属性长度不够，后面填充字节码</figcaption>
        </figure>
<ul>
<li>
<p><strong>Reordering</strong>:重新排列属性+填充</p>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter4-8.png" title="/img/CMU 15-445 Database Systems/chapter4-8.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter4-8.png" data-sub-html="<h2>能凑到一块的先凑起来，然后再填充</h2>">
              
          </a><figcaption class="image-caption">能凑到一块的先凑起来，然后再填充</figcaption>
          </figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>其他数据表示：整数，字符串这俩都很好记录，字符串可能头部需要存储一个长度，但是也不难，这里重点讨论浮点数/高精度和时间的表示</p>
</li>
<li>
<p>浮点数:IEEE-754下面的标准转到十进制是有误差的，这个在金融等需要绝对准确的领域里面是无法忍受的</p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter4-9.png" title="/img/CMU 15-445 Database Systems/chapter4-9.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter4-9.png" data-sub-html="<h2>0.1 &#43; 0.2 != 0.3</h2>">
        
    </a><figcaption class="image-caption">0.1 + 0.2 != 0.3</figcaption>
    </figure>
<ul>
<li>解决方案：高精度</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter4-10.png" title="/img/CMU 15-445 Database Systems/chapter4-10.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter4-10.png" data-sub-html="<h2>pg的高精度</h2>">
        
    </a><figcaption class="image-caption">pg的高精度</figcaption>
    </figure>
<hr>
<ul>
<li>
<p><strong>LARGE VALUES</strong></p>
</li>
<li>
<p>某一段数据很长造成的，比如在存储字符串的地方存了一本电子小说的内容，数据长到比最小的页还长，整个页都没法完整地把这个数据给存储下来</p>
</li>
<li>
<p>解决方案:<strong>Overflow Page</strong>，新开一个“溢出页”，把大的数据存到这个新开的页里面，然后原始页里面存放这个数据的地方去存放这个新开的页的地址</p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter4-11.png" title="/img/CMU 15-445 Database Systems/chapter4-11.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter4-11.png" data-sub-html="<h2>溢出页和原有页的关系</h2>">
        
    </a><figcaption class="image-caption">溢出页和原有页的关系</figcaption>
    </figure>
<ul>
<li>
<p>如果溢出页还不够：后面再加溢出页（当成拉链法去理解就好）</p>
</li>
<li>
<p><strong>使用数据库尽量避免这样的情况，很损害数据库的性能</strong></p>
<ul>
<li>一种方案是存成文件，然后数据库里面存文件路径，缺点就是这个文件里面数据没有持久性和事务保护</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Null Data Types</strong></li>
<li>在DBMS里面表示null的方法
<ul>
<li><strong>Null Column Bitmap Header</strong>：在数据的头部集中存储一个bitmap，这个bitmap就表示本条数据里面那些属性是null，这是最常见的方法</li>
<li><strong>Special Values</strong>：用特殊值来标记null，比如给整数标定一个int32min来表示null</li>
<li><strong>Per Attribute Null Flag</strong>：给每个属性前面都加一位来表示这个属性是不是为null，不推荐，因为不节约内存，多这一位的数据可能会造成内存需要填充好几位才能维持字节对齐</li>
</ul>
</li>
</ul>
<h3 id="system-catalogs">System Catalogs</h3>
<ul>
<li>每个数据库都有一个System Catalogs，里面的表存自己的元数据（有什么表，表结构，用户，用户权限，统计信息，日志信息。。。）</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter4-12.png" title="/img/CMU 15-445 Database Systems/chapter4-12.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter4-12.png" data-sub-html="<h2>MySQL的information schema</h2>">
        
    </a><figcaption class="image-caption">MySQL的information schema</figcaption>
    </figure>
<ul>
<li>每个数据库里面都有information schema，但是存的东西不一样</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter4-13.png" title="/img/CMU 15-445 Database Systems/chapter4-13.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter4-13.png" data-sub-html="<h2>MySQL的information schema里面的TABLES表，存了这个数据库里面所有表的信息</h2>">
        
    </a><figcaption class="image-caption">MySQL的information schema里面的TABLES表，存了这个数据库里面所有表的信息</figcaption>
    </figure>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #03: Database Storage (Part I)</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter3/</link>
    <pubDate>Mon, 25 Mar 2024 15:48:05 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter3/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-03-database-storage-part-i">Lecture #03: Database Storage (Part I)</h2>
<h3 id="storage">Storage</h3>
<ul>
<li>
<p>本课程讨论的都是存储在磁盘上的数据库，不考虑后期出现的内存数据库</p>
</li>
<li>
<p>补充计组的知识：设备离CPU越近，存储速度越快，内存越小，价格越贵</p>
</li>
<li>
<p><strong>Volatile Devices</strong></p>
<ul>
<li>断了电就没有数据了</li>
<li>可以通过字节寻址快速随机访问，程序可以随机获取数据</li>
<li>这个地方基本就叫内存</li>
</ul>
</li>
<li>
<p><strong>Non-Volatile Devices</strong></p>
<ul>
<li>断了电也不怕</li>
<li>也是块/页可寻址的，但是如果程序要读取需要先load到内存</li>
<li>更适合顺序访问（加载到内存+局部性原理）</li>
<li>一般叫磁盘，这个课不区分机械盘和SSD</li>
</ul>
</li>
<li>
<p>部分公司后面为了获取两个设备的长处推出了“持久内存”，但是本课程不会讨论，而且从Intel 2022开始逐步停产该系列产品来看，它没有想象中那么好</p>
</li>
<li>
<p>本课程主要是磁盘存储的数据库，我们必须明白一点，磁盘上面的数据必须要先load到内存中才能操作</p>
</li>
</ul>
<h3 id="disk-oriented-dbms-overview">Disk-Oriented DBMS Overview</h3>
<ul>
<li>
<p>数据库全部存储在磁盘上，数据库文件被数据组织成页，<strong>第一页是目录页</strong></p>
</li>
<li>
<p>为了对数据库进行操作，DBMS需要将数据放入内存，<strong>这个时候会使用一个缓冲池来管理在磁盘和内存之间移动的数据</strong></p>
</li>
<li>
<p>例子：以DBMS中的查询为例，执行引擎会让缓冲池请求特定的页面，缓冲池将该页加载到内存，然后返回给执行引擎目前内存中该页的指针，使得执行引擎可以进行下一步的工作</p>
</li>
</ul>
<h3 id="dbms-vs-os">DBMS vs. OS</h3>
<ul>
<li>
<p>DBMS和OS的虚拟内存都涉及到了cache和disk调用的问题，那么是否可以在DBMS中使用mmap呢</p>
<ul>
<li>不可以</li>
<li>mmap一旦出现地址错误会block，这对于DBMS的性能来说是不能接收的</li>
<li>mmap是为OS设计的，对于cache和disk的调用，DBMS其实更应该根据自己的情况来定制化其他方案</li>
</ul>
</li>
<li>
<p>但是我们和disk交互的时候仍然可以使用下面的OS调用，这些是符合我们期望的</p>
</li>
</ul>
<blockquote>
<p>• <strong>madvise</strong>: Tells the OS know when you are planning on reading certain pages.</p>
<p>• <strong>mlock</strong>: Tells the OS to not swap memory ranges out to disk.</p>
<p>• <strong>msync</strong>: Tells the OS to flush memory ranges out to disk.</p>
</blockquote>
<ul>
<li>对于DBMS这种如此吃性能的设施，很多解决方案还是需要手搓定制化，而不是依赖OS的调用</li>
</ul>
<h3 id="file-storage">File Storage</h3>
<ul>
<li>
<p>DBMS将数据库作为文件存储在磁盘上，有些使用文件层次结构，有些使用单个文件（比如SQLite）</p>
</li>
<li>
<p>OS是不知道这些文件存储的是什么，只有DBMS才能读懂和操作它们（有特定的编码）</p>
</li>
<li>
<p>DBMS的存储管理器负责管理数据库的文件。<strong>它将文件表示为页面的集合</strong>，它还跟踪哪些数据被读取和写入到页面，以及这些页面中有多少空闲空间</p>
</li>
</ul>
<h3 id="database-pages">Database Pages</h3>
<ul>
<li>
<p>DBMS会将多个文件组织成固定大小的数据块，这个东西就叫页</p>
</li>
<li>
<p>页面可以包含不同的数据类型，但是大多数系统是不会在页面中混合使用这些类型的</p>
</li>
<li>
<p>有些系统要求页面是自包含的，这意味着读取每个页面所需的所有信息都在页面本身上</p>
</li>
<li>
<p>每个页面都有一个唯一的标识符</p>
</li>
<li>
<p>如果数据库是单个文件，那么页id可以只是文件偏移量。大多数DBMS都有一个间接层，它将页id映射到文件路径和偏移量。系统的上层将要求提供特定的页码。然后，存储管理器必须将该页码转换为文件和偏移量以查找该页</p>
</li>
<li>
<p>大多数的页大小都是固定的，不然难以管理内存（内存碎片）</p>
</li>
<li>
<p>DBMS中的三种页面</p>
<ul>
<li>Hardware page (usually 4 KB).</li>
</ul>
<ol start="2">
<li>
<p>OS page (4 KB).</p>
</li>
<li>
<p>Database page (1-16 KB).</p>
</li>
</ol>
</li>
<li>
<p>硬件页设计的小是为了能够利用硬件的条件原子性写入，但是到了数据库的页就无法保证了，所以需要使用额外的措施保证原子性</p>
</li>
</ul>
<h3 id="database-heap">Database Heap</h3>
<ul>
<li>数据库的页“堆”成一个文件的方式</li>
<li>也要能够有创建页，遍历页，删除页的操作，那么页之间怎么组织？
<ul>
<li>Linked List</li>
<li>Page Directory</li>
</ul>
</li>
</ul>
<h3 id="page-layout">Page Layout</h3>
<ul>
<li>
<p>Every page includes a header that records meta-data about the page’s contents:</p>
<ul>
<li>
<p>Page size.</p>
</li>
<li>
<p>Checksum.</p>
</li>
<li>
<p>DBMS version.</p>
</li>
<li>
<p>Transaction visibility.</p>
</li>
<li>
<p>Self-containment. (Some systems like Oracle require this.)</p>
</li>
</ul>
</li>
<li>
<p>数据的存储方案</p>
<ul>
<li>
<p>Tuple-oriented:按照真实数据一行一行存</p>
<ul>
<li>
<p>如何避免内存碎片化问题：Slotted Page结构，索引在一个区，剩下的空间存储数据</p>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter3-1.png" title="/img/CMU 15-445 Database Systems/chapter3-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter3-1.png" data-sub-html="<h2>Slotted Page</h2>">
              
          </a><figcaption class="image-caption">Slotted Page</figcaption>
          </figure>
</li>
<li>
<p>定位：page_id + offset/slot</p>
</li>
</ul>
</li>
<li>
<p>Log-Structured:存操作日志</p>
</li>
</ul>
</li>
</ul>
<h3 id="tuple-layout">Tuple Layout</h3>
<ul>
<li>一组数据存储在磁盘上面就是bytes，需要我们附加其他的信息进行解析</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter3-2.png" title="/img/CMU 15-445 Database Systems/chapter3-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter3-2.png" data-sub-html="<h2>Tuple布局</h2>">
        
    </a><figcaption class="image-caption">Tuple布局</figcaption>
    </figure>
<ul>
<li>
<p><strong>Tuple Header</strong>: Contains meta-data about the tuple.</p>
<ul>
<li>
<p>并发控制信息（为了事务安全）</p>
</li>
<li>
<p>NULL值的Bit映射（解析Tuple需要的信息）</p>
</li>
<li>
<p>注：不需要存结构信息（每一个Header都存一下内存浪费太多了）</p>
</li>
<li>
<p>属性通常按照创建表的时候指定的数据存储</p>
</li>
<li>
<p>大多数DBMS不允许一个元组超过一个页面的大小</p>
</li>
</ul>
</li>
<li>
<p><strong>Unique Identifier</strong></p>
<ul>
<li>最常见的是page_id+offset</li>
<li>应用程序不能直接用这些，只能用主键这类的属性（因为这个东西会因为内存整理而更改，程序员只能和DBMS这部分的管理系统用主键交流，由这个系统进行映射）</li>
</ul>
</li>
<li>
<p><strong>Denormalized Tuple Data</strong>: If two tables are related, the DBMS can “pre-join” them, so the tables end up
on the same page. This makes reads faster since the DBMS only has to load in one page rather than two
separate pages. However, it makes updates more expensive since the DBMS needs more space for each
tuple.</p>
<ul>
<li>两个表如果总是需要JOIN，那我提前给你在内存中连好</li>
<li>理论上可行，现实中会让插入等的复杂度变的很高，目前这种方案已经被废止</li>
</ul>
</li>
</ul>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #02: Modern SQL</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter2/</link>
    <pubDate>Sun, 24 Mar 2024 22:00:23 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter2/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-02-modern-sql">Lecture #02: Modern SQL</h2>
<h3 id="关系型数据库sql">关系型数据库|SQL</h3>
<ul>
<li>
<p>在历经上个世纪的探索和总结后，关系型数据库被发明了出来，其使用的语言也规范为了SQL</p>
</li>
<li>
<p>SQL可以分为三类</p>
<ul>
<li>数据操作语言(DML):SELECT,INSERT,UPDATE,DELETE</li>
<li>数据定义语言(DDL):用于定义表，视图等</li>
<li>数据控制语言(DCL):用于访问控制，保证数据库的安全</li>
</ul>
</li>
<li>
<p>SQL也和其他编程语言一样，每隔几年会更新一次，目前规定最低标准是SQL-92</p>
<blockquote>
<p>Some of the major updates released with each new edition of the SQL standard are shown below.</p>
<p>• SQL:1999 Regular expressions, Triggers</p>
<p>• SQL:2003 XML, Windows, Sequences</p>
<p>• SQL:2008 Truncation, Fancy sorting</p>
<p>• SQL:2011 Temporal DBs, Pipelined DML</p>
<p>• SQL:2016 JSON, Polymorphic tables</p>
</blockquote>
</li>
</ul>
<h3 id="joins">Joins</h3>
<ul>
<li>合并一个或多个表中的列生成新表，主要用于需要使用多个表中数据的操作</li>
<li>例子：查学生成绩</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">student</span><span class="w"> </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">sid</span><span class="w"> </span><span class="nb">INT</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">name</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">login</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="k">UNIQUE</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">age</span><span class="w"> </span><span class="nb">SMALLINT</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">gpa</span><span class="w"> </span><span class="nb">FLOAT</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">course</span><span class="w"> </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">cid</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">name</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">enrolled</span><span class="w"> </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">sid</span><span class="w"> </span><span class="nb">INT</span><span class="w"> </span><span class="k">REFERENCES</span><span class="w"> </span><span class="n">student</span><span class="w"> </span><span class="p">(</span><span class="n">sid</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">cid</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="k">REFERENCES</span><span class="w"> </span><span class="n">course</span><span class="w"> </span><span class="p">(</span><span class="n">cid</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">grade</span><span class="w"> </span><span class="nb">CHAR</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>Example: Which students got an A in 15-721?</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">enrolled</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="n">student</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">s</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">grade</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;A&#39;</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">cid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;15-721&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">AND</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">sid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">sid</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="aggregates">Aggregates</h3>
<ul>
<li>接受Tuples，对整体进行计算，几乎只能用于SELECT输出列表</li>
</ul>
<blockquote>
<p>• AVG(COL): The average of the values in COL</p>
<p>• MIN(COL): The minimum value in COL</p>
<p>• MAX(COL): The maximum value in COL</p>
<p>• COUNT(COL): The number of tuples in the relation</p>
</blockquote>
<ul>
<li>Example: Get # of students with a ‘@cs’ login.</li>
<li>下面三个查询是等价的(第三个是COUNT里面填入数字统计出来的都是行数)</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">student</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">login</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;%@cs&#39;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="k">COUNT</span><span class="p">(</span><span class="n">login</span><span class="p">)</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">student</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">login</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;%@cs&#39;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="k">COUNT</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">student</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">login</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;%@cs&#39;</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>可以在一个SELECT中使用多个聚合函数</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="k">AVG</span><span class="p">(</span><span class="n">gpa</span><span class="p">),</span><span class="w"> </span><span class="k">COUNT</span><span class="p">(</span><span class="n">sid</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">student</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">login</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;%@cs&#39;</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>一些聚合函数支持<code>DISTINCT </code>的关键字（比如<code>COUNT, SUM, AVG)</code>），这样在计算的时候就直接去重了（<code>unique</code>）</p>
</li>
<li>
<p>使用聚合函数/分组后除了聚合函数其他的输出都是undefined，尽量不要使用</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="k">AVG</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">gpa</span><span class="p">),</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">cid</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">enrolled</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="n">student</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">s</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">sid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">sid</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>如果想让列属性是defined的话，那就必须在<code>GROUP BY</code>中加入该属性（也就是用这个属性分组）</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="k">AVG</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">gpa</span><span class="p">),</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">cid</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">enrolled</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="n">student</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">s</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">sid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">sid</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">cid</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>如果想要过滤聚合函数的数据，需要使用HAVING</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="k">AVG</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">gpa</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">avg_gpa</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">cid</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">enrolled</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="n">student</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">s</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">sid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">sid</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">cid</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">HAVING</span><span class="w"> </span><span class="n">avg_gpa</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">3</span><span class="p">.</span><span class="mi">9</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="o">#</span><span class="w"> </span><span class="err">规范写法</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="k">AVG</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">gpa</span><span class="p">),</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">cid</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">enrolled</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="n">student</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">s</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">sid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">sid</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">cid</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">HAVING</span><span class="w"> </span><span class="k">AVG</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">gpa</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">3</span><span class="p">.</span><span class="mi">9</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="string-operations">String Operations</h3>
<ul>
<li>SQL区分字符串大小写，使用单引号</li>
<li><strong>Pattern Matching</strong>: The LIKE keyword is used for string matching in predicates.</li>
</ul>
<blockquote>
<ul>
<li>“%” matches any substrings (including empty).</li>
<li>“_” matches any one character</li>
</ul>
</blockquote>
<ul>
<li><strong>String Functions</strong>:SQL-92 defines string functions. Many database systems implement other functions in
addition to those in the standard. Examples of standard string functions include SUBSTRING(S, B, E) and
UPPER(S).</li>
<li><strong>Concatenation</strong>: Two vertical bars (“||”) will concatenate two or more strings together into a single string.</li>
</ul>
<h3 id="date-and-time">Date and Time</h3>
<ul>
<li>Operations to manipulate DATE and TIME attributes. Can be used in either output or predicates. The specific
syntax for date and time operations varies wildly across systems.</li>
</ul>
<h3 id="output-redirection">Output Redirection</h3>
<ul>
<li>
<p>可以将查询的结果直接存储在另一张表中</p>
</li>
<li>
<p><strong>New Table</strong>: Store the output of the query into a new (permanent) table.</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="k">DISTINCT</span><span class="w"> </span><span class="n">cid</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">CourseIds</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">enrolled</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>Existing Table</strong>: Store the output of the query into a table that already exists in the database. <u>The target table must have the same number of columns with the same types as the target table, but the names of the columns in the output query do not have to match.</u></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">CourseIds</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="k">DISTINCT</span><span class="w"> </span><span class="n">cid</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">enrolled</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="output-control">Output Control</h3>
<ul>
<li>排序使用ORDER BY，默认是升序排序ASC，如果使用降序请显示标明DESC</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="n">sid</span><span class="p">,</span><span class="w"> </span><span class="n">grade</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">enrolled</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">cid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;15-721&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">grade</span><span class="w"> </span><span class="k">DESC</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>可以使用多个ORDER BY效果就是先排序A，A相同比较B</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="n">sid</span><span class="p">,</span><span class="w"> </span><span class="n">grade</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">enrolled</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">cid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;15-721&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">grade</span><span class="w"> </span><span class="k">DESC</span><span class="p">,</span><span class="w"> </span><span class="n">sid</span><span class="w"> </span><span class="k">ASC</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>在ORDER BY中可以计算/使用函数</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="n">sid</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">enrolled</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">cid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;15-721&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="k">UPPER</span><span class="p">(</span><span class="n">grade</span><span class="p">)</span><span class="w"> </span><span class="k">DESC</span><span class="p">,</span><span class="w"> </span><span class="n">sid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">ASC</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>可以使用LIMIT限制数据范围</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="n">sid</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">student</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">login</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;%@cs&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">LIMIT</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">sid</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">student</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">login</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;%@cs&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">LIMIT</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="k">OFFSET</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="nested-queries">Nested Queries</h3>
<ul>
<li>在查询中使用其他查询的结果，<strong>嵌套查询通常很难被优化</strong></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">student</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">student</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="n">sid</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">enrolled</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">e</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">sid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">sid</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">student</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">sid</span><span class="w"> </span><span class="k">IN</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="n">sid</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">enrolled</span><span class="w"> </span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>Nested Query Results Expressions:</p>
<p>• ALL: Must satisfy expression for all rows in sub-query.</p>
<p>• ANY: Must satisfy expression for at least one row in sub-query.</p>
<p>• IN: Equivalent to =ANY().</p>
<p>• EXISTS: At least one row is returned</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">course</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">EXISTS</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">enrolled</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">course</span><span class="p">.</span><span class="n">cid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">enrolled</span><span class="p">.</span><span class="n">cid</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="window-functions">Window Functions</h3>
<ul>
<li>解决了分组后非聚合函数数值undefined的问题，保留了原来的列结构</li>
</ul>
<a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter2-1.png" title="/img/CMU 15-445 Database Systems/chapter2-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter2-1.png">
        
    </a>
<ol>
<li>
<p>ROW NUMBER: The number of the current row.</p>
</li>
<li>
<p>RANK: The order position of the current row.</p>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="n">cid</span><span class="p">,</span><span class="w"> </span><span class="n">sid</span><span class="p">,</span><span class="w"> </span><span class="n">ROW_NUMBER</span><span class="p">()</span><span class="w"> </span><span class="n">OVER</span><span class="w"> </span><span class="p">(</span><span class="n">PARTITION</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">cid</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">enrolled</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">cid</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">ROW_NUMBER</span><span class="p">()</span><span class="w"> </span><span class="n">OVER</span><span class="w"> </span><span class="p">(</span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">cid</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">enrolled</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">cid</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>本质上面来说是一种分析函数，将order by之后的组进行二次分析，而不是只能使用聚合函数来获取那些值</li>
</ul>
<h3 id="common-table-expressions">Common Table Expressions</h3>
<ul>
<li>主要是WITH，和Python中的WITH做对比，表示临时变量，这样可以简单的生成临时表用于复杂的操作</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">WITH</span><span class="w"> </span><span class="n">cteName</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">cteName</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>递归操作</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">WITH</span><span class="w"> </span><span class="k">RECURSIVE</span><span class="w"> </span><span class="n">cteSource</span><span class="w"> </span><span class="p">(</span><span class="n">counter</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">(</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">UNION</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">(</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">cteSource</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    	</span><span class="k">WHERE</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">cteSource</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div>]]></description>
</item>
<item>
    <title>LRU and LRU-K</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/lru_and_lru-k/</link>
    <pubDate>Mon, 11 Mar 2024 14:26:44 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/lru_and_lru-k/</guid>
    <description><![CDATA[<h1 id="lru-and-lru-k">LRU and LRU-k</h1>
<ul>
<li>注：本文章为<a href="https://15445.courses.cs.cmu.edu/spring2024" target="_blank" rel="noopener noreffer">CMU15445-2024-spring</a> project1-task1的部分讲解，为了遵守<a href="https://www.cs.cmu.edu/~pavlo/" target="_blank" rel="noopener noreffer">Andy Pavlo</a>对于学术的要求，<strong>有关实验中的代码一律不予公开</strong>，只会讲解思路</li>
</ul>
<h2 id="实验要求">实验要求</h2>
<blockquote>
<p>This component is responsible for tracking page usage in the buffer pool. You will implement a new class called <code>LRUKReplacer</code> in <code>src/include/buffer/lru_k_replacer.h</code> and its corresponding implementation file in <code>src/buffer/lru_k_replacer.cpp</code>. Note that <code>LRUKReplacer</code> is a stand-alone class and is not related to any of the other <code>Replacer</code> classes. You are expected to implement only the LRU-K replacement policy. You don&rsquo;t have to implement LRU or a clock replacement policy, even if there is a corresponding file for it.</p>
<p>The LRU-K algorithm evicts a frame whose backward k-distance is maximum of all frames in the replacer. Backward k-distance is computed as the difference in time between current timestamp and the timestamp of kth previous access. A frame with fewer than k historical accesses is given +inf as its backward k-distance. <strong>When multiple frames have +inf backward k-distance, the replacer evicts the frame with the earliest overall timestamp (i.e., the frame whose least-recent recorded access is the overall least recent access).</strong></p>
<p>The maximum size for the <code>LRUKReplacer</code> is the same as the size of the buffer pool since it contains placeholders for all of the frames in the <code>BufferPoolManager</code>. However, at any given moment, not all the frames in the replacer are considered to be evictable. The size of <code>LRUKReplacer</code> is represented by the number of <em>evictable</em> frames. The <code>LRUKReplacer</code> is initialized to have no frames in it. Then, only when a frame is marked as evictable, replacer&rsquo;s size will increase.</p>
<p>You will need to implement the <em>LRU-K</em> policy discussed in this course. You will need to implement the following methods as defined in the header file (<code>src/include/buffer/lru_k_replacer.h</code>) and in the source file (<code>src/buffer/lru_k_replacer.cpp</code>):</p>
<ul>
<li><code>Evict(frame_id_t* frame_id)</code> : Evict the frame with largest backward k-distance compared to all other <strong>evictable</strong> frames being tracked by the <code>Replacer</code>. Store the frame id in the output parameter and return <code>True</code>. If there are no evictable frames return <code>False</code>.</li>
<li><code>RecordAccess(frame_id_t frame_id)</code> : Record that given frame id is accessed at current timestamp. This method should be called after a page is pinned in the <code>BufferPoolManager</code>.</li>
<li><code>Remove(frame_id_t frame_id)</code> : Clear all access history associated with a frame. This method should be called only when a page is deleted in the <code>BufferPoolManager</code>.</li>
<li><code>SetEvictable(frame_id_t frame_id, bool set_evictable)</code> : This method controls whether a frame is evictable or not. It also controls <code>LRUKReplacer</code>&rsquo;s size. You&rsquo;ll know when to call this function when you implement the <code>BufferPoolManager</code>. To be specific, when pin count of a page reaches 0, its corresponding frame is marked evictable and replacer&rsquo;s size is incremented.</li>
<li><code>Size()</code> : This method returns the number of evictable frames that are currently in the <code>LRUKReplacer</code>.</li>
</ul>
<p>The implementation details are up to you. You are allowed to use built-in STL containers. You may assume that you will not run out of memory, but you must make sure that your implementation is thread-safe.</p>
</blockquote>
<ul>
<li>本文不会考虑thread-safe的问题，主要是为了讲解两种算法的模型</li>
</ul>
<h2 id="内容分析">内容分析</h2>
<ul>
<li>这个实验的主要内容是为了实现一个<code>BUFFER POOL</code>，用于将存储数据的页暂时存储在内存中，但是一台机器的内容始终都是有限的，一旦到达阈值，我们就要踢出去一些页（从内容中移除，刷到磁盘上面去），那么怎么踢呢？本实验提供给我们的算法是LRU-K算法</li>
</ul>
<h2 id="lru">LRU</h2>
<ul>
<li>
<p>学过OS/计算机组成的朋友一定对这个算法不陌生，以往对于cache中数据的处理中LRU就是常用的一个手法，但是我们该如何实现呢？这也就是<a href="https://leetcode.cn/problems/lru-cache/description/" target="_blank" rel="noopener noreffer">leetcode-146</a>，首先选取数据结构上的模型</p>
</li>
<li>
<p>首先存储数据标准或者整个数据的数据结构肯定是一个列表，但是这个列表我们是选数组还是链表呢？<u>在LRU算法中，常常会发生的事情是之前用的数据在没有被踢出cache之前会再次被使用，而且我们踢数据通常就是在列表的末尾踢掉的，如果这个数据再次被使用，应该将其移动到列表头部</u>，那对于移动数据均摊下来时间复杂度是$O(n)$的数组近乎是一场效率上的灾难，所以这个时候删除和插入数据的时间复杂度仅有$O(1)$的链表就成了首选</p>
</li>
<li>
<p>但是我们选了链表之后又有一个问题，对于get(key) -&gt; value这样的操作，时间复杂度会升高到$O(n)$，我们还是不能容忍这样的效率，所以我们可以再用一部分空间来换取时间：加上一张&lt;key, pointer of node&gt;的哈希表，这样通过key可以直接定位到链表中的节点，时间复杂度就降到了O(1)</p>
</li>
<li>
<p>C++库的选取：因为15445要用C++，所以本题也为C++实现，这里面会遇到一个选择：list是使用STL提供好的还是手搓？我先使用的STL中的list，然后哈希表中的value存储的是list的迭代器，但是这样会出现一个隐式的bug：STL的list存在迭代器失效问题，而这个东西又是在一定条件下出现的，很难预测，所以这里手搓了一个双向链表，哈希表中的value直接换成链表中node的地址就可以了</p>
</li>
</ul>
<h2 id="lc-146实现">lc-146实现</h2>
<ul>
<li>节点node</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#pragma once
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">selfDS</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="p">,</span> <span class="k">typename</span> <span class="n">V</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">_doubleLinkedListNode</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">K</span> <span class="n">key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">V</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">_doubleLinkedListNode</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">_doubleLinkedListNode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">_doubleLinkedListNode</span><span class="p">()</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="nf">_doubleLinkedListNode</span><span class="p">(</span><span class="n">K</span> <span class="n">key</span><span class="p">,</span> <span class="n">V</span> <span class="n">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="o">:</span> <span class="n">key</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">value</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="n">prev</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span> <span class="n">next</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="nf">getKey</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="k">const</span> <span class="n">K</span> <span class="o">&amp;</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="nf">getValue</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="k">const</span> <span class="n">V</span> <span class="o">&amp;</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="nf">setValue</span><span class="p">(</span><span class="k">const</span> <span class="n">V</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">{</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="nf">remove</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="nf">addAfter</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span> <span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="k">const</span> <span class="n">V</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="o">*</span><span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">_doubleLinkedListNode</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">newNode</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">newNode</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="nf">addAfter</span><span class="p">(</span><span class="n">_doubleLinkedListNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">node</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="nf">getNext</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">_doubleLinkedListNode</span> <span class="o">*</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="nf">setNext</span><span class="p">(</span><span class="n">_doubleLinkedListNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">{</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="nf">getPrev</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">_doubleLinkedListNode</span> <span class="o">*</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="nf">setPrev</span><span class="p">(</span><span class="n">_doubleLinkedListNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">{</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">_doubleLinkedListNode</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>  <span class="c1">// namespace selfDS
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>LRU模板实现</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#pragma once
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// k-v store, by LRU algorithm
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;cstddef&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;optional&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;doubleLinkedlistNode.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="p">,</span> <span class="k">typename</span> <span class="n">V</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">LRU</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">selfDS</span><span class="o">::</span><span class="n">_doubleLinkedListNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">_head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">selfDS</span><span class="o">::</span><span class="n">_doubleLinkedListNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">_tail</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">capacity</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">length</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">selfDS</span><span class="o">::</span><span class="n">_doubleLinkedListNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="o">*&gt;</span> <span class="n">_map</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="n">LRU</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">capacity</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="o">:</span> <span class="n">capacity</span><span class="p">(</span><span class="n">capacity</span><span class="p">),</span> <span class="n">length</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">_map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">selfDS</span><span class="o">::</span><span class="n">_doubleLinkedListNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="o">*&gt;</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="o">-&gt;</span><span class="n">_head</span> <span class="o">=</span> <span class="k">new</span> <span class="n">selfDS</span><span class="o">::</span><span class="n">_doubleLinkedListNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="n">K</span><span class="p">(),</span> <span class="n">V</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="o">-&gt;</span><span class="n">_tail</span> <span class="o">=</span> <span class="k">new</span> <span class="n">selfDS</span><span class="o">::</span><span class="n">_doubleLinkedListNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="n">K</span><span class="p">(),</span> <span class="n">V</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="o">-&gt;</span><span class="n">_head</span><span class="o">-&gt;</span><span class="n">setNext</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_tail</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="o">-&gt;</span><span class="n">_tail</span><span class="o">-&gt;</span><span class="n">setPrev</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_head</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="na">[[nodiscard]]</span> <span class="k">auto</span> <span class="n">get</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_map</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">selfDS</span><span class="o">::</span><span class="n">_doubleLinkedListNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">pointer</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_map</span><span class="p">[</span><span class="n">key</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">      <span class="n">pointer</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="k">this</span><span class="o">-&gt;</span><span class="n">_head</span><span class="o">-&gt;</span><span class="n">addAfter</span><span class="p">(</span><span class="n">pointer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="p">(</span><span class="n">pointer</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="nf">put</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="k">const</span> <span class="n">V</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_map</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">selfDS</span><span class="o">::</span><span class="n">_doubleLinkedListNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">pointer</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_map</span><span class="p">[</span><span class="n">key</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">      <span class="n">pointer</span><span class="o">-&gt;</span><span class="n">setValue</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">pointer</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="k">this</span><span class="o">-&gt;</span><span class="n">_head</span><span class="o">-&gt;</span><span class="n">addAfter</span><span class="p">(</span><span class="n">pointer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">==</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">selfDS</span><span class="o">::</span><span class="n">_doubleLinkedListNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">pointer</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_tail</span><span class="o">-&gt;</span><span class="n">getPrev</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">pointer</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">-&gt;</span><span class="n">_map</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">pointer</span><span class="o">-&gt;</span><span class="n">getKey</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="k">delete</span> <span class="n">pointer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">this</span><span class="o">-&gt;</span><span class="n">_head</span><span class="o">-&gt;</span><span class="n">addAfter</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">this</span><span class="o">-&gt;</span><span class="n">_map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_head</span><span class="o">-&gt;</span><span class="n">getNext</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="k">this</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">LRU</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">selfDS</span><span class="o">::</span><span class="n">_doubleLinkedListNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_head</span><span class="o">-&gt;</span><span class="n">getNext</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_tail</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">selfDS</span><span class="o">::</span><span class="n">_doubleLinkedListNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">temp</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">getNext</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="k">delete</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">x</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">delete</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">delete</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_tail</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>题解直接将模板实例化就可以了</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">LRUCache</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">LRU</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">lru</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="n">LRUCache</span><span class="p">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="p">)</span> <span class="o">:</span> <span class="n">lru</span><span class="p">(</span><span class="n">capacity</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="nf">get</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">).</span><span class="n">value_or</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">put</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="lru-k">LRU-K</h2>
<ul>
<li>
<p>从上文看，LRU算法对于cache数据的管理已经很好了，但是这里面为什么又要引入LRU-K算法呢？</p>
</li>
<li>
<p>LRU算法存在的问题是，当存在大量的一次性操作时，会把历史的缓存冲刷掉，而新进入cache的数据有可能之后不会再访问了，被冲刷掉的数据是之前保留下来的比较“有用”的数据，这就是<strong>缓存污染</strong>问题</p>
</li>
<li>
<p>LRU-K的思路是，永远最先驱逐访问次数小于K次的page。网上的很多讲解是直接维护两个链表，一个叫做history list，另一个叫buffer list。新加入的数据总会先进入history list，当访问次数等于指定的次数K次时，就会从history list删除，并移动到buffer list的头部</p>
</li>
<li>
<p>Buffer list服从LRU算法，History List可以服从任意替换算法，在实验手册中，要求驱逐最早进入history list的page，采用的是FIFO策略</p>
</li>
<li>
<p>以上就是LRU和LRU-K算法的解释</p>
</li>
</ul>
<h2 id="补充">补充</h2>
<ul>
<li>由于该版的实验<strong>page中有是否可以移除的标志位</strong>，如果为false表明该页无法被移除，所以说移除page的算法需要在原有的LRU-K算法的基础上面改进，按照优先级别先从History List的头向后扫描，如果有可以移除的page就直接移除，如果说History List中的页都无法移除，那么就需要从Buffer List的尾部向前扫描，发现可以移除的page就直接移除</li>
<li>这种情况的改变将删除操作的时间复杂度从$O(1)$上升到了$O(n)$，但是因为理想的模型和实际并不相符，实际中有一些page就是规定不应该被移除，所以为了和实际相符只能损失一小部分效率（毕竟主存和磁盘的容量比很小）</li>
</ul>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #01: Course Overview &amp; Relational Model</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter1/</link>
    <pubDate>Wed, 22 Feb 2023 15:23:14 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter1/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-01-course-overview--relational-model">Lecture #01: Course Overview &amp; Relational Model</h2>
<h3 id="outline">Outline</h3>
<ul>
<li>Course Logistics</li>
<li>Relational Model</li>
<li>Relational Algebra</li>
</ul>
<h3 id="course-overiew">Course overiew</h3>
<ul>
<li>This course is about the design/implementation of database management systems (<code>DBMSs</code>)</li>
<li>This is <strong>not</strong> a course ($\rightarrow Key\ point\ is\ the\ theory\ and\ the\ concept$) about how to use a DBMS to build applications or how to administer a DBMS.→ See <a href="http://www.heinz.cmu.edu/academic-resources/course-results/course-details/index.aspx?cid=273" target="_blank" rel="noopener noreffer">CMU 95-703</a> (Heinz College)</li>
</ul>
<h3 id="projects">PROJECTS</h3>
<ul>
<li>
<p>All projects will use the CMU DB Group <a href="https://github.com/cmu-db/bustub" target="_blank" rel="noopener noreffer">BusTub</a> academic DBMS.</p>
<ul>
<li>→ Each project builds on the previous one.</li>
<li>→ We will not teach you how to write/debug C++17</li>
</ul>
</li>
<li>
<p><strong>complete <a href="https://15445.courses.cs.cmu.edu/fall2022/project0/" target="_blank" rel="noopener noreffer">Project #0</a> ! ! !</strong></p>
</li>
</ul>
<h3 id="database">Database</h3>
<ul>
<li>
<p><strong>Organized collection of inter-related data that models some aspect of the real-world</strong></p>
</li>
<li>
<p><strong>Databases are the core component of most computer applications</strong></p>
</li>
</ul>
<h4 id="example">Example</h4>
<p>Create a database that models a digital music store to keep track of artists and albums</p>
<ul>
<li>Things we need for our store
<ul>
<li>Information about <code>Artists</code></li>
<li>What <code>Albums</code> those Artists released</li>
</ul>
</li>
</ul>
<h5 id="flat-file-strawman">FLAT FILE STRAWMAN</h5>
<ul>
<li>
<p>Store our database as <strong>comma-separated value (CSV)</strong> files that we manage ourselves in our application code</p>
<ul>
<li>
<p>Use a separate file per entity</p>
</li>
<li>
<p>The application must parse the files each time they want to read/update records</p>
</li>
</ul>
</li>
<li>
<p>Create a database that models a digital music store</p>
</li>
</ul>
<p>Artist(name, year, country)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="s2">&#34;Wu-Tang Clan&#34;</span><span class="err">,</span><span class="mi">1992</span><span class="err">,</span><span class="s2">&#34;USA&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s2">&#34;Notorious BIG&#34;</span><span class="err">,</span><span class="mi">1992</span><span class="err">,</span><span class="s2">&#34;USA&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s2">&#34;GZA&#34;</span><span class="err">,</span><span class="mi">1990</span><span class="err">,</span><span class="s2">&#34;USA&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Album(name, artist, year)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="s2">&#34;Enter the Wu-Tang&#34;</span><span class="err">,</span><span class="s2">&#34;Wu-Tang Clan&#34;</span><span class="err">,</span><span class="mi">1993</span>
</span></span><span class="line"><span class="cl"><span class="s2">&#34;St.Ides Mix Tape&#34;</span><span class="err">,</span><span class="s2">&#34;Wu-Tang Clan&#34;</span><span class="err">,</span><span class="mi">1994</span>
</span></span><span class="line"><span class="cl"><span class="s2">&#34;Liquid Swords&#34;</span><span class="err">,</span><span class="s2">&#34;GZA&#34;</span><span class="err">,</span><span class="mi">1990</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="our-code">Our Code</h5>
<ul>
<li>Example: Get the year that GZA went solo $\rightarrow$ Artist</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file</span><span class="o">.</span><span class="n">readlines</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">	<span class="n">record</span> <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="n">record</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&#34;GZA&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nb">print</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">record</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="problem-about-flat-files-rightarrow-data-integrity">Problem about FLAT FILES $\rightarrow$ DATA-INTEGRITY</h4>
<ul>
<li>
<p>How do we ensure that the artist is the same for each album entry?</p>
</li>
<li>
<p>What if somebody overwrites the album year with an invalid string?</p>
</li>
<li>
<p>What if there are multiple artists on an album?</p>
</li>
<li>
<p>What happens if we delete an artist that has albums?</p>
</li>
</ul>
<h4 id="problem-about-flat-files-rightarrow-implementation">Problem about FLAT FILES $\rightarrow$ IMPLEMENTATION</h4>
<ul>
<li>
<p>How do you find a particular record?</p>
</li>
<li>
<p>What if we now want to create a new application that uses the same database?</p>
</li>
<li>
<p>What if two threads try to write to the same file at the same time?</p>
</li>
</ul>
<h4 id="problem-about-flat-files-rightarrow-durability">Problem about FLAT FILES $\rightarrow$ DURABILITY</h4>
<ul>
<li>
<p>What if the machine crashes while our program is updating a record?</p>
</li>
<li>
<p>What if we want to replicate the database on multiple machines for high availability?</p>
</li>
</ul>
<h3 id="database-management-system">DATABASE MANAGEMENT SYSTEM</h3>
<ul>
<li>
<p>A <u>database management system</u> (<strong>DBMS</strong>) is software that allows applications to <strong>store and analyze information in a database</strong></p>
</li>
<li>
<p>A general-purpose DBMS supports the <u>definition, creation, querying, update, and administration of databases</u> in accordance with some <u>data model</u></p>
</li>
</ul>
<h4 id="early-dbmss">EARLY DBMSs</h4>
<blockquote>
<p>Early database applications were difficult to build and maintain on available DBMSs in the 1960s</p>
<blockquote>
<p>Examples: IDS, IMS, CODASYL</p>
<p>Computers were expensive, humans were cheap😂</p>
</blockquote>
</blockquote>
<ul>
<li><u>Tight coupling</u> between <strong>logical</strong> and <strong>physical</strong> layers</li>
<li>Programmers had to (roughly) know what queries the application would execute before they could deploy the database😟</li>
</ul>
<blockquote>
<p><strong>Ted Codd</strong> was a <u>mathematician</u> working at IBM Research in the late 1960s</p>
<p>He saw IBM&rsquo;s developers spending their time <strong>rewriting database programs</strong> every time <u>the database’s schema or layout changed</u>😨</p>
<p>Devised the <strong>relational model</strong> in 1969</p>
</blockquote>
<h3 id="relational-model">RELATIONAL MODEL</h3>
<ul>
<li>
<p>The relational model defines a database abstraction based on relations to avoid maintenance overhead</p>
</li>
<li>
<p>Key tenets</p>
<ul>
<li>Store database in simple data structures (relations)</li>
<li>Physical storage left up to the DBMS implementation</li>
<li>Access data through high-level language, DBMS figures out best execution strategy</li>
</ul>
</li>
<li>
<p><strong>Structure:</strong> The definition of the database&rsquo;s relations and their contents</p>
</li>
<li>
<p><strong>Integrity:</strong> Ensure the database&rsquo;s contents satisfy constraints</p>
</li>
<li>
<p><strong>Manipulation:</strong> Programming interface for accessing and modifying a database&rsquo;s contents</p>
</li>
</ul>
<hr>
<ul>
<li>A <u>relation</u> is an unordered set that contain the relationship of attributes that represent entities</li>
<li>A <u>tuple</u> is a set of attribute values (also known as its <u>domain</u>) in the relation
<ul>
<li>Values are (normally) atomic/scalar</li>
<li>The special value <strong>NULL</strong> is a member of every domain (if allowed)</li>
</ul>
</li>
</ul>
<p>Artist(name, year, country)</p>
<table>
<thead>
<tr>
<th>name</th>
<th>year</th>
<th>country</th>
</tr>
</thead>
<tbody>
<tr>
<td>Wu-Tang Clan</td>
<td>1992</td>
<td>USA</td>
</tr>
<tr>
<td>Notorious BIG</td>
<td>1992</td>
<td>USA</td>
</tr>
<tr>
<td>GZA</td>
<td>1990</td>
<td>USA</td>
</tr>
</tbody>
</table>
<p>$$
n-ary\ Relation=Table\ with\ n\ columns\newline
$$</p>
<h4 id="relational-model-primary-keys">RELATIONAL MODEL: PRIMARY KEYS</h4>
<ul>
<li>A relation&rsquo;s <u>primary key</u> <strong>uniquely</strong> identifies a single tuple</li>
<li>Some <code>DBMSs</code> automatically create an internal primary key if a table does not define one</li>
<li>Auto-generation of unique integer primary keys
<ul>
<li>→ <strong>SEQUENCE</strong> (SQL:2003)</li>
<li>→ <strong>AUTO_INCREMENT</strong> (MySQL)</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>year</th>
<th>country</th>
</tr>
</thead>
<tbody>
<tr>
<td>123</td>
<td>Wu-Tang Clan</td>
<td>1992</td>
<td>USA</td>
</tr>
<tr>
<td>456</td>
<td>Notorious BIG</td>
<td>1992</td>
<td>USA</td>
</tr>
<tr>
<td>789</td>
<td>GZA</td>
<td>1990</td>
<td>USA</td>
</tr>
</tbody>
</table>
<h4 id="relational-model-foreign-keys">RELATIONAL MODEL: FOREIGN KEYS</h4>
<ul>
<li>A <u>foreign key</u> specifies that an attribute <strong>from one relation</strong> has to <strong>map to a tuple in another relation</strong></li>
</ul>
<a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter1-1.png" title="/img/CMU 15-445 Database Systems/chapter1-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter1-1.png">
        
    </a>
<h3 id="data-models">DATA MODELS</h3>
<ul>
<li>
<p>A <u>data model</u> is a collection of concepts for describing the data in a database</p>
</li>
<li>
<p>A <u>schema</u> is a description of a particular collection of data, <u>using a given data model</u></p>
</li>
</ul>
<hr>
<ul>
<li>
<p>Example</p>
<ul>
<li>
<p><strong>Relational</strong> $\leftarrow This\ Course\newline$</p>
</li>
<li>
<p>Key/Value</p>
</li>
<li>
<p>Graph</p>
</li>
<li>
<p>Document / Object</p>
</li>
<li>
<p>Wide-Column / Column-family</p>
</li>
<li>
<p>Array / Matrix / Vectors</p>
</li>
<li>
<p>Hierarchical</p>
</li>
<li>
<p>Network</p>
</li>
<li>
<p>Multi-Value</p>
</li>
</ul>
</li>
</ul>
<h3 id="data-manipulation-languages-dml">DATA MANIPULATION LANGUAGES (DML)</h3>
<ul>
<li>
<p>Methods to store and retrieve information from a database</p>
</li>
<li>
<p><strong>Procedural:</strong></p>
<ul>
<li>→ The query specifies the (high-level) strategy to find the desired result based on sets / bags $\leftarrow Relational\ Algebra\newline$</li>
</ul>
</li>
<li>
<p><strong>Non-Procedural (Declarative):</strong></p>
<ul>
<li>→ The query specifies only what data is wanted and not how to find it. $\leftarrow Relational\ Calculus\newline$</li>
</ul>
</li>
</ul>
<h3 id="relational-algebra">RELATIONAL ALGEBRA</h3>
<ul>
<li>
<p>Fundamental operations to retrieve and manipulate tuples in a relation</p>
<ul>
<li>→ Based on set algebra</li>
</ul>
</li>
<li>
<p>Each operator takes one or more relations as its inputs and outputs a new relation</p>
<ul>
<li>→ We can &ldquo;chain&rdquo; operators together to create more complex operations</li>
</ul>
</li>
</ul>
<p>$$
\begin{align}
&amp;\sigma\Longrightarrow Select\newline
&amp;\prod\Longrightarrow Projection\newline
&amp;\cup\Longrightarrow Union\newline
&amp;\cap\Longrightarrow Intersection\newline
&amp;-\Longrightarrow Difference\newline
&amp;\times\Longrightarrow Product\newline
&amp;\bowtie\Longrightarrow Join\newline
\end{align}
$$</p>
<h4 id="select">SELECT</h4>
<ul>
<li>
<p>Choose a subset of the tuples from a relation that satisfies a selection predicate</p>
<ul>
<li>
<p>Predicate acts as a filter to retain only tuples that fulfill its qualifying requirement</p>
</li>
<li>
<p>Can combine multiple predicates using conjunctions / disjunctions</p>
</li>
</ul>
</li>
</ul>
<p>$$
Syntax:\sigma_{predicate}(R)
$$</p>
<a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter1-2.png" title="/img/CMU 15-445 Database Systems/chapter1-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter1-2.png">
        
    </a>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">R</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="k">WHERE</span><span class="w"> </span><span class="n">a_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;a2&#39;</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">b_id</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">102</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="projection">PROJECTION</h4>
<ul>
<li>
<p>Generate a relation with tuples that contains only the specified attributes</p>
<ul>
<li>
<p>Can rearrange attributes’ ordering</p>
</li>
<li>
<p>Can manipulate the values</p>
</li>
</ul>
</li>
</ul>
<p>$$
Syntax:\prod_{A_1, A_2, &hellip;A_n}(R)
$$</p>
<a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter1-3.png" title="/img/CMU 15-445 Database Systems/chapter1-3.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter1-3.png">
        
    </a>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="n">b_id</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="n">a_id</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="k">FROM</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">a_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;a2&#39;</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="union">UNION</h4>
<ul>
<li>Generate a relation that contains all tuples that <strong>appear in either only one or both input relations</strong></li>
</ul>
<p>$$
Syntax:(R\cup S)
$$</p>
<a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter1-4.png" title="/img/CMU 15-445 Database Systems/chapter1-4.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter1-4.png">
        
    </a>
<a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter1-5.png" title="/img/CMU 15-445 Database Systems/chapter1-5.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter1-5.png">
        
    </a>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">R</span><span class="p">)</span><span class="w"> </span><span class="k">UNION</span><span class="w"> </span><span class="k">ALL</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">S</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="intersection">INTERSECTION</h4>
<ul>
<li>Generate a relation that contains only the tuples that <strong>appear in both of the input relations</strong></li>
</ul>
<p>$$
Syntax:(R\cap S)
$$</p>
<a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter1-6.png" title="/img/CMU 15-445 Database Systems/chapter1-6.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter1-6.png">
        
    </a>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">R</span><span class="p">)</span><span class="w"> </span><span class="k">INTERSECT</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">S</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="difference">DIFFERENCE</h4>
<ul>
<li>Generate a relation that contains only the tuples that appear in the first and not the second of the input relations</li>
</ul>
<p>$$
Syntax:(R-S)
$$</p>
<a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter1-7.png" title="/img/CMU 15-445 Database Systems/chapter1-7.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter1-7.png">
        
    </a>
<a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter1-8.png" title="/img/CMU 15-445 Database Systems/chapter1-8.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter1-8.png">
        
    </a>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">R</span><span class="p">)</span><span class="w"> </span><span class="k">EXCEPT</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">S</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="product">PRODUCT</h4>
<ul>
<li>Generate a relation that contains all possible combinations of tuples from the input relations(<code>combination</code>)</li>
</ul>
<p>$$
Syntax:(R\times S)
$$</p>
<a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter1-9.png" title="/img/CMU 15-445 Database Systems/chapter1-9.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter1-9.png">
        
    </a>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="k">CROSS</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">S</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">R</span><span class="p">,</span><span class="w"> </span><span class="n">S</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="join-">JOIN !</h4>
<ul>
<li>Generate a relation that contains all tuples that are a combination of two tuples (one from each input relation) with a common value(s) for one or more attributes</li>
</ul>
<p>$$
Syntax:(R\bowtie S)
$$</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="k">NATURAL</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">S</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>R</li>
</ul>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>1</td>
</tr>
<tr>
<td>b</td>
<td>2</td>
</tr>
</tbody>
</table>
<ul>
<li>S</li>
</ul>
<table>
<thead>
<tr>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>x</td>
</tr>
<tr>
<td>1</td>
<td>y</td>
</tr>
<tr>
<td>3</td>
<td>z</td>
</tr>
</tbody>
</table>
<ul>
<li>$R\bowtie S$</li>
</ul>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>1</td>
<td>x</td>
</tr>
<tr>
<td>a</td>
<td>1</td>
<td>y</td>
</tr>
</tbody>
</table>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="k">USING</span><span class="w"> </span><span class="p">(</span><span class="n">a_id</span><span class="p">,</span><span class="w"> </span><span class="n">b_id</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter1-10.png" title="/img/CMU 15-445 Database Systems/chapter1-10.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter1-10.png">
        
    </a>
<h4 id="extra-operators">EXTRA OPERATORS</h4>
<ul>
<li>
<p>Rename($\rho$)</p>
</li>
<li>
<p>Assignment($R \leftarrow S$)</p>
</li>
<li>
<p>Duplicate Elimination($\delta$)</p>
</li>
<li>
<p>Aggregation($\gamma$)</p>
</li>
<li>
<p>Sorting($\tau$)</p>
</li>
<li>
<p>Division($R\div S$)</p>
</li>
</ul>
<h4 id="observation">OBSERVATION</h4>
<blockquote>
<p>Relational algebra is a procedural language because it defines the high level-steps of how to compute a query. For example, $\sigma_{b_id=102}(R\bowtie S)$ is saying to first do the join of R and S and then do the select,whereas $(R \bowtie (\sigma_{b_id=102}(S)))$ will do the select on S first, and then do the join. These two statements will actually produce the same answer, but if there is only 1 tuple in S with b_id=102 out of a billion tuples, then$(R \bowtie (\sigma_{b_id=102}(S)))$ will be significantly faster than $\sigma_{b_id=102}(R\bowtie S)$😂</p>
</blockquote>
<blockquote>
<p>A better approach is to say the result you want (state $\rightarrow$<u>retrieve the joined tuples from R and S where b_id equals 102</u>), and let the DBMS decide the steps it wants to take to compute the query. SQL will do exactly this,and it is the de facto standard for writing queries on relational model databases🐮</p>
</blockquote>
<h4 id="queries">QUERIES</h4>
<ul>
<li>
<p>The relational model is independent of any query language implementation.</p>
</li>
<li>
<p><strong>SQL</strong> is the <em>de facto</em> standard (many dialects)</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file</span><span class="o">.</span><span class="n">readlines</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">	<span class="n">record</span> <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="n">record</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&#34;GZA&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nb">print</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">record</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="k">year</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">artists</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="k">WHERE</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;GZA&#39;</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="document-data-model">DOCUMENT DATA MODEL</h3>
<ul>
<li>Embed data hierarchy into a single object❌</li>
</ul>
<a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter1-11.png" title="/img/CMU 15-445 Database Systems/chapter1-11.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter1-11.png">
        
    </a>
<div class="mermaid" id="id-1"></div>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Artist</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">year</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Album</span> <span class="n">albums</span><span class="o">[];</span>
</span></span><span class="line"><span class="cl"><span class="o">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Album</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">year</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>$$
\Downarrow
$$</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;GZA&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;year&#34;</span><span class="p">:</span> <span class="mi">1990</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;albums&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Liquid Swords&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;year&#34;</span><span class="p">:</span> <span class="mi">1995</span>
</span></span><span class="line"><span class="cl">        <span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Beneath the Surface&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;year&#34;</span><span class="p">:</span> <span class="mi">1999</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="conclusion">CONCLUSION</h3>
<ul>
<li>
<p>Databases are ubiquitous</p>
</li>
<li>
<p>Relational algebra defines the primitives for processing queries on a relational database.</p>
</li>
<li>
<p>We will see relational algebra again when we talk about query optimization + execution</p>
</li>
</ul>
]]></description>
</item>
</channel>
</rss>
