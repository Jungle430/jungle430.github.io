<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Jungle&#39;s Blog</title>
        <link>https://Jungle430.github.io/</link>
        <description>Welcome to Jungle&#39;s blog.</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>junglece430@gmail.com (Jungle)</managingEditor>
            <webMaster>junglece430@gmail.com (Jungle)</webMaster><lastBuildDate>Sun, 21 Apr 2024 10:39:27 &#43;0800</lastBuildDate>
            <atom:link href="https://Jungle430.github.io/index.xml" rel="self" type="application/rss+xml" />
        <item>
    <title>CMU 15-445 Lecture #19: Multi-Version Concurrency Control</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter19/</link>
    <pubDate>Sun, 21 Apr 2024 10:39:27 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter19/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-19-multi-version-concurrency-control">Lecture #19: Multi-Version Concurrency Control</h2>
<h3 id="multi-version-concurrency-control">Multi-Version Concurrency Control</h3>
<ul>
<li>
<p>常常作为2PL和T/O的辅助手段</p>
</li>
<li>
<p>The DBMS maintains multiple physical versions of a single logical object in the database（维护多个历史版本（像git））</p>
<ul>
<li>
<p>When a txn writes to an object, the DBMS creates a new version of that object. 不改动，直接创建一个新的版本</p>
</li>
<li>
<p>When a txn reads an object, it reads the newest version that existed when the txn started.</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>First implementations was Rdb/VMS and InterBase at DEC in early 1980s.</p>
<p>→ Both were by Jim Starkey, co-founder of NuoDB.</p>
<p>→ DEC Rdb/VMS is now “Oracle Rdb”.</p>
<p>→ InterBase was open-sourced as Firebird.</p>
</blockquote>
<ul>
<li>
<p>解决的问题</p>
<ul>
<li>Writers do not block readers.</li>
<li>Readers do not block writers.</li>
<li>我去上面读历史版本就是了</li>
</ul>
</li>
<li>
<p>Read-only txns can read a consistent snapshot without acquiring locks. 好像在读静态数据</p>
<ul>
<li>Use timestamps to determine visibility.用时间戳来确定可见性</li>
<li>MVCC naturally supports Snapshot Isolation (SI).天然支持快照隔离读</li>
</ul>
</li>
<li>
<p>Easily support time-travel queries.可以读取某一个时刻的历史版本，和IDE退到昨天的代码很像（其他方案很难做到，会把历史数据直接给写没）</p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter19-1.png" title="/img/CMU 15-445 Database Systems/chapter19-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter19-1.png" data-sub-html="<h2>MVCC 写</h2>">
        
    </a><figcaption class="image-caption">MVCC 写</figcaption>
    </figure>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter19-2.png" title="/img/CMU 15-445 Database Systems/chapter19-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter19-2.png" data-sub-html="<h2>MVCC 读</h2>">
        
    </a><figcaption class="image-caption">MVCC 读</figcaption>
    </figure>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter19-3.png" title="/img/CMU 15-445 Database Systems/chapter19-3.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter19-3.png" data-sub-html="<h2>防止级联回滚，只读最新的commit数据</h2>">
        
    </a><figcaption class="image-caption">防止级联回滚，只读最新的commit数据</figcaption>
    </figure>
<ul>
<li>从上面的一张图可以看到T1和T2没法做到完全串行化，T2没有读到T1commit上去的数据，所以说只靠MVCC做不到完全串行化，Oracle最高隔离级别就是上面的图，快照隔离</li>
</ul>
<hr>
<ul>
<li>There are five important MVCC design considerations:
<ol>
<li>Concurrency Control Protocol</li>
<li>Version Storage</li>
<li>Garbage Collection</li>
<li>Index Management</li>
<li>Deletes</li>
</ol>
</li>
</ul>
<hr>
<ul>
<li><strong>Concurrency Control Protocol</strong>
<ul>
<li><strong>Approach #1: Timestamp Ordering</strong>: Assign txns timestamps that determine serial order.</li>
<li><strong>Approach #2: Optimistic Concurrency Control</strong>: Three-phase protocol from last class,Use private workspace for new versions.</li>
<li><strong>Approach #3: Two-Phase Locking</strong>: Txns acquire appropriate lock on physical version before they can read/write a logical tuple.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="design-consideration-version-storage">Design consideration: Version Storage</h3>
<ul>
<li><strong>Version Storage</strong>
<ul>
<li>
<p>The DBMS uses the tuples’ pointer field to create a version chain per logical tuple</p>
<ul>
<li>This allows the DBMS to find the version that is visible to a particular txn at runtime.</li>
<li>Indexes always point to the “head” of the chain.</li>
</ul>
</li>
<li>
<p><strong>Approach #1: Append-Only Storage</strong>: New versions are appended to the same table space.</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter19-4.png" title="/img/CMU 15-445 Database Systems/chapter19-4.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter19-4.png" data-sub-html="<h2>Append-Only Storage</h2>">
        
    </a><figcaption class="image-caption">Append-Only Storage</figcaption>
    </figure>
<ul>
<li>两种插法：头插法和尾插法，头插法搜索效率高（大部分txn要最新的数据）</li>
</ul>
</li>
<li>
<p><strong>Approach #2: Time-Travel Storage</strong>: Old versions are copied to separate table space.</p>
<ul>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter19-5.png" title="/img/CMU 15-445 Database Systems/chapter19-5.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter19-5.png" data-sub-html="<h2>Time-Travel Storage</h2>">
        
    </a><figcaption class="image-caption">Time-Travel Storage</figcaption>
    </figure></li>
</ul>
</li>
<li>
<p><strong>Approach #3: Delta Storage</strong>: The original values of the modified attributes are copied into a separate delta record space.</p>
<ul>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter19-6.png" title="/img/CMU 15-445 Database Systems/chapter19-6.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter19-6.png" data-sub-html="<h2>Delta Storage就是Time-Travel Storage的省空间版本，只存增量</h2>">
        
    </a><figcaption class="image-caption">Delta Storage就是Time-Travel Storage的省空间版本，只存增量</figcaption>
    </figure></li>
<li>MySQL用的就是这个方案</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="design-consideration-garbage-collection">Design consideration: Garbage Collection</h3>
<ul>
<li>
<p><strong>Garbage Collection</strong></p>
<ul>
<li>
<p>历史版本不能一直存着（那样存储空间就会被严重浪费），所以需要定期回收无用的历史版本</p>
</li>
<li>
<p>怎么判断无用？</p>
<ul>
<li>现在运行的事务都看不到这个版本了(Snapshot Isolation)</li>
<li>创建这个版本的事务回滚了</li>
</ul>
</li>
<li>
<p>两个问题</p>
<ul>
<li>怎么发现过期的版本?</li>
<li>决定何时回收才能保证内存安全?</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Approach #1: Tuple-level</strong></p>
<ul>
<li>
<p>Find old versions by examining tuples directly.</p>
</li>
<li>
<p>Background Vacuuming vs. Cooperative Cleaning</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter19-8.png" title="/img/CMU 15-445 Database Systems/chapter19-8.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter19-8.png" data-sub-html="<h2>Background Vacuuming:后台清理</h2>">
        
    </a><figcaption class="image-caption">Background Vacuuming:后台清理</figcaption>
    </figure>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter19-9.png" title="/img/CMU 15-445 Database Systems/chapter19-9.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter19-9.png" data-sub-html="<h2>用位图表面那些页被更新过，只扫被更新过的页，这样可以减少GC的压力</h2>">
        
    </a><figcaption class="image-caption">用位图表面那些页被更新过，只扫被更新过的页，这样可以减少GC的压力</figcaption>
    </figure>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter19-10.png" title="/img/CMU 15-445 Database Systems/chapter19-10.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter19-10.png" data-sub-html="<h2>Cooperative Cleaning:查询的时候顺便清理</h2>">
        
    </a><figcaption class="image-caption">Cooperative Cleaning:查询的时候顺便清理</figcaption>
    </figure>
</li>
</ul>
</li>
<li>
<p><strong>Approach #2: Transaction-level</strong></p>
<ul>
<li>Txns keep track of their old versions so the DBMS does not have to scan tuples to determine visibility</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter19-11.png" title="/img/CMU 15-445 Database Systems/chapter19-11.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter19-11.png" data-sub-html="<h2>事务记录自己改了什么，GC定时间戳去扫描事务的操作记录然后清理无用数据</h2>">
        
    </a><figcaption class="image-caption">事务记录自己改了什么，GC定时间戳去扫描事务的操作记录然后清理无用数据</figcaption>
    </figure></li>
</ul>
</li>
</ul>
<h3 id="design-consideration-index-management">Design consideration: Index Management</h3>
<ul>
<li>
<p>Primary key indexes point to version chain head</p>
</li>
<li>
<p>修改主键=先删除后插入</p>
</li>
<li>
<p>Secondary indexes</p>
<ul>
<li>
<p><strong>Approach #1: Logical Pointers:</strong> 记录数据的逻辑地址，比如主键的值</p>
</li>
<li>
<p><strong>Approach #2: Physical Pointers:</strong> 记录物理地址</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter19-12.png" title="/img/CMU 15-445 Database Systems/chapter19-12.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter19-12.png" data-sub-html="<h2>指向物理地址带来的一个严重的后果是如果版本链需要更新，那么一大批二级索引指向版本链的pointer也要更新</h2>">
        
    </a><figcaption class="image-caption">指向物理地址带来的一个严重的后果是如果版本链需要更新，那么一大批二级索引指向版本链的pointer也要更新</figcaption>
    </figure>
</li>
<li>
<p>逻辑地址就没有上面的毛病，只需要改主键索引，辅助索引就不需要变</p>
</li>
<li>
<p>还有一个折中的方案就是在物理地址索引和版本链之间加上一个表做索引到版本链的代理</p>
</li>
</ul>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter19-13.png" title="/img/CMU 15-445 Database Systems/chapter19-13.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter19-13.png" data-sub-html="<h2>删除后再插入也会出现问题</h2>">
        
    </a><figcaption class="image-caption">删除后再插入也会出现问题</figcaption>
    </figure>
</li>
<li>
<p>Delete</p>
<ul>
<li>Approach #1: Deleted Flag: Maintain a flag to indicate that the logical tuple has been deleted after the newest physical version. This can either be in the tuple header or a separate column.</li>
<li>Approach #2: Tombstone Tuple: Create an empty physical version to indicate that a logical tuple is deleted. Use a separate pool for tombstone tuples with only a special bit pattern in version chain pointer to reduce storage overhead.</li>
</ul>
</li>
<li>
<a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter19-14.png" title="/img/CMU 15-445 Database Systems/chapter19-14.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter19-14.png">
        
    </a>
</li>
</ul>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #18: Timestamp Ordering Concurrency Control</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter18/</link>
    <pubDate>Sat, 20 Apr 2024 20:07:38 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter18/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-18-timestamp-ordering-concurrency-control">Lecture #18: Timestamp Ordering Concurrency Control</h2>
<h3 id="timestamp-ordering-concurrency-control">Timestamp Ordering Concurrency Control</h3>
<ul>
<li>
<p>纯用锁很影响性能，锁是一个悲观的方法</p>
</li>
<li>
<p>乐观的方法：用时间戳</p>
</li>
<li>
<p>If $TS(T_i) &lt; TS(T_j)$, then the DBMS must ensure that the execution schedule is equivalent to the serial schedule where $T_i$appears before $T_j$ .</p>
</li>
<li>
<p>Multiple implementation strategies:</p>
<ul>
<li>→ System/Wall Clock.:不可能完全准确，一般不用</li>
<li>→ Logical Counter.:单机系统一般用这个</li>
<li>→ Hybrid.:分布式系统用这个</li>
</ul>
</li>
</ul>
<h3 id="basic-timestamp-ordering-basic-to">Basic Timestamp Ordering (BASIC T/O)</h3>
<ul>
<li>
<p>Every object X is tagged with timestamp of the last txn that successfully did read/write:时间戳也分两种</p>
<ul>
<li>→ W-TS(X) – Write timestamp on X</li>
<li>→ R-TS(X) – Read timestamp on X</li>
</ul>
</li>
<li>
<p>Check timestamps for every operation:</p>
<ul>
<li>→ If txn tries to access an object <strong>“from the future”</strong>, it aborts and restarts.(不能操作“未来”的数据)</li>
</ul>
</li>
<li>
<p><strong>BASIC T/O – READS</strong></p>
<ul>
<li>Don’t read stuff from the “future.”</li>
<li>Action: Transaction Ti wants to read object X.</li>
<li>If TS(Ti) &lt; W-TS(X), this violates the timestamp order of Ti with regard to the writer of X.
<ul>
<li>→ Abort Ti and restart it with a new TS.</li>
</ul>
</li>
<li>Else:
<ul>
<li>→ Allow Ti to read X.</li>
<li>→ Update R-TS(X) to max(R-TS(X), TS(Ti))</li>
<li>→ Make a local copy of X to ensure repeatable reads for Ti.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>BASIC T/O – WRITES</strong></p>
<ul>
<li>Can’t write if a future transaction has read or written to the object.(不能写未来读过和写过的数据)</li>
<li>Action: Transaction Ti wants to write object X.</li>
<li>If TS(Ti) &lt; R-TS(X) or TS(Ti) &lt; W-TS(X)
<ul>
<li>→ Abort and restart Ti.</li>
</ul>
</li>
<li>Else:
<ul>
<li>→ Allow Ti to write X and update W-TS(X)</li>
<li>→ Also, make a local copy of X to ensure repeatable reads.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Thomas Write Rule</strong></p>
<ul>
<li>对上述理论进行优化</li>
<li>If TS(Ti) &lt; R-TS(X) (未来有事务读了这个数据)
<ul>
<li>Abort and Restart Ti</li>
</ul>
</li>
<li>If TS(Ti) &lt; R-WS(X) (未来有事务写了这个数据，等效成我写了然后未来被覆盖掉了)
<ul>
<li>The DBMS can instead ignore the write and allow the transaction to continue instead of aborting and restarting it. This is called the Thomas Write Rule.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>BASIC T/O总结</p>
<ul>
<li>优点：无锁，无死锁</li>
<li>缺点：对于长的事务可能会饥饿（一直rollback），前面的事务一旦修改数据后回滚那么后面的事务会读到错误的数据，读数据的时候需要copy一份到本地，如果读的数据过多，那么开销会很大</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter18-1.png" title="/img/CMU 15-445 Database Systems/chapter18-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter18-1.png" data-sub-html="<h2>事务2的数据来源于事务1，事务1一旦回滚那么无法恢复事务2</h2>">
        
    </a><figcaption class="image-caption">事务2的数据来源于事务1，事务1一旦回滚那么无法恢复事务2</figcaption>
    </figure>
<h3 id="optimistic-concurrency-control-occ">Optimistic Concurrency Control (OCC)</h3>
<ul>
<li>Also based on timestamp</li>
</ul>
<hr>
<ul>
<li>
<p><u>The DBMS creates a private workspace for each txn.</u></p>
<ul>
<li>→ Any object read is copied into workspace.</li>
<li>Modifications are applied to workspace.(If data is wried, only applied to private workspace, no need to be wried to DBMS)</li>
</ul>
</li>
<li>
<p>When a txn commits, the DBMS compares workspace write set to see whether it conflicts with other txns.(提交的时候DBMS看你workspace里面写的数据，和其他事务对比看看有无冲突)</p>
</li>
<li>
<p>If there are no conflicts, the write set is installed into the “global” database.(无冲突一把全部写回到数据库里面)</p>
</li>
</ul>
<hr>
<ul>
<li><strong>OCC PHASES</strong>
<ul>
<li><strong>#1 – Read Phase:</strong> Track the read/write sets of txns and store their writes in a private workspace.</li>
<li><strong>#2 – Validation Phase:</strong> When a txn commits, check whether it conflicts with other txns.</li>
<li><strong>#3 – Write Phase:</strong> If validation succeeds, apply private changes to database. Otherwise abort and restart the txn.</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter18-2.png" title="/img/CMU 15-445 Database Systems/chapter18-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter18-2.png" data-sub-html="<h2>OCC在提交的时候才会分配时间戳</h2>">
        
    </a><figcaption class="image-caption">OCC在提交的时候才会分配时间戳</figcaption>
    </figure>
<ul>
<li>
<p><strong>OCC – READ PHASE</strong></p>
<ul>
<li>Track the read/write sets of txns and store their writes in a private workspace.</li>
<li>The DBMS copies every tuple that the txn accesses from the shared database to its workspace ensure repeatable reads.</li>
</ul>
</li>
<li>
<p><strong>OCC – VALIDATION PHASE</strong></p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter18-3.png" title="/img/CMU 15-445 Database Systems/chapter18-3.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter18-3.png" data-sub-html="<h2>VALIDATION PHASE的决策图，不能提交的时候发现后面的事务读/写了自己写了的数据（因为按照串行的理论，应该是后面的事务要读自己提交后的数据，但是自己还没提交，后面的事务读的是自己之前的数据！）</h2>">
        
    </a><figcaption class="image-caption">VALIDATION PHASE的决策图，不能提交的时候发现后面的事务读/写了自己写了的数据（因为按照串行的理论，应该是后面的事务要读自己提交后的数据，但是自己还没提交，后面的事务读的是自己之前的数据！）</figcaption>
    </figure>
<ul>
<li><strong>Approach #1: Backward Validation</strong>：和前面的历史数据做校验</li>
<li><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter18-4.png" title="/img/CMU 15-445 Database Systems/chapter18-4.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter18-4.png">
        
    </a></li>
<li><strong>Approach #2: Forward Validation</strong>：和未来的事务做校验</li>
<li><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter18-5.png" title="/img/CMU 15-445 Database Systems/chapter18-5.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter18-5.png">
        
    </a></li>
</ul>
</li>
<li>
<p><strong>OCC – WRITE PHASE</strong></p>
<ul>
<li>Serial Commits: → Use a global latch to limit a single txn to be in the Validation/Write phases at a time.(直接锁全表写，一是为了解决并发问题，二来由于写的数据都准备好了，所以写耗费的时间很短，对并发度的影响不高)</li>
</ul>
</li>
<li>
<p>OCC works well when the # of conflicts is low:</p>
<ul>
<li>→ All txns are read-only (ideal).</li>
<li>→ Txns access disjoint subsets of data.</li>
</ul>
</li>
<li>
<p>If the database is large and the workload is not skewed, then there is a low probability of conflict, so again locking is wasteful.</p>
</li>
<li>
<p>OCC问题</p>
<ul>
<li>本地Copy带来的额外开销</li>
<li>commit的时候校验的逻辑很麻烦，消耗性能</li>
<li>写的步骤是锁表的，也可能会称为性能瓶颈</li>
<li>一旦出了问题前面干的全部回退，这也是一种浪费，2PL能够执行到一半发现死锁直接让这个事务回退，损失就比OCC要小</li>
</ul>
</li>
</ul>
<h3 id="dynamic-databases-and-the-phantom-problem">Dynamic Databases and The Phantom Problem</h3>
<ul>
<li>2PL和OCC在完全串行化上面都有BUG。。。$\rightarrow$ 幻读</li>
<li>前面讨论的问题都是read和update的问题，但是没有讨论insert和delete的问题</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter18-6.png" title="/img/CMU 15-445 Database Systems/chapter18-6.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter18-6.png" data-sub-html="<h2>幻读的情景</h2>">
        
    </a><figcaption class="image-caption">幻读的情景</figcaption>
    </figure>
<ul>
<li>2PL和OCC有这个BUG的原因：我只能控制现存的数据，但是不管数据的插入/删除</li>
</ul>
<hr>
<ul>
<li>
<p><strong>THE PHANTOM PROBLEM</strong></p>
</li>
<li>
<p><strong>Approach #1: Re-Execute Scans</strong></p>
<ul>
<li>对可能产生幻读的行为(SELECT … FROM … GROUP BY …/insert/delete)进行记录，然后在提交的时候再扫描一遍检测有无并发的问题</li>
<li>缺点：这种扫描开销过大，性能上接受不了</li>
</ul>
</li>
<li>
<p><strong>Approach #2: Predicate Locking</strong></p>
<ul>
<li>
<p>最早由System R发明</p>
</li>
<li>
<p>Shared lock on the predicate in a WHERE clause of a SELECT query.</p>
</li>
<li>
<p>Exclusive lock on the predicate in a WHERE clause of any UPDATE, INSERT, or DELETE query</p>
</li>
<li>
<p>It is rarely implemented in systems; an example of a system that uses it is HyPer (precision locking).</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter18-7.jpg" title="/img/CMU 15-445 Database Systems/chapter18-7.jpg" data-thumbnail="/img/CMU 15-445 Database Systems/chapter18-7.jpg" data-sub-html="<h2>谓词锁控制数据竞争</h2>">
        
    </a><figcaption class="image-caption">谓词锁控制数据竞争</figcaption>
    </figure>
</li>
</ul>
</li>
<li>
<p><strong>Approach #3: Index Locking</strong></p>
<ul>
<li>有索引给索引上锁，没索引就要加大的列锁/表锁了</li>
</ul>
</li>
<li>
<p>MySQL的解决方案：间隙锁</p>
</li>
</ul>
<h3 id="isolation-levels">Isolation Levels</h3>
<ul>
<li>
<p>数据库很难做到完全串行，而且很多业务也不需要完全串行，所以有不同的隔离级别</p>
</li>
<li>
<p><strong>Isolation Levels (Strongest to Weakest):</strong></p>
<ul>
<li>
<p><strong>SERIALIZABLE</strong>: No Phantoms, all reads repeatable, and no dirty reads.</p>
<ul>
<li>Possible implementation: Index locks + Strict 2PL.</li>
</ul>
</li>
<li>
<p><strong>REPEATABLE READS</strong>: Phantoms may happen.</p>
<ul>
<li>Possible implementation: Strict 2PL.</li>
</ul>
</li>
<li>
<p><strong>READ-COMMITTED</strong>: Phantoms and unrepeatable reads may happen.</p>
<ul>
<li>Possible implementation: Strict 2PL for exclusive locks, immediate release of the shared lock after a read.</li>
</ul>
</li>
<li>
<p><strong>READ-UNCOMMITTED</strong>: All anomalies may happen.</p>
<ul>
<li>Possible implementation: Strict 2PL for exclusive locks, no shared locks for reads.</li>
</ul>
</li>
</ul>
</li>
<li>
<a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter18-8.png" title="/img/CMU 15-445 Database Systems/chapter18-8.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter18-8.png">
        
    </a>
</li>
<li>
<a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter18-9.png" title="/img/CMU 15-445 Database Systems/chapter18-9.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter18-9.png">
        
    </a>
</li>
<li>
<p>如果显式声明一个表是READ ONLY的话，那么数据库会进行优化（不加锁），还有的数据库会自动检测，如果没有写的操作会自动优化</p>
</li>
</ul>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #17: Two-Phase Locking</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter17/</link>
    <pubDate>Fri, 19 Apr 2024 17:58:06 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter17/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-17-two-phase-locking">Lecture #17: Two-Phase Locking</h2>
<h3 id="transaction-locks">Transaction Locks</h3>
<ul>
<li>
<p>在操作数据的时候通过DBMS的锁管理器给数据上一把锁，这样就可以避免并发的数据竞争问题</p>
</li>
<li>
<p>但是这个锁怎么加怎么解的方案需要设计</p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter17-1.png" title="/img/CMU 15-445 Database Systems/chapter17-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter17-1.png" data-sub-html="<h2>利用锁保证数据安全</h2>">
        
    </a><figcaption class="image-caption">利用锁保证数据安全</figcaption>
    </figure>
<ul>
<li>
<p><strong>Lock Types</strong></p>
<ul>
<li><strong>S-LOCK</strong>: Shared locks for reading(Reading Lock)</li>
<li><strong>X-LOCK</strong>: Exclusive locks for writing(Writing Lock)</li>
</ul>
</li>
<li>
<p>仅仅W(R)的时候上锁，修改完了解锁是无法修复串行化带来的问题，因为这个操作在一个事务里面只是一段，没有锁这个事务</p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter17-2.png" title="/img/CMU 15-445 Database Systems/chapter17-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter17-2.png" data-sub-html="<h2>lock -&gt; W(R) -&gt; unlock下的串行问题</h2>">
        
    </a><figcaption class="image-caption">lock -&gt; W(R) -&gt; unlock下的串行问题</figcaption>
    </figure>
<h3 id="two-phase-locking2pl">Two-Phase Locking(2PL)</h3>
<ul>
<li>这个就是后面的研究人员为了避免上面加锁还是没有解决并发问题提出来的一个理论，这个加锁的理论和上面最大的不同就是不用预先知道整个事务的全貌（前面的加锁方案好多都是事后诸葛亮，但是放在真实场景下你又不可能回滚去干这玩意）</li>
<li>2PL分为两个阶段
<ul>
<li><strong>Phase #1– Growing</strong>: In the growing phase, each transaction requests the locks that it needs from the DBMS’s lock manager. The lock manager grants/denies these lock requests.</li>
<li><strong>Phase #2– Shrinking</strong>: Transactions enter the shrinking phase immediately after they release their first
lock. In the shrinking phase, transactions are only allowed to release locks. They are not allowed to acquire
new ones.</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter17-3.png" title="/img/CMU 15-445 Database Systems/chapter17-3.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter17-3.png" data-sub-html="<h2>2PL Two Phases</h2>">
        
    </a><figcaption class="image-caption">2PL Two Phases</figcaption>
    </figure>
<ul>
<li>2PL的问题: <strong>cascading aborts</strong></li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter17-4.png" title="/img/CMU 15-445 Database Systems/chapter17-4.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter17-4.png" data-sub-html="<h2>Shrinking阶段如果Rollback，会造成其他事务读到了你上面修改过但未commit的数据</h2>">
        
    </a><figcaption class="image-caption">Shrinking阶段如果Rollback，会造成其他事务读到了你上面修改过但未commit的数据</figcaption>
    </figure>
<ul>
<li>Solution: <strong>Strong Strict 2PL (aka Rigorous 2PL)</strong></li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter17-5.png" title="/img/CMU 15-445 Database Systems/chapter17-5.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter17-5.png" data-sub-html="<h2>Strong Strict 2PL解决了cascading aborts问题</h2>">
        
    </a><figcaption class="image-caption">Strong Strict 2PL解决了cascading aborts问题</figcaption>
    </figure>
<hr>
<h3 id="deadlock-handling">Deadlock Handling</h3>
<ul>
<li>2PL的另一个问题: <strong>Dead-Locks</strong></li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter17-6.png" title="/img/CMU 15-445 Database Systems/chapter17-6.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter17-6.png" data-sub-html="<h2>Strong Strict 2PL解决不了Dead-Lock的问题，出来环锁基本就解不开了</h2>">
        
    </a><figcaption class="image-caption">Strong Strict 2PL解决不了Dead-Lock的问题，出来环锁基本就解不开了</figcaption>
    </figure>
<ul>
<li>
<p>Two ways of dealing with deadlocks:</p>
<ul>
<li>
<p>→ Approach #1: <strong>Deadlock Detection</strong>:DBMS会维护一个waits-for graph来描述所有并发的事务谁在等谁的锁</p>
<ul>
<li>Nodes are transactions</li>
<li>Edge from $T_i$ to $T_j$ if $T_i$ is waiting for $T_j$ to release a lock.</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter17-7.png" title="/img/CMU 15-445 Database Systems/chapter17-7.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter17-7.png" data-sub-html="<h2>The system periodically checks for cycles in waits-for graph and then decides how to break it.</h2>">
        
    </a><figcaption class="image-caption">The system periodically checks for cycles in waits-for graph and then decides how to break it.</figcaption>
    </figure></li>
<li>When the DBMS detects a deadlock, it will <strong>select a “victim” transaction to rollback(rollback or restart) to break the cycle.</strong></li>
<li>权衡: 检测周期和死锁解开时间反相关，和开销正相关，还有就是干掉那个事务(执行时间，young还是old，执行了几条SQL，加了几个锁)</li>
<li><strong>Deadlock handling: rollback length</strong>
<ul>
<li>Approach #1: <strong>Completely</strong> → Rollback entire txn and tell the application it was aborted.</li>
<li>Approach #2: <strong>Partial (Savepoints)</strong> → DBMS rolls back a portion of a txn (to break deadlock) and then attempts to re-execute the undone queries.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>→ Approach #2: <strong>Deadlock Prevention</strong></p>
<ul>
<li>
<p>给每个事务加上时间戳，越靠前的事务越老，越靠后的事务越年轻</p>
</li>
<li>
<p>Older Timestamp = Higher Priority (e.g., T1 &gt; T2)</p>
</li>
<li>
<p><strong>Wait-Die (“Old Waits for Young”)</strong>:</p>
<ul>
<li>If requesting txn has higher priority than holding txn, then requesting txn waits for holding txn. (老事务碰到年轻的事务占有锁，就等到年轻的事务解锁)</li>
<li>Otherwise requesting txn aborts.(反之年轻的事务等老事务的锁，直接rollback自杀)</li>
</ul>
</li>
<li>
<p><strong>Wound-Wait (“Young Waits for Old”)</strong></p>
<ul>
<li>If requesting txn has higher priority than holding txn, then holding txn aborts and releases lock(老的事务要锁，发现整个锁被年轻的事务持有，直接rollback年轻的事务然后抢锁)</li>
<li>Otherwise requesting txn waits.(年轻的事务发现锁在老的事务哪里，那就等老的事务解锁)</li>
</ul>
</li>
<li>
<p>这个主要的思路就是解决了构成死锁条件里面“持有并等待”的条件，冲突了直接开抢</p>
</li>
<li>
<p>注意: restart的txn的时间戳用上次的时间戳，不然可能会造成饥饿</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="lock-granularities">Lock Granularities</h3>
<ul>
<li>
<p>获取锁的时候是获取属性锁，行锁，表锁，还是库锁？整个需要DBMS来负责，需要保证你加锁的数量尽可能小(10亿行锁 vs 一张表锁)，也需要考虑对并发度的影响</p>
</li>
<li>
<p><strong>Intention Lock</strong>:高层级的锁会有标记来判断下面有没有加锁的（比如表锁会记录下面的行有没有加锁的），节省了向下检索的效率</p>
<ul>
<li>意向锁也有S锁和X锁</li>
</ul>
</li>
<li>
<p>分层的锁在实际工程中相当好用</p>
</li>
<li>
<p><strong>LOCK ESCALATION</strong></p>
<ul>
<li>如果下层的锁过多了，那么DBMS就会自动升级成高层的锁（怎么和JVM的锁升级机制的思想很像？）</li>
</ul>
</li>
<li>
<p>一般加锁都是DBMS自动负责的，但是用户可以用SQL手动来加锁</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-mysql" data-lang="mysql"><span class="line"><span class="cl"><span class="k">LOCK</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="o">&lt;</span><span class="k">table</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="n">mode</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="o">&lt;</span><span class="k">table</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="o">&lt;</span><span class="n">qualification</span><span class="o">&gt;</span><span class="w"> </span><span class="k">FOR</span><span class="w"> </span><span class="k">UPDATE</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">#这样告诉了MYSQL这个不加读锁，加写锁(后面要UPDATE)
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="conclusion">CONCLUSION</h3>
<ul>
<li>
<p>2PL is used in almost every DBMS.</p>
</li>
<li>
<p>Automatically generates correct interleaving:</p>
<ul>
<li>Locks + protocol (2PL, SS2PL &hellip;)</li>
<li>Deadlock detection + handling</li>
<li>Deadlock prevention</li>
</ul>
</li>
</ul>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #16: Concurrency Control Theory</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter16/</link>
    <pubDate>Mon, 15 Apr 2024 16:04:09 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter16/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-16-concurrency-control-theory">Lecture #16: Concurrency Control Theory</h2>
<h3 id="motivation">Motivation</h3>
<ul>
<li>Lost Update Problem (Concurrency Control):数据竞争</li>
<li>Durability Problem (Recovery):故障恢复</li>
</ul>
<h3 id="transactions">Transactions</h3>
<ul>
<li>
<p>特点：ACID</p>
</li>
<li>
<p>Atomicity: Atomicity ensures that either all actions in the transaction happen, or none happen.</p>
</li>
<li>
<p>Consistency: If each transaction is consistent and the database is consistent at the beginning of the transaction, then the database is guaranteed to be consistent when the transaction completes. Data is consistent if it satisfies all validation rules such as constraints, cascades and triggers.</p>
</li>
<li>
<p>Isolation: Isolation means that when a transaction executes, it should have the illusion that it is isolated from other transactions. Isolation ensures that concurrent execution of transactions should have the same resulting database state as a sequential execution of the transactions.</p>
</li>
<li>
<p>Durability: If a transaction commits, then its effects on the database should persist.</p>
</li>
</ul>
<h3 id="acid-atomicity">ACID: Atomicity</h3>
<ul>
<li>
<p>Approach #1: Logging:常用的方法就是记日至，典型的就是undo log，日志也能提交性能（异步刷磁盘）</p>
</li>
<li>
<p>Approach #2: Shadow Paging:备份自己改的那些页</p>
</li>
</ul>
<h3 id="acid-consistency">ACID: Consistency</h3>
<ul>
<li>后面的事务能看见前面事务的变动</li>
<li>业务的一致性是后端程序员保证的</li>
</ul>
<h3 id="acid-isolation">ACID: Isolation</h3>
<ul>
<li>好像就我一个人在用数据库</li>
<li>但是实际上是好多txn在一起跑</li>
<li>这边也是两大流派
<ul>
<li>悲观控制</li>
<li>乐观控制+回滚</li>
</ul>
</li>
<li>三种冲突
<ul>
<li>R-W</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter16-1.png" title="/img/CMU 15-445 Database Systems/chapter16-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter16-1.png" data-sub-html="<h2>R-W也叫不可重复读</h2>">
        
    </a><figcaption class="image-caption">R-W也叫不可重复读</figcaption>
    </figure></li>
<li>W-R</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter16-2.png" title="/img/CMU 15-445 Database Systems/chapter16-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter16-2.png" data-sub-html="<h2>W-R也叫脏读</h2>">
        
    </a><figcaption class="image-caption">W-R也叫脏读</figcaption>
    </figure></li>
<li>W-W</li>
</ul>
</li>
</ul>
<h3 id="acid-durability">ACID: Durability</h3>
<ul>
<li>一旦commit，必须保证持久化到磁盘上面</li>
</ul>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #15: Query Planning &amp; Optimization</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter15/</link>
    <pubDate>Mon, 15 Apr 2024 12:47:46 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter15/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-15-query-planning--optimization">Lecture #15: Query Planning &amp; Optimization</h2>
<ul>
<li>数据库最复杂的模块之一，论文都在这个上面做功夫</li>
</ul>
<h3 id="overview">Overview</h3>
<ul>
<li>
<p>SQL都是声明式的，没有告诉DBMS执行的过程</p>
</li>
<li>
<p>需要优化器来根据SQL告诉DBMS具体怎么执行</p>
</li>
<li>
<p>两种流派</p>
<ul>
<li>SQL+优化器</li>
<li>大数据处理框架(flink,spark)+程序员</li>
</ul>
</li>
<li>
<p>优化的两种流派</p>
<ul>
<li>Heuristics/Rules
<ul>
<li>启发式，通过查看catalog来看表的结构/有无索引，从而进行优化</li>
</ul>
</li>
<li>Cost-base Search
<ul>
<li>基于代价的：要估计每一个查询plan的变化，然后进行决策，要知道数据的情况</li>
</ul>
</li>
<li>大部分的数据库会结合这两个流派</li>
</ul>
</li>
<li>
<p><strong>Logical vs. Physical Plans</strong></p>
<ul>
<li>逻辑计划都是关系代数级别的</li>
<li>物理计划具体到怎么执行，比如算子怎么执行，是sort join还是hash join</li>
</ul>
</li>
<li>
<p>计划的优化是NP难度级别的问题，这门课就是讲的普及</p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter15-1.png" title="/img/CMU 15-445 Database Systems/chapter15-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter15-1.png" data-sub-html="<h2>例子：逻辑等价优化</h2>">
        
    </a><figcaption class="image-caption">例子：逻辑等价优化</figcaption>
    </figure>
<h3 id="logical-query-optimization">Logical Query Optimization</h3>
<ul>
<li>
<p>自己要写一些模式上面的规则，让优化器拿着规则去优化，比如JOIN怎么消除，怎么做索引下推</p>
</li>
<li>
<p>缺点：只能根据规则进行逻辑计划的转换，但是不能根据代价开销去进行优化，很死板</p>
</li>
<li>
<p>Some pattern</p>
<ul>
<li>Perform filters as early as possible (predicate pushdown).</li>
<li>Reorder predicates so that the DBMS applies the most selective one first.</li>
<li>Breakup a complex predicate and pushing it down (split conjunctive predicates)</li>
</ul>
</li>
</ul>
<h3 id="cost-estimations">Cost Estimations</h3>
<ul>
<li>
<p>最大的代价还是磁盘的I/O，这里的优化就是减少I/O</p>
</li>
<li>
<p>postgres:用的”magic”，黑魔法</p>
</li>
<li>
<p>老牌的商用数据库在优化的时候比开源的要保守和细得多，DB2就会结合事务，锁，用户数整体考虑，pg就比较激进和简单了</p>
</li>
<li>
<p><strong>Selection Statistics</strong></p>
<ul>
<li>这个就是参数，关系型数据库会对每张表做统计信息，这样你分析才有参数</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter15-2.png" title="/img/CMU 15-445 Database Systems/chapter15-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter15-2.png" data-sub-html="<h2>强制立即更新统计信息的命令</h2>">
        
    </a><figcaption class="image-caption">强制立即更新统计信息的命令</figcaption>
    </figure>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #14: Query Execution II</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter14/</link>
    <pubDate>Fri, 12 Apr 2024 21:01:51 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter14/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-14-query-execution-ii">Lecture #14: Query Execution II</h2>
<h3 id="background">Background</h3>
<ul>
<li>上节课讨论了DBMS的执行过程</li>
<li>这节课讨论DBMS在多线程下的执行过程</li>
</ul>
<h3 id="parallel-vs-distributed-databases">Parallel vs Distributed Databases</h3>
<ul>
<li>
<p>并行和分布式数据库</p>
</li>
<li>
<p><strong>Parallel DBMSs</strong></p>
<ul>
<li>资源都在一块，离得很近</li>
<li>资源通信很高速，OS内通信</li>
<li>线程间的通信高速又可靠</li>
</ul>
</li>
<li>
<p><strong>Distributed Databases</strong></p>
<ul>
<li>资源相互之间离得很远</li>
<li>资源之间的通信很慢</li>
<li>节点之间通信的代价很高且不可靠</li>
</ul>
</li>
</ul>
<h3 id="process-models">Process Models</h3>
<ul>
<li>模型：认为每个DBMS下面有多个worker，多个worker并行处理</li>
<li>这个模型针对的是多个SQL并发执行的问题，不能做个单个SQL并发处理的问题</li>
</ul>
<hr>
<ul>
<li><strong>Process per Worker</strong>
<ul>
<li>每一个worker给分配一个进程(OS级别的)</li>
<li>依赖OS对进程的调度</li>
<li>用共享内存来进行通信</li>
<li>优点：一个进程崩了不至于让整个系统宕机</li>
<li>例子：Oracle，Postgres(因为开发年代太古早)</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter14-1.png" title="/img/CMU 15-445 Database Systems/chapter14-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter14-1.png" data-sub-html="<h2>工作模型，因为进程太吃资源，后面基本都做了池化的技术</h2>">
        
    </a><figcaption class="image-caption">工作模型，因为进程太吃资源，后面基本都做了池化的技术</figcaption>
    </figure></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Thread per Worker</strong>
<ul>
<li>pthread统一出现后各大数据库也把模型换成了给worker分配线程</li>
<li>优点：线程切换代价小，内存天然共享</li>
<li>缺点：一个线程崩了整个进程跟着崩</li>
<li>例子：MySQL，IBM DB2</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter14-2.png" title="/img/CMU 15-445 Database Systems/chapter14-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter14-2.png" data-sub-html="<h2>工作模型</h2>">
        
    </a><figcaption class="image-caption">工作模型</figcaption>
    </figure></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p><strong>Scheduling</strong></p>
<ul>
<li>In conclusion, for each query plan, the DBMS has to decide where, when, and how to execute. Relevant
questions include:
<ul>
<li>How many tasks should it use?</li>
<li>How many CPU cores should it use?</li>
<li>What CPU cores should the tasks execute on?</li>
<li>Where should a task store its output?</li>
</ul>
</li>
<li>When making decisions regarding query plans, <strong>the DBMS always knows more than the OS</strong> and should be
prioritized as such.</li>
</ul>
</li>
<li>
<p>说白了就是让DBMS安排一个执行计划怎么执行，这个东西和缓存一样，不能完全依赖OS线程方面的系统调用，要定制化</p>
</li>
</ul>
<h3 id="inter-query-parallelism">Inter-Query Parallelism</h3>
<ul>
<li>多个SQL之间怎么并发执行</li>
<li>如果并发的查询都是只读的，那冲突很小</li>
<li>如果并发的查询涉及更新数据，那冲突就很多且不可避免</li>
</ul>
<h3 id="intra-query-parallelism-horizontal">Intra-Query parallelism (Horizontal)</h3>
<ul>
<li>
<p>水平切，把要处理的数据给切开，然后分给多个线程，这个切是靠Exchange算子的</p>
</li>
<li>
<p>多个线程干的事情是一一样的</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter14-3.png" title="/img/CMU 15-445 Database Systems/chapter14-3.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter14-3.png" data-sub-html="<h2>Exchange算子工作模型，并发调用</h2>">
        
    </a><figcaption class="image-caption">Exchange算子工作模型，并发调用</figcaption>
    </figure>
</li>
<li>
<p>Exchange Type #1 – <strong>Gather</strong></p>
<ul>
<li>→ Combine the results from multiple workers into a single output stream.</li>
</ul>
</li>
<li>
<p>Exchange Type #2 – <strong>Distribute</strong></p>
<ul>
<li>→ Split a single input stream into multiple output streams.</li>
</ul>
</li>
<li>
<p>Exchange Type #3 – <strong>Repartition</strong></p>
<ul>
<li>→ Shuffle multiple input streams across multiple output streams.</li>
</ul>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter14-4.png" title="/img/CMU 15-445 Database Systems/chapter14-4.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter14-4.png" data-sub-html="<h2>三个类型的工作模型</h2>">
        
    </a><figcaption class="image-caption">三个类型的工作模型</figcaption>
    </figure>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter14-5.png" title="/img/CMU 15-445 Database Systems/chapter14-5.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter14-5.png" data-sub-html="<h2>Para Hash</h2>">
        
    </a><figcaption class="image-caption">Para Hash</figcaption>
    </figure>
<h3 id="inter-operator-parallelism--vertical">Inter-Operator parallelism  (Vertical)</h3>
<ul>
<li>垂直切，让多个算子并发执行，数据在每个算子之间流动</li>
<li>Also called pipeline parallelism.</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter14-6.png" title="/img/CMU 15-445 Database Systems/chapter14-6.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter14-6.png" data-sub-html="<h2>多个算子并发</h2>">
        
    </a><figcaption class="image-caption">多个算子并发</figcaption>
    </figure>
<ul>
<li>缺点：中间一个线程处理的速度慢，其他部分线程就要等，会浪费</li>
</ul>
<h3 id="bushy-parallelism">Bushy Parallelism</h3>
<ul>
<li>上面两种并发方式的结合</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter14-7.png" title="/img/CMU 15-445 Database Systems/chapter14-7.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter14-7.png" data-sub-html="<h2>水平并发&#43;垂直并发</h2>">
        
    </a><figcaption class="image-caption">水平并发+垂直并发</figcaption>
    </figure>
<h3 id="io-parallelism">I/O Parallelism</h3>
<ul>
<li>
<p>上面的模型说的都是数据已经在内存中的并行，但是对于本课程的数据库，I/O带来的性能问题如何通过并行优化甚至比前面的并行优化还重要</p>
</li>
<li>
<p>还有上面的内存并行带来的问题可能是两个算子并发读写磁盘的不同部分，那对于机械盘来说这种随机读写也会大大降低性能，这部分也要进行优化</p>
</li>
</ul>
<hr>
<ul>
<li><strong>Split the DBMS across multiple storage devices to improve disk bandwidth latency.Many different options that have trade-offs</strong>:
<ul>
<li>→ Multiple Disks per Database</li>
<li>→ One Database per Disk</li>
<li>→ One Relation per Disk</li>
<li>→ Split Relation across Multiple Disks</li>
</ul>
</li>
<li>Some DBMSs support this natively. Others require admin to configure outside of DBMS.</li>
</ul>
<hr>
<ul>
<li><strong>Multi-Disk Parallelism</strong>
<ul>
<li>在操作系统/硬件层面让不同的DBMS文件去不同的磁盘(e.g. RAID)，这个层面对DBMS是透明的（对于他来说就像操作一个盘一样）</li>
<li>多盘并发</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter14-8.png" title="/img/CMU 15-445 Database Systems/chapter14-8.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter14-8.png" data-sub-html="<h2>RAID0(Striping)下面的多盘并发</h2>">
        
    </a><figcaption class="image-caption">RAID0(Striping)下面的多盘并发</figcaption>
    </figure></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Database Partitioning</strong>
<ul>
<li>把数据库也进行切分</li>
<li>不同的库存在不同的盘，如果有统一恢复用的log文件要记得做好共享问题</li>
<li>把单个的表进行分区，物理存储上分成多个部分，注意，这个分区对应用程序来说要是透明的，不需要关心数据如何存储的</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter14-9.png" title="/img/CMU 15-445 Database Systems/chapter14-9.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter14-9.png" data-sub-html="<h2>某一个属性特别的大且不常用就可以垂直切开分两部分存</h2>">
        
    </a><figcaption class="image-caption">某一个属性特别的大且不常用就可以垂直切开分两部分存</figcaption>
    </figure></li>
</ul>
</li>
</ul>
<h3 id="conclusion">CONCLUSION</h3>
<ul>
<li>
<p>Parallel execution is important, which is why (almost) every major DBMS supports it.</p>
</li>
<li>
<p>However, it is hard to get right.</p>
<ul>
<li>→ Coordination Overhead</li>
<li>→ Scheduling</li>
<li>→ Concurrency Issues</li>
<li>→ Resource Contention</li>
</ul>
</li>
<li>
<p>总结：并发能提示DBMS效率，但是理论简单实现难得多，要面对一大堆的问题</p>
</li>
</ul>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #13: Query Processing I</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter13/</link>
    <pubDate>Fri, 12 Apr 2024 14:56:21 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter13/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-13-query-processing-i">Lecture #13: Query Processing I</h2>
<h3 id="query-plan">Query Plan</h3>
<ul>
<li>就是前面提到的执行树</li>
<li>同一个SQL可以有很多执行计划</li>
</ul>
<h3 id="processing-models">Processing Models</h3>
<ul>
<li>Approach #1: <strong>Iterator Model</strong></li>
<li>Approach #2: <strong>Materialization Model</strong></li>
<li>Approach #3: <strong>Vectorized / Batch Model</strong></li>
</ul>
<hr>
<ul>
<li>
<p><strong>Iterator Model</strong></p>
<ul>
<li>
<p>每一个算子需要提供一个Next()的方法，父算子调用一次就吐出来一些数据，如果返回null说明数据都吐出来了（很像Python的yield），我也可以调用我的子算子的Next()方法</p>
</li>
<li>
<p>也叫“<strong>Volcano/Pipeline Model</strong>”</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter12-1.jpg" title="/img/CMU 15-445 Database Systems/chapter12-1.jpg" data-thumbnail="/img/CMU 15-445 Database Systems/chapter12-1.jpg" data-sub-html="<h2>Volcano Model计算的模型</h2>">
        
    </a><figcaption class="image-caption">Volcano Model计算的模型</figcaption>
    </figure>
</li>
<li>
<p>这个模型几乎在所有DBMS中都有使用</p>
</li>
<li>
<p>这个模型会有Block的现象，比如Join的时候左边在hash，这个时候上层会被Block</p>
</li>
<li>
<p>部分操作不适合这个模型，比如Sort，只能Block之后全吐出来</p>
</li>
<li>
<p>优点：便于操作，比如LIMIT 100的话我Next() 100次就OK</p>
</li>
<li>
<p>缺点：过多的函数调用（一次返回一个，要调用好多次）会影响性能</p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p><strong>Materialization Model</strong></p>
<ul>
<li>
<p>符合直觉的模型，一把算出来给上面</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter12-2.png" title="/img/CMU 15-445 Database Systems/chapter12-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter12-2.png" data-sub-html="<h2>这里的返回值就是数组，是下面算子的最终结果</h2>">
        
    </a><figcaption class="image-caption">这里的返回值就是数组，是下面算子的最终结果</figcaption>
    </figure>
</li>
<li>
<p>OLTP的数据库喜欢这个模型(点查询)</p>
</li>
<li>
<p>OLAP容易给表吐爆</p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Vectorized / Batch Model</strong>
<ul>
<li>前两个模型折中，Next()每次吐出来一批</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter12-3.png" title="/img/CMU 15-445 Database Systems/chapter12-3.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter12-3.png" data-sub-html="<h2>每次吐出来一批数据</h2>">
        
    </a><figcaption class="image-caption">每次吐出来一批数据</figcaption>
    </figure></li>
<li>OLAP友好，函数调用不会过多，又不会像<strong>Materialization Model</strong>那样一次返回的东西太大</li>
<li>还有个好处就是匹配硬件，现在部分CPU支持小规模并行处理事务（类似残废版CUDA），这种模型非常符合CPU的并行批处理指令</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>函数调用的方向可以根到叶子，也可以叶子到根</li>
</ul>
<h3 id="access-methods">Access Methods</h3>
<ul>
<li><strong>Sequential Scan</strong>
<ul>
<li>顺序扫描</li>
<li>顺序把页读进来，然后顺序扫描叶中的元组</li>
<li>优化
<ul>
<li>预加载</li>
<li>不再读的东西扫完就扔</li>
<li>并行化</li>
<li>Zone Maps
<ul>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter12-4.png" title="/img/CMU 15-445 Database Systems/chapter12-4.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter12-4.png" data-sub-html="<h2>给每个页做统计信息，这样算子可以不用加载到缓存池就对页做一次判断和过滤</h2>">
        
    </a><figcaption class="image-caption">给每个页做统计信息，这样算子可以不用加载到缓存池就对页做一次判断和过滤</figcaption>
    </figure></li>
<li>问题:数据冗余，而且不能存到页里面（那又该加载到缓存池了），要转门找地方存，还要同步数据</li>
</ul>
</li>
<li>晚物化：只要需要的数据，不要整个Tuple，或者只存Record ID，利用回表拿数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Index Scan</strong>
<ul>
<li>考虑的条件后面会讲</li>
<li>用什么索引要靠优化器分析</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Multi-Index Scan</strong>
<ul>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter12-5.png" title="/img/CMU 15-445 Database Systems/chapter12-5.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter12-5.png" data-sub-html="<h2>多索引扫描每一个条件取集合，根据谓词做交/并的操作</h2>">
        
    </a><figcaption class="image-caption">多索引扫描每一个条件取集合，根据谓词做交/并的操作</figcaption>
    </figure></li>
</ul>
</li>
</ul>
<h3 id="modification-queries">Modification Queries</h3>
<ul>
<li>
<p>更改的操作，逻辑会不一样</p>
<ul>
<li>不能无脑修改，要检查当前表的约束</li>
<li>索引等其他数据要同步进行维护</li>
<li>HALLOWEEN PROBLEM
<ul>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter12-6.png" title="/img/CMU 15-445 Database Systems/chapter12-6.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter12-6.png" data-sub-html="<h2>不记录之前操作过什么数据会导致部分数据被多次更新（更新完了之后没有达到预定条件被扫到再次被更新）</h2>">
        
    </a><figcaption class="image-caption">不记录之前操作过什么数据会导致部分数据被多次更新（更新完了之后没有达到预定条件被扫到再次被更新）</figcaption>
    </figure></li>
</ul>
</li>
</ul>
</li>
<li>
<p>expression tree</p>
<ul>
<li>给谓词表达式也用树的结构处理
<ul>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter12-7.png" title="/img/CMU 15-445 Database Systems/chapter12-7.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter12-7.png" data-sub-html="<h2>expression tree</h2>">
        
    </a><figcaption class="image-caption">expression tree</figcaption>
    </figure></li>
</ul>
</li>
<li>缺点：可能会重复计算浪费时间</li>
<li>解决方案：能先算出来的全算出来，像Java的JIT（比如经常跑的一段Java字节码，我直接转成二进制CPU指令，然后跑的时候直接跑CPU指令，省去JVM解析的过程）</li>
</ul>
</li>
</ul>
<h3 id="conclusion">CONCLUSION</h3>
<ul>
<li>The same query plan can be executed in multiple different ways.</li>
<li>(Most) DBMSs will want to use index scans as much as possible.</li>
<li>Expression trees are flexible but slow.JIT compilation can (sometimes) speed them up.</li>
</ul>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #11: Joins Algorithms</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter11/</link>
    <pubDate>Fri, 12 Apr 2024 00:56:12 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter11/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-11-joins-algorithms">Lecture #11: Joins Algorithms</h2>
<h3 id="introduction">Introduction</h3>
<ul>
<li>
<p>根据数据库的范式理论，设计数据库表的一个原则是不让数据冗余，所以在查找的时候JOIN的操作是少不了的</p>
</li>
<li>
<p>For binary joins, we often prefer the left table (the ”outer table” ) to be the smaller one of the two.优化SQL的一个方法，左表尽量小(<strong>这个小指的是文件页数少</strong>)，后面会说明原因</p>
</li>
</ul>
<h3 id="join-operators">Join Operators</h3>
<ul>
<li><strong>Operator Output</strong>
<ul>
<li>两个表满足JOIN条件的attributes可以组合成一个新的tuple</li>
<li>输出取决于以下几个方面
<ul>
<li>processing model</li>
<li>storage model</li>
<li>data requirements in query</li>
</ul>
</li>
<li><strong>Data</strong>
<ul>
<li><strong>Early materialization</strong>
<ul>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter11-1.png" title="/img/CMU 15-445 Database Systems/chapter11-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter11-1.png" data-sub-html="<h2>JOIN的时候需要什么属性都加上，最后直接输出</h2>">
        
    </a><figcaption class="image-caption">JOIN的时候需要什么属性都加上，最后直接输出</figcaption>
    </figure></li>
<li>可以避免子操作回表</li>
</ul>
</li>
<li><strong>Record Id</strong>
<ul>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter11-2.png" title="/img/CMU 15-445 Database Systems/chapter11-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter11-2.png" data-sub-html="<h2>属性里面放的是行id或者地址，后面需要回表拿数据</h2>">
        
    </a><figcaption class="image-caption">属性里面放的是行id或者地址，后面需要回表拿数据</figcaption>
    </figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p><strong>Cost Analysis</strong></p>
<ul>
<li>
<p>不同JOIN算法的开销</p>
</li>
<li>
<p>Assume</p>
<ul>
<li>
<p>M pages in table R, m tuples in R</p>
</li>
<li>
<p>N pages in table S, n tuples in S</p>
</li>
<li>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="n">R</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">S</span><span class="p">.</span><span class="n">cdate</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">S</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">ON</span><span class="w"> </span><span class="n">R</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">S</span><span class="p">.</span><span class="n">id</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">S</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>
<p>Cost Metric: <strong>number of IOs</strong> to compute join</p>
</li>
<li>
<p><strong>JOIN Algorithms</strong></p>
<ul>
<li>Next Loop Join</li>
<li>Sort-Merge Join</li>
<li>Hash Join</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="nested-loop-join">Nested Loop Join</h3>
<ul>
<li><strong>Native Nested Loop Join</strong></li>
<li>伪代码</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="line"><span class="cl"><span class="k">foreach</span> <span class="n">tuple</span> <span class="n">r</span> <span class="k">in</span> <span class="n">R</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">foreach</span> <span class="n">tuple</span> <span class="n">s</span> <span class="k">in</span> <span class="n">S</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">r</span> <span class="n">and</span> <span class="n">s</span> <span class="n">match</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">emit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>“stupid nested loop join”</p>
<ul>
<li><strong>一个R中的tuple需要扫S表的所有数据，对于缓存池的利用率过低，这种方法开销太大</strong></li>
<li>S每次都是先灌满缓存池，然后前面的页淘汰，如此反复</li>
</ul>
</li>
<li>
<p>Assume</p>
<ul>
<li>
<p>M pages in table R, m tuples in R</p>
</li>
<li>
<p>N pages in table S, n tuples in S</p>
</li>
</ul>
</li>
<li>
<p>Cost: $M+(m \times N)$</p>
</li>
<li>
<p>优化：高效利用缓存池，一次多加载一些页，不要一页一页加载</p>
</li>
<li>
<p><strong>Block Nested Loop Join</strong></p>
</li>
<li>
<p>伪代码</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="line"><span class="cl"><span class="k">foreach</span> <span class="n">block</span> <span class="n">B_R</span> <span class="k">in</span> <span class="n">R</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">foreach</span> <span class="n">block</span> <span class="n">B_S</span> <span class="k">in</span> <span class="n">S</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">foreach</span> <span class="n">tuple</span> <span class="n">r</span> <span class="k">in</span> <span class="n">B_R</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">foreach</span> <span class="n">tuple</span> <span class="n">s</span> <span class="k">in</span> <span class="n">B_S</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="n">r</span> <span class="n">and</span> <span class="n">s</span> <span class="n">match</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">emit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>每次不只读一页，每次R和S都读好多页进行匹配</p>
</li>
<li>
<p>Cost: $M+(\frac{M}{M\ Block\ Size} \times N)$</p>
</li>
<li>
<p>讨论block size</p>
</li>
<li>
<p>B个页的内存，一个页做输出缓存，一个页给右表，多缓存左表(给B-2个)</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="line"><span class="cl"><span class="k">foreach</span> <span class="n">B</span><span class="p">-</span><span class="m">2</span> <span class="n">blocks</span> <span class="n">B_R</span> <span class="k">in</span> <span class="n">R</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">foreach</span> <span class="n">block</span> <span class="n">B_S</span> <span class="k">in</span> <span class="n">S</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">foreach</span> <span class="n">tuple</span> <span class="n">r</span> <span class="k">in</span> <span class="n">B</span><span class="p">-</span><span class="m">2</span> <span class="n">blocks</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">foreach</span> <span class="n">tuple</span> <span class="n">s</span> <span class="k">in</span> <span class="n">B_S</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="n">r</span> <span class="n">and</span> <span class="n">s</span> <span class="n">match</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">emit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>Cost: $M+(\frac{M}{B-2}\times N)$</p>
</li>
<li>
<p>if $B-2&gt;M$, then cost: $M+N$</p>
</li>
<li>
<p>为啥nested loop join性能不行</p>
<ul>
<li>总要去遍历S表</li>
<li>为啥要遍历：<strong>没有索引等其他方案来提高查找S中属性的效率，所以只能傻瓜式的遍历</strong></li>
</ul>
</li>
<li>
<p>优化思路：提高S中查找/范围查找的速度</p>
</li>
<li>
<p><strong>Index Nested Loop Join</strong></p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="line"><span class="cl"><span class="k">foreach</span> <span class="n">tuple</span> <span class="n">r</span> <span class="k">in</span> <span class="n">R</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">foreach</span> <span class="n">tuple</span> <span class="n">S</span> <span class="k">in</span> <span class="n">Index</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">==</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">r</span> <span class="n">and</span> <span class="n">s</span> <span class="n">match</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">emit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>认为每次索引查询需要C次I/O</p>
</li>
<li>
<p>Cost: $M+(m\times C)$</p>
</li>
</ul>
<h3 id="sort-merge-join">Sort-Merge Join</h3>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter11-3.png" title="/img/CMU 15-445 Database Systems/chapter11-3.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter11-3.png" data-sub-html="<h2>先对Join的列进行排序，后面就是合并多个有序数组的思路</h2>">
        
    </a><figcaption class="image-caption">先对Join的列进行排序，后面就是合并多个有序数组的思路</figcaption>
    </figure>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter11-4.png" title="/img/CMU 15-445 Database Systems/chapter11-4.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter11-4.png" data-sub-html="<h2>匹配中可能会漏掉匹配项，必须要加上回退的功能</h2>">
        
    </a><figcaption class="image-caption">匹配中可能会漏掉匹配项，必须要加上回退的功能</figcaption>
    </figure>
<ul>
<li>
<p>Cost</p>
<ul>
<li>
<p>Sort R: $2M \times (1+\log_{B-1}\frac{M}{B})$</p>
</li>
<li>
<p>Sort S: $2N\times (1+\log_{B-1}\frac{N}{B})$</p>
</li>
<li>
<p>Merge Cost: $M+N$</p>
</li>
<li>
<p>Total Cost: $Sort + Merge$</p>
</li>
</ul>
</li>
<li>
<p>退化情况：两个连接列所有值一样，那么Merge Cost会因为回退增加到$M\times N$</p>
</li>
<li>
<p>适合的场景</p>
<ul>
<li>数据本身就有序</li>
<li>输出的结果需要排序</li>
</ul>
</li>
</ul>
<h3 id="hash-join">Hash Join</h3>
<ul>
<li>Hash table点查询比B+ Tree快
<ul>
<li>左表做hash，右表去匹配</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">build</span> <span class="nb">hash</span> <span class="n">table</span> <span class="n">HT_R</span> <span class="k">for</span> <span class="n">R</span>
</span></span><span class="line"><span class="cl"><span class="n">foreach</span> <span class="nb">tuple</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">S</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">h1</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">in</span> <span class="n">HT_R</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">output</span>
</span></span></code></pre></td></tr></table>
</div>
</div><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter11-5.png" title="/img/CMU 15-445 Database Systems/chapter11-5.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter11-5.png" data-sub-html="<h2>给左表做哈希表，右表的数据hash完成后去哈希表里面找匹配数据</h2>">
        
    </a><figcaption class="image-caption">给左表做哈希表，右表的数据hash完成后去哈希表里面找匹配数据</figcaption>
    </figure>
<ul>
<li>
<p>Hash</p>
<ul>
<li>Key:需要连接的列</li>
<li>Value
<ul>
<li>Full Tuple:放上需要的数据，不需要回表</li>
<li>Tuple Identifier:放索引，最后需要去回表拿数据</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>OPTIMIZATION</strong></p>
<ul>
<li>Create a probe filter (such as a Bloom Filter) during the build phase if the key is likely to not exist in the inner relation 加上一层过滤器先过滤掉部分没有匹配项的数据，防止在哈希表里面找半天发现没有，比如加一个布隆过滤器</li>
</ul>
</li>
<li>
<p>如果哈希表太大可能会面临内存池驱逐的问题，但是我们不想让内存池随机驱逐</p>
</li>
<li>
<p><strong>Grace Hash Join</strong></p>
<ul>
<li>
<p>1980’s东京大学搞数据库一体机的时候发明的（现在也有一体机，比如Oracle还在卖），银行和金融机构爱买</p>
</li>
<li>
<p>左表和右表都做hash，把哈希表存在硬盘里面，把硬盘里面相对应的哈希桶拿出来做nested loop join</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter11-6.png" title="/img/CMU 15-445 Database Systems/chapter11-6.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter11-6.png" data-sub-html="<h2>能连接上的行都在一个桶号里面，所以每次都加载两个哈希表里面相同桶号的桶</h2>">
        
    </a><figcaption class="image-caption">能连接上的行都在一个桶号里面，所以每次都加载两个哈希表里面相同桶号的桶</figcaption>
    </figure>
</li>
<li>
<p>如果哈希桶还是太大怎么办，再换别的哈希函数继续哈希，直到哈希出来的块够小（这个叫<strong>RECURSIVE PARTITIONING</strong>）</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter11-7.png" title="/img/CMU 15-445 Database Systems/chapter11-7.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter11-7.png" data-sub-html="<h2>RECURSIVE PARTITIONING</h2>">
        
    </a><figcaption class="image-caption">RECURSIVE PARTITIONING</figcaption>
    </figure>
</li>
</ul>
</li>
<li>
<p>Cost</p>
<ul>
<li>Partition Phash:$2(M+N)$(读到内存hash后还要写回去)</li>
<li>Probing Phash:$M+N$</li>
<li>Total:$3(M+N)$</li>
</ul>
</li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter11-8.png" title="/img/CMU 15-445 Database Systems/chapter11-8.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter11-8.png" data-sub-html="<h2>各方法开销</h2>">
        
    </a><figcaption class="image-caption">各方法开销</figcaption>
    </figure>
<ul>
<li>Sorting和Hash没有最好，要看条件选择
<ul>
<li>哈希碰撞，输出是否有序都会影响开销</li>
<li>优秀的数据库会有优化器来进行分析和选择</li>
</ul>
</li>
</ul>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #10: Sorting &amp; Aggregation Algorithms</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter10/</link>
    <pubDate>Thu, 11 Apr 2024 19:21:30 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter10/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-10-sorting--aggregation-algorithms">Lecture #10: Sorting &amp; Aggregation Algorithms</h2>
<h3 id="query-plan">Query Plan</h3>
<ul>
<li>
<p>从本节课开始将讨论DBMS的Operator Execution</p>
</li>
<li>
<p>优化器会把SQL变成一棵执行树，递归式的向上执行</p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter10-1.png" title="/img/CMU 15-445 Database Systems/chapter10-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter10-1.png" data-sub-html="<h2>执行树</h2>">
        
    </a><figcaption class="image-caption">执行树</figcaption>
    </figure>
<ul>
<li>本课DBMS的特点：内存没法一次处理全部数据，会OOM，往往需要把中间结果也给写回到磁盘，磁盘和内存要相互配合，要最大化利用连续I/O，减少随机I/O的压力</li>
</ul>
<h3 id="sorting">Sorting</h3>
<ul>
<li>
<p><strong>External merge sort</strong></p>
<ul>
<li>排的是硬盘里面的数据，而不是像往常那样排内存里面的数据</li>
<li>代表：MySQL</li>
<li>Phase #1 – Sorting: First, the algorithm sorts small chunks of data that fit in main memory, and then writes the sorted pages back to disk.</li>
<li>Phase #2 – Merge: Then, the algorithm combines the sorted runs into larger sorted runs.</li>
</ul>
</li>
<li>
<p>两种&lt;Key,Value&gt;的模式</p>
<ul>
<li>Early Materialization:&lt;Key,Tuple&gt;，直接存储的就是数据</li>
<li>Late Materialization:&lt;Key,Record id&gt;，需要回表</li>
</ul>
</li>
<li>
<p><strong>Two-way Merge Sort</strong></p>
<ul>
<li>N个页的大表，缓存池最多能承受B个页的容量</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter10-2.png" title="/img/CMU 15-445 Database Systems/chapter10-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter10-2.png" data-sub-html="<h2>把每页加载到内存后排序，然后把排序好的数据写回磁盘，最后再归并刚才写回磁盘的那些有序页</h2>">
        
    </a><figcaption class="image-caption">把每页加载到内存后排序，然后把排序好的数据写回磁盘，最后再归并刚才写回磁盘的那些有序页</figcaption>
    </figure></li>
<li>排序好的数据不是全部一把进到内存（那又该爆内存了，可以轮询着进，因为合并有序数组本来就是轮询比较的（参考力扣里面的题目））</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter10-3.png" title="/img/CMU 15-445 Database Systems/chapter10-3.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter10-3.png" data-sub-html="<h2>多个页的情况</h2>">
        
    </a><figcaption class="image-caption">多个页的情况</figcaption>
    </figure></li>
<li>优化：一次I/O不要只读一页，尽最大可能多读几页</li>
</ul>
</li>
<li>
<p><strong>General (K-way) Merge Sort</strong></p>
<ul>
<li>二路归并变成K路归并，一次比如读N/B个页，然后进行排序，Merge的轮数会少很多，这样效率会提高很多</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Using B+Trees</strong>
<ul>
<li>直接利用B+ Tree的有序性</li>
<li>要考虑聚簇还是非聚簇，因为聚簇的话关系到Early Materialization的问题，可以省去回表的过程，提高效率</li>
</ul>
</li>
</ul>
<h3 id="aggregations">Aggregations</h3>
<ul>
<li>
<p><strong>Sorting</strong></p>
<ul>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter10-4.png" title="/img/CMU 15-445 Database Systems/chapter10-4.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter10-4.png" data-sub-html="<h2>过滤，排序，去重</h2>">
        
    </a><figcaption class="image-caption">过滤，排序，去重</figcaption>
    </figure></li>
</ul>
</li>
<li>
<p><strong>Hashing</strong></p>
<ul>
<li>
<p>如果不要求有序可以用Hashing来提高效率</p>
</li>
<li>
<p><strong>External Hashing aggregations</strong></p>
</li>
<li>
<p><strong>Phase #1 – Partition</strong></p>
<ul>
<li>先给要Agg的字段做一个哈希表，然后把这个哈希表写回到磁盘里面</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter10-5.png" title="/img/CMU 15-445 Database Systems/chapter10-5.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter10-5.png" data-sub-html="<h2>把需要Agg的字段做第一次哈希，相同的值&#43;碰撞的都放在一个桶</h2>">
        
    </a><figcaption class="image-caption">把需要Agg的字段做第一次哈希，相同的值+碰撞的都放在一个桶</figcaption>
    </figure></li>
</ul>
</li>
<li>
<p><strong>Phase #2 – ReHash</strong>:把磁盘里面的哈希表再加载到内存中，读进去之后再做第二次哈希，这样就把碰撞的值也分开了，这样就生成了第二次的哈希表，也就是最终结果</p>
<ul>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter10-6.png" title="/img/CMU 15-445 Database Systems/chapter10-6.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter10-6.png" data-sub-html="<h2>二次哈希解决了哈希碰撞，也就拿到了最终结果</h2>">
        
    </a><figcaption class="image-caption">二次哈希解决了哈希碰撞，也就拿到了最终结果</figcaption>
    </figure></li>
</ul>
</li>
<li>
<p><strong>Hashing summarization</strong></p>
<ul>
<li>During the rehash phase, store pairs of the form (GroupKey→RunningVal) 如果说需要对值进行计算(count,sum等)，那么在hash的过程中也要带上其他需要的数值，这部分叫RunningVal</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter10-7.png" title="/img/CMU 15-445 Database Systems/chapter10-7.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter10-7.png" data-sub-html="<h2>带上需要的数据进行聚合类函数的计算</h2>">
        
    </a><figcaption class="image-caption">带上需要的数据进行聚合类函数的计算</figcaption>
    </figure></li>
</ul>
</li>
</ul>
</li>
<li>
<p>Sorting和Hashing没有绝对的好，要看条件，比如前置的数据有没有做了排序或者哈希，需要的结果到底要不要进行排序</p>
</li>
<li>
<p>优化的思路</p>
<ul>
<li>随机I/O尽量变成连续I/O:一次写入页的数量尽量多</li>
<li>预加载:能先加载到内存中的数据都先加载到内存中</li>
</ul>
</li>
</ul>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #09: Index Concurrency Control</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter9/</link>
    <pubDate>Thu, 11 Apr 2024 13:34:01 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter9/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-09-index-concurrency-control">Lecture #09: Index Concurrency Control</h2>
<h3 id="index-concurrency-control">Index Concurrency Control</h3>
<ul>
<li>
<p>前面讨论都默认是单线程条件下，但是对于DBMS这种主要问题在I/O上面的系统来说，肯定要上多线程，异步这些来提高效率，那么如何在这种条件下保证索引的线程安全很重要了</p>
</li>
<li>
<p>其他数据库的一些处理方法</p>
<ul>
<li>内存型NoSQL:直接单线程模式运行，比如Redis</li>
</ul>
</li>
<li>
<p>本节课主要研究<strong>Physical Correctness</strong>，关注底层设计</p>
</li>
</ul>
<h3 id="locks-vs-latches">Locks vs. Latches</h3>
<ul>
<li>和前面的课讨论的一样，一个逻辑锁，一个底层锁</li>
<li>死锁和回滚都是建立在Locks上面的</li>
<li>Latches这个锁要划分为读锁和写锁
<ul>
<li>多个线程可以同时去读一个变量，相应的读锁可以重入其他线程的读锁，但是其他线程不能写(也叫共享锁)</li>
<li>一个线程写数据的时候，其他线程不能读和写这个数据，所以写锁一般不可重入其他线程的锁(也叫独占锁)</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter9-1.png" title="/img/CMU 15-445 Database Systems/chapter9-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter9-1.png" data-sub-html="<h2>Locks和Latches的区别</h2>">
        
    </a><figcaption class="image-caption">Locks和Latches的区别</figcaption>
    </figure>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter9-1.png" title="/img/CMU 15-445 Database Systems/chapter9-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter9-1.png" data-sub-html="<h2>兼容矩阵</h2>">
        
    </a><figcaption class="image-caption">兼容矩阵</figcaption>
    </figure>
<h3 id="latch-implementations">Latch Implementations</h3>
<ul>
<li><strong>Blocking OS Mutex</strong>
<ul>
<li>simple to use(操作系统自己支持)</li>
<li>Non-scalable (about 25ns per lock/unlock invocation)，大规模使用不行，这东西效率太低</li>
<li>Example: std::mutex$\rightarrow$pthread_mutex$\rightarrow$futex</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">m</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Do something special...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">m</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>底层实现:内存中分配出来一个变量来获取锁，要锁的程序就把这个变量设置值，如果发现锁被夺取，这个线程就直接进入内核态自己sleep，如果锁被释放操作系统会试着唤醒sleep的线程
<ul>
<li>好处：竞争的线程拿不到锁直接sleep，不会额外消耗系统的资源</li>
<li>坏处：sleep和notify在操作系统层面上面很浪费资源（线程链表的调整）</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Test-and-Set Spin Latch (TAS)</strong></li>
<li>也叫自旋锁</li>
<li>Very efficient (single instruction to latch/unlatch)</li>
<li>Non-scalable, not cache friendly, not OS friendly.大规模用效率上也不行，自旋也很笨</li>
<li>Example: std::atomic&lt;T&gt;</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">atomic_flag</span> <span class="n">latch</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">while</span> <span class="p">(</span><span class="n">latch</span><span class="p">.</span><span class="n">test_and_set</span><span class="p">(</span><span class="err">…</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// Retry? Yield? Abort?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>检测和设置这一组操作必须要是原子的</p>
</li>
<li>
<p>自旋锁对于CPU的开销很大（一直空转）</p>
</li>
<li>
<p>很多语言会把TAS和Blocking结合，自旋一阵子不行就去睡一会</p>
</li>
</ul>
<hr>
<ul>
<li><strong>Atomic Instruction Example: compare-and-swap (CAS)</strong>
<ul>
<li>
<p>Atomic instruction that compares contents of a memory location M to a given value V</p>
<ul>
<li>If values are equal, installs new given value V’ in M</li>
<li>Otherwise, operation fails</li>
</ul>
</li>
<li>
<p>这个东西是CPU的一条指令，由CPU来保证原子性</p>
</li>
<li>
<p>经常作为自旋锁或者JUC的包里面的一些锁底层的实现</p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Reader-Writer Latches</strong>
<ul>
<li>Allows for concurrent readers. Must manage read/write queues to avoid starvation.</li>
<li>Can be implemented on top of spinlocks</li>
<li>Example: std::shared_mutex $\rightarrow$ pthread_rwlock</li>
</ul>
</li>
</ul>
<h3 id="hash-table-latching">Hash Table Latching</h3>
<ul>
<li>
<p>好加锁，无论是桶还是开放地址哈希，大家查找的方向是一致的，并且一次只能访问一个页/槽，这点上出不了死锁(当然HashMap的头插法可能会出，不过这个和链表的结构有关)，向其他搜索方向不一致的B+ Tree可能就会出死锁</p>
</li>
<li>
<p>如果要调整容量，一般把整个哈希表都给加上全局的写锁</p>
</li>
<li>
<p>其他情况下一般锁部分就可以了</p>
<ul>
<li>
<p><strong>Page/Block-level Latches</strong></p>
<ul>
<li>Each page/block has its own reader-writer latch that protects its entire contents.</li>
<li>Threads acquire either a read or write latch before they access a page/block</li>
<li>按块划分，加锁</li>
<li>Java的ConcurrentHashMap是这种处理方案，几个槽一个锁</li>
<li>好处：不用维护太多锁，还保证了并发性</li>
</ul>
</li>
<li>
<p><strong>Slot Latches</strong></p>
<ul>
<li>一个槽加一个锁</li>
<li>锁更细了，更能避免死锁和提高并发</li>
<li>但是维护这么多锁开销太高了</li>
</ul>
</li>
<li>
<p>还有其他方法，比如读写分离（比如go的sync.Map）</p>
</li>
</ul>
</li>
</ul>
<h3 id="btree-latching">B+Tree Latching</h3>
<ul>
<li>两方面的并发问题
<ul>
<li>节点内部的数据要做并发保护</li>
<li>节点的分裂/合并过程中要做并发保护</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p><strong>Latch Crabbing/Coupling</strong></p>
<ul>
<li>
<p>Get latch for parent，给根节点上锁</p>
</li>
<li>
<p>Get latch for child，给子节点上锁</p>
</li>
<li>
<p>Release latch for parent if “safe”，判断子节点是否“安全”，安全的话放根节点的锁</p>
</li>
<li>
<p>“safe”:A <strong>safe node</strong> is one that will not split or merge when updated.</p>
</li>
</ul>
</li>
<li>
<p>Find: Start at root and traverse down the tree</p>
<ul>
<li>Acquire R latch on child</li>
<li>Then unlatch parent</li>
<li>Repeat until we reach the leaf node</li>
</ul>
</li>
<li>
<p>Insert/Delete: Start at root and go down, obtaining W latches as needed. Once child is latched, check if it is safe:</p>
<ul>
<li>If child is safe, release all latches on ancestors</li>
</ul>
</li>
<li>
<p>问题：所有的操作都要先锁根节点，这是一个性能上面的瓶颈</p>
<ul>
<li>原因：上面的想法是悲观的，认为每次写操作都有可能会造成根节点的分裂/合并，但是实际上来说根节点变动的次数很少</li>
<li>使用乐观的想法：我认为大部分操作不会改变根节点的结构，所以我给根节点加读锁，如果说发现根节点要变动结构，这个时候从根节点重新给加写锁</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Leaf Node Scans</strong>
<ul>
<li>一般来说是顺序扫描</li>
<li>但是这样会带来一个风险:Find key &gt; 4和Find key &lt; 1扫描叶子节点的时候方向是相反的，会有死锁的风险</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter9-3.png" title="/img/CMU 15-445 Database Systems/chapter9-3.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter9-3.png" data-sub-html="<h2>方向相反造成死锁</h2>">
        
    </a><figcaption class="image-caption">方向相反造成死锁</figcaption>
    </figure></li>
<li>解决方法：<strong>制定规则</strong>，比如数据只能从大往小走，比如MySQL，之前不支持倒序遍历就和这个有关，后面又加上了倒叙索引才解决了这个问题</li>
</ul>
</li>
</ul>
]]></description>
</item>
</channel>
</rss>
