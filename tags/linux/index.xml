<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Linux - 标签 - Jungle&#39;s Blog</title>
        <link>https://Jungle430.github.io/tags/linux/</link>
        <description>Linux - 标签 - Jungle&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>1239946358@qq.com (Jungle)</managingEditor>
            <webMaster>1239946358@qq.com (Jungle)</webMaster><lastBuildDate>Sat, 04 Mar 2023 15:47:02 &#43;0800</lastBuildDate><atom:link href="https://Jungle430.github.io/tags/linux/" rel="self" type="application/rss+xml" /><item>
    <title>Linux x86 Program Start Up or - How the heck do we get to main()?</title>
    <link>https://Jungle430.github.io/posts/operating-system/support2/</link>
    <pubDate>Sat, 04 Mar 2023 15:47:02 &#43;0800</pubDate><author>1239946358@qq.com (Jungle)</author><guid>https://Jungle430.github.io/posts/operating-system/support2/</guid>
    <description><![CDATA[<h2 id="概述">概述</h2>
<ul>
<li>
<p>文章介绍了X86系统main函数调用前后的一些细节，并阐述了C程序的<b>构造函数</b>和<b>析构函数</b>，<u>以及<code>.init</code>,<code>.fini</code>,<code>init_array</code>和<code>fini_array</code>各section相对于main函数及彼此的执行顺序。遗憾的是这篇文章是基于32位CPU架构来研究的</u></p>
</li>
<li>
<p>文章对$debug$ <code>main</code>函数之前的代码有一定的帮助效果</p>
</li>
<li>
<p>主要介绍了X86 ELF文件的动态加载过程</p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/Operating%20System/support2-1.png" title="/img/Operating System/support2-1.png" data-thumbnail="/img/Operating System/support2-1.png" data-sub-html="<h2>总体流程图</h2>">
        
    </a><figcaption class="image-caption">总体流程图</figcaption>
    </figure>
<h2 id="调用过程分析">调用过程分析</h2>
<h3 id="main函数的调用">main函数的调用</h3>
<ul>
<li>先写一个最简单的C程序prog1.c</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>编译一下</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">gcc -ggdb -o prog1 prog1.c
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>注：<code>-ggdb</code>的选项作用：生成<code>gdb</code>专用的调试信息，会有一些<code>gdb</code>专用的扩展</p>
</blockquote>
<ul>
<li>然后我们用objdump做一下反汇编</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">objdump -d prog1 &gt; prog1.asm
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="从我们终端敲回车到程序被载入执行的过程中发生了什么">从我们终端敲回车到程序被载入执行的过程中发生了什么？</h4>
<ul>
<li>当我们从终端输入要运行的程序或者是从有关的<code>gui</code>界面点击相关的button的时候，<b>shell</b>或者<b>gui</b>就会调用<code>execve()</code>。这里不是我们重点关心的地方，简单来说，execve()会设立一个栈，然后将参数<code>argc</code>，<code>argv</code>和<code>envp</code>压入栈中。文件描述符0，1，2（stdin, stdout和stderr）由之前的shell设置，加载器会帮我们完成有关重定位的许多工作，当所有搞定之后，控制权会传递给<code>_start()</code></li>
</ul>
<figure><a class="lightgallery" href="/img/Operating%20System/support2-2.png" title="/img/Operating System/support2-2.png" data-thumbnail="/img/Operating System/support2-2.png" data-sub-html="<h2>shell输入man execve之后的函数声明和所在位置</h2>">
        
    </a><figcaption class="image-caption">shell输入<code>man execve</code>之后的函数声明和所在位置</figcaption>
    </figure>
<h4 id="_start">_start()</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">080482e0 &lt;_start&gt;:
</span></span><span class="line"><span class="cl">80482e0:       31 ed                   xor    %ebp,%ebp
</span></span><span class="line"><span class="cl">80482e2:       5e                      pop    %esi
</span></span><span class="line"><span class="cl">80482e3:       89 e1                   mov    %esp,%ecx
</span></span><span class="line"><span class="cl">80482e5:       83 e4 f0                and    $0xfffffff0,%esp
</span></span><span class="line"><span class="cl">80482e8:       50                      push   %eax
</span></span><span class="line"><span class="cl">80482e9:       54                      push   %esp
</span></span><span class="line"><span class="cl">80482ea:       52                      push   %edx
</span></span><span class="line"><span class="cl">80482eb:       68 00 84 04 08          push   $0x8048400
</span></span><span class="line"><span class="cl">80482f0:       68 a0 83 04 08          push   $0x80483a0
</span></span><span class="line"><span class="cl">80482f5:       51                      push   %ecx
</span></span><span class="line"><span class="cl">80482f6:       56                      push   %esi
</span></span><span class="line"><span class="cl">80482f7:       68 94 83 04 08          push   $0x8048394
</span></span><span class="line"><span class="cl">80482fc:       e8 c3 ff ff ff          call   80482c4 &lt;__libc_start_main@plt&gt;
</span></span><span class="line"><span class="cl">8048301:       f4                      hlt
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>任何值<code>xor</code>自身得到的结果都是0。所以<code>xor %ebp,%ebp</code>语句会把<code>%ebp</code>设置为0。ABI（Application Binary Interface specification）推荐这么做，目的是为了标记最外层函数的页帧（frame）</li>
<li>接下来，从栈中弹出栈顶的值保存到<code>%esi</code>。在最开始的时候我们把<code>argc</code>，<code>argv</code>和<code>envp</code>放到了栈里，所以现在的<code>pop</code>语句会把<code>argc</code>放到<code>%esi</code>中</li>
<li>这里只是临时保存一下，稍后我们会把它再次压回栈中</li>
<li>因为我们弹出了<code>argc</code>，所以<code>%ebp</code>现在指向的是<code>argv</code>。<code>mov</code>指令把<code>argv</code>放到了<code>%ecx</code>中，但是并没有移动栈指针</li>
<li><u>然后，将栈指针和一个可以清除后四位的掩码做<code>and</code>操作。根据当前栈指针的位置不同，栈指针将会向下移动0到15个字节。这么做，保证了任何情况下，栈指针都是16字节的偶数倍对齐的。对齐的目的是保证栈上所有的变量都能够被内存和cache快速的访问</u></li>
<li><u>要求这么做的是SSE，就是指令都能在单精度浮点数组上工作的那个<b>（扩展指令集）</b></u></li>
<li>例子：某次运行时，<code>_start</code>函数刚被调用的时候，<code>%esp</code>处于<code>0xbffff770</code>。在我们从栈上弹出<code>argc</code>后，<code>%esp</code>指向<code>0xbffff774</code>。它向高地址移动了（栈向下增长）。当对栈指针执行了<code>and</code>操作后，栈指针回到了<code>0xbffff770</code></li>
</ul>
<h4 id="__libc_start_main">__libc_start_main</h4>
<ul>
<li>现在，我们把<code>__libc_start_main</code>函数的参数压入栈中。第一个参数<code>%eax</code>被压入栈中，里面保存了无效信息，原因是稍后会有七个参数将被压入栈中，但是为了保证16字节对齐，所以需要第八个参数。这个值也并不会被用到。<code>__libc_start_main</code>是在链接的时候从glibc复制过来的。在glibc的代码中，它位于<code>csu/libc-start.c</code>文件里。<code>__libc_start_main</code>的定义如下</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">__libc_start_main</span><span class="p">(</span>  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">main</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="o">*</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="o">*</span> <span class="n">ubp_av</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">init</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fini</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">rtld_fini</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                <span class="kt">void</span> <span class="p">(</span><span class="o">*</span> <span class="n">stack_end</span><span class="p">));</span>
</span></span></code></pre></td></tr></table>
</div>
</div><figure><a class="lightgallery" href="/img/Operating%20System/support2-3.jpg" title="/img/Operating System/support2-3.jpg" data-thumbnail="/img/Operating System/support2-3.jpg" data-sub-html="<h2>参数说明</h2>">
        
    </a><figcaption class="image-caption">参数说明</figcaption>
    </figure>
<ul>
<li>__libc_csu_fini函数也是从glibc被链接进我们代码的，它的源代码位于csu/elf-init.c中</li>
</ul>
<h4 id="环境变量哪里去了">环境变量哪里去了？</h4>
<ul>
<li>
<p>我们并没有获取envp（栈里指向我们环境变量的指针）？它并不是<code>__libc_start_main</code>函数的参数。但是我们知道main函数的原型其实是<code>int main(int argc, char** argv, char** envp)</code>。所以，到底怎么回事？</p>
</li>
<li>
<p>其实，<code>__libc_start_main</code>函数会调用<code>__libc_init_first</code>，这个函数会使用内部信息去找到环境变量（实际上环境变量就位于<code>argv</code>的终止字符null的后面），然后设置一个全局变量<code>__environ</code>，这个全局变量可以被<code>__libc_start_main</code>函数内部任何地方使用，包括调用main函数时。当<code>envp</code>建立了之后，<code>__libc_start_main</code>函数会使用相同的小技巧，越过envp数组之后的<code>NULL</code>字符，获取另一个向量——ELF辅助向量（加载器使用它给进程传递一些信息）</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">__libc_init_first</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">arg0</span><span class="p">,</span> <span class="p">...)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arg0</span><span class="p">,</span> <span class="o">**</span><span class="n">envp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">argv</span><span class="p">[</span><span class="n">argc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">__environ</span> <span class="o">=</span> <span class="n">envp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">__libc_init</span> <span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">envp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>运行程序前，设置环境变量<code>LD_SHOW_AUXV=1</code>,可以查看里面的内容</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ <span class="nv">LD_SHOW_AUXV</span><span class="o">=</span><span class="m">1</span> ./prog1
</span></span><span class="line"><span class="cl">AT_SYSINFO:      0xe62414
</span></span><span class="line"><span class="cl">AT_SYSINFO_EHDR: 0xe62000
</span></span><span class="line"><span class="cl">AT_HWCAP:    fpu vme de pse tsc msr pae mce cx8 apic
</span></span><span class="line"><span class="cl">             mtrr pge mca cmov pat pse36 clflush dts
</span></span><span class="line"><span class="cl">             acpi mmx fxsr sse sse2 ss ht tm pbe
</span></span><span class="line"><span class="cl">AT_PAGESZ:       <span class="m">4096</span>
</span></span><span class="line"><span class="cl">AT_CLKTCK:       <span class="m">100</span>
</span></span><span class="line"><span class="cl">AT_PHDR:         0x8048034
</span></span><span class="line"><span class="cl">AT_PHENT:        <span class="m">32</span>
</span></span><span class="line"><span class="cl">AT_PHNUM:        <span class="m">8</span>
</span></span><span class="line"><span class="cl">AT_BASE:         0x686000
</span></span><span class="line"><span class="cl">AT_FLAGS:        0x0
</span></span><span class="line"><span class="cl">AT_ENTRY:        0x80482e0
</span></span><span class="line"><span class="cl">AT_UID:          <span class="m">1002</span>
</span></span><span class="line"><span class="cl">AT_EUID:         <span class="m">1002</span>
</span></span><span class="line"><span class="cl">AT_GID:          <span class="m">1000</span>
</span></span><span class="line"><span class="cl">AT_EGID:         <span class="m">1000</span>
</span></span><span class="line"><span class="cl">AT_SECURE:       <span class="m">0</span>
</span></span><span class="line"><span class="cl">AT_RANDOM:       0xbff09acb
</span></span><span class="line"><span class="cl">AT_EXECFN:       ./prog1
</span></span><span class="line"><span class="cl">AT_PLATFORM:     i686
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>各种各样的信息。<code>AT_ENTRY</code>是<code>_start</code>的地址，还有我们的UID、有效UID和GID</p>
</li>
<li>
<p><b>__libc_start_main功能总结</b></p>
<ul>
<li>处理关于setuid、setgid程序的安全问题</li>
<li>启动线程</li>
<li>把<code>fini</code>函数和<code>rtld_fini</code>函数作为参数传递给<code>at_exit</code>调用，使它们在<code>at_exit</code>里被调用，从而完成用户程序和加载器的调用结束之后的清理工作</li>
<li>调用其<code>init</code>参数</li>
<li>调用<code>main</code>函数，并把<code>argc</code>和<code>argv</code>参数、环境变量传递给它</li>
<li>调用<code>exit</code>函数，并将main函数的返回值传递给它</li>
</ul>
</li>
</ul>
<h4 id="__libc_csu_init">__libc_csu_init</h4>
<ul>
<li><code>__libc_start_main</code>函数的<code>init</code>参数被设置成了<code>__libc_csu_init</code>函数，它也是被链接进我们代码的。它来源于glibc源代码中的csu/elf-init.c。其C代码如下（原代码只不过多了一些#ifdef）：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">__libc_csu_init</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">_init</span> <span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">__init_array_end</span> <span class="o">-</span> <span class="n">__init_array_start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="p">(</span><span class="o">*</span><span class="n">__init_array_start</span> <span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">envp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>功能：<b>用户应用程序的构造函数</b></p>
</li>
<li>
<p><code>__libc_csu_init</code>函数相当重要，因为它是我们<b>可执行程序的构造函数</b></p>
<ul>
<li>？？？这不是C++，哪里来的构造函数？？？ $\Longrightarrow$ 构造函数和析构函数的概念并非属于C++，它诞生早于C++</li>
<li>对于任意的可执行程序都可以有一个C函数的<b>构造函数</b><code>__libc_csu_init</code>和C函数的<b>析构函数</b><code>__libc_csu_fini</code>。<u>在构造函数内部，可执行程序会找到全局C函数组成的构造函数集，并且调用它们</u>。（任何一个C程序都是可以有构造函数集的） $\Longrightarrow$ <u>the executable will look for global C level constructors and call any that it finds. It&rsquo;s possible for a C program to also have these</u>（原文）</li>
</ul>
</li>
<li>
<p><code>__libc_csu_init</code>函数的反汇编代码</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">080483a0 &lt;__libc_csu_init&gt;:
</span></span><span class="line"><span class="cl"> 80483a0:       55                      push   %ebp
</span></span><span class="line"><span class="cl"> 80483a1:       89 e5                   mov    %esp,%ebp
</span></span><span class="line"><span class="cl"> 80483a3:       57                      push   %edi
</span></span><span class="line"><span class="cl"> 80483a4:       56                      push   %esi
</span></span><span class="line"><span class="cl"> 80483a5:       53                      push   %ebx
</span></span><span class="line"><span class="cl"> 80483a6:       e8 5a 00 00 00          call   8048405 &lt;__i686.get_pc_thunk.bx&gt;
</span></span><span class="line"><span class="cl"> 80483ab:       81 c3 49 1c 00 00       add    $0x1c49,%ebx
</span></span><span class="line"><span class="cl"> 80483b1:       83 ec 1c                sub    $0x1c,%esp
</span></span><span class="line"><span class="cl"> 80483b4:       e8 bb fe ff ff          call   8048274 &lt;_init&gt;
</span></span><span class="line"><span class="cl"> 80483b9:       8d bb 20 ff ff ff       lea    -0xe0(%ebx),%edi
</span></span><span class="line"><span class="cl"> 80483bf:       8d 83 20 ff ff ff       lea    -0xe0(%ebx),%eax
</span></span><span class="line"><span class="cl"> 80483c5:       29 c7                   sub    %eax,%edi
</span></span><span class="line"><span class="cl"> 80483c7:       c1 ff 02                sar    $0x2,%edi
</span></span><span class="line"><span class="cl"> 80483ca:       85 ff                   test   %edi,%edi
</span></span><span class="line"><span class="cl"> 80483cc:       74 24                   je     80483f2 &lt;__libc_csu_init+0x52&gt;
</span></span><span class="line"><span class="cl"> 80483ce:       31 f6                   xor    %esi,%esi
</span></span><span class="line"><span class="cl"> 80483d0:       8b 45 10                mov    0x10(%ebp),%eax
</span></span><span class="line"><span class="cl"> 80483d3:       89 44 24 08             mov    %eax,0x8(%esp)
</span></span><span class="line"><span class="cl"> 80483d7:       8b 45 0c                mov    0xc(%ebp),%eax
</span></span><span class="line"><span class="cl"> 80483da:       89 44 24 04             mov    %eax,0x4(%esp)
</span></span><span class="line"><span class="cl"> 80483de:       8b 45 08                mov    0x8(%ebp),%eax
</span></span><span class="line"><span class="cl"> 80483e1:       89 04 24                mov    %eax,(%esp)
</span></span><span class="line"><span class="cl"> 80483e4:       ff 94 b3 20 ff ff ff    call   *-0xe0(%ebx,%esi,4)
</span></span><span class="line"><span class="cl"> 80483eb:       83 c6 01                add    $0x1,%esi
</span></span><span class="line"><span class="cl"> 80483ee:       39 fe                   cmp    %edi,%esi
</span></span><span class="line"><span class="cl"> 80483f0:       72 de                   jb     80483d0 &lt;__libc_csu_init+0x30&gt;
</span></span><span class="line"><span class="cl"> 80483f2:       83 c4 1c                add    $0x1c,%esp
</span></span><span class="line"><span class="cl"> 80483f5:       5b                      pop    %ebx
</span></span><span class="line"><span class="cl"> 80483f6:       5e                      pop    %esi
</span></span><span class="line"><span class="cl"> 80483f7:       5f                      pop    %edi
</span></span><span class="line"><span class="cl"> 80483f8:       5d                      pop    %ebp
</span></span><span class="line"><span class="cl"> 80483f9:       c3                      ret
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="这个函数都做了什么">这个函数都做了什么？</h5>
<h6 id="get_pc_truck函数">get_pc_truck函数</h6>
<ul>
<li>该函数是给位置无关码使用的。设置它们可以让位置无关码正常工作。为了让它们工作，基址寄存器（%ebp）需要知道<code>GLOBAL_OFFSET_TABLE</code>。其部分代码如下</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">push %ebx
</span></span><span class="line"><span class="cl">call __get_pc_thunk_bx
</span></span><span class="line"><span class="cl">add  $_GLOBAL_OFFSET_TABLE_,%ebx
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">__get_pc_thunk_bx:
</span></span><span class="line"><span class="cl">movel (%esp),%ebx
</span></span><span class="line"><span class="cl">return
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>过程分析</p>
<ul>
<li>
<p>调用<code>__get_pc_thunk_bx</code>时，像所有其他函数调用一样，将下一条指令的地址压入栈中（计组：保存上一级程序的<b>PC</b>）。这样，当函数返回时，就会继续执行下条指令</p>
</li>
<li>
<p>在<code>__get_pc_thunk_bx</code>中，我们将返回地址从栈中复制到<code>%ebx</code>中。当返回的时候，下条指令会把<code>_GLOBAL_OFFSET_TABLE_</code>加到<code>%ebx</code>上去（前3句）</p>
</li>
<li>
<p>其中<code>_GLOBAL_OFFSET_TABLE_</code>代表了当前地址和位置无关码使用的<code>GOT(global offset table)</code>的差值</p>
</li>
<li>
<p>在<code>GOT</code>中保存了我们想访问的变量的指针的集合，<b>并且我们只需要知道数据在这个表中的偏移量就行</b></p>
</li>
<li>
<p>加载器会为我们修改这个表里面的地址。对于函数来讲，也有一个类似的表（PLT）</p>
</li>
<li>
<p><u>汇编里面这么编写实在是太烦人了，但是，在C或者C++中，你可以将-pic参数传递给编译器，它将会自动帮你完成这个工作</u><b>（你知道你不用关心这个事情就可以了（md就怕自己再™️钻牛角尖））</b></p>
</li>
</ul>
</li>
<li>
<p>和64位有关的区别</p>
</li>
</ul>
<blockquote>
<p><em>上述·get_pc_truck·函数的主要目的其实是获取变量对应的GOT，以通过它获取变量真正的值。之所以这么写，是因为在32位系统里，没有类似于rip的寄存器，因此并不能直接获取当前指令的地址，而在64位系统里就不用这种小技巧了</em></p>
<ul>
<li>
<p>有关阅读</p>
<ul>
<li>
<p><a href="https://blog.csdn.net/mw_nice/article/details/100022610" target="_blank" rel="noopener noreffer">《Linux中的GOT和PLT到底是个啥？》</a> （原来的博客寄了，在CSDN找到了转载）</p>
</li>
<li>
<p><a href="https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html" target="_blank" rel="noopener noreffer">《PLT and GOT - the key to code sharing and dynamic libraries》</a> （英文原文）</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h6 id="剩下的循环在干什么">剩下的循环在干什么？</h6>
<ul>
<li>现在我们只要记住：<b>翻译的不好，这里建议看原文</b></li>
</ul>
<blockquote>
<p>For now, just remember that it calls any C level initializers for our program.</p>
</blockquote>
<p>中文翻译版：</p>
<blockquote>
<p><b>它调用了用户程序中所有用C代码编写的<code>initializers</code></b></p>
</blockquote>
<ul>
<li>中文这个版本容易让人看跑了，这个C代码不一定是自己编写的，只要是<b>C level</b>级别的<b>initializers</b>（后面有预处理，链接，中译容易让人看跑）</li>
</ul>
<h4 id="_init函数分析">_init函数分析</h4>
<h5 id="调用">调用</h5>
<ul>
<li>当加载器将控制权交给<code>_start</code>函数之后，<code>_start</code>函数将会调用<code>__libc_start_main</code>函数，<code>__libc_start_main</code>函数会调用<code>__libc_csu_init</code>函数, <code>__libc_csu_init</code>函数会调用<code>_init</code>函数</li>
</ul>
<div class="details admonition tip open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-lightbulb fa-fw"></i>Update<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><p>End in 2023-03-08 0:44</p>
<p>这种真🐔8️⃣👨的文章真是看点就看不下去了，明天概率论，先睡</p>
<p>某<a href="https://daonan233.github.io" target="_blank" rel="noopener noreffer">55</a>今天玩了5h ⚪，晚上卸载之后🎠自己是<b>S</b>🅱️，只能说是dinner行为了吧</p>
</div>
        </div>
    </div>
<h2 id="相关参考资料">相关参考资料</h2>
<ul>
<li>参考文章
<ul>
<li>
<p><a href="http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html" target="_blank" rel="noopener noreffer">《Linux x86 Program Start Up or - How the heck do we get to main()? by Patrick Horgan》</a></p>
</li>
<li>
<p><a href="https://luomuxiaoxiao.com/?p=516" target="_blank" rel="noopener noreffer">《Linux X86 程序启动 – main函数是如何被执行的？——落木萧萧的博客》</a>（已与作者沟通，同意部分转载）</p>
</li>
<li>
<p><a href="https://www.gnu.org/software/hurd/glibc/startup.html" target="_blank" rel="noopener noreffer">《How libc startup in a process works》</a></p>
</li>
</ul>
</li>
</ul>
]]></description>
</item>
</channel>
</rss>
