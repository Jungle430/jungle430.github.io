<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Database Systems - 标签 - Jungle&#39;s Blog</title>
        <link>https://Jungle430.github.io/tags/database-systems/</link>
        <description>Database Systems - 标签 - Jungle&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>junglece430@gmail.com (Jungle)</managingEditor>
            <webMaster>junglece430@gmail.com (Jungle)</webMaster><lastBuildDate>Mon, 15 Apr 2024 12:47:46 &#43;0800</lastBuildDate><atom:link href="https://Jungle430.github.io/tags/database-systems/" rel="self" type="application/rss+xml" /><item>
    <title>CMU 15-445 Lecture #15: Query Planning &amp; Optimization</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter15/</link>
    <pubDate>Mon, 15 Apr 2024 12:47:46 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter15/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-15-query-planning--optimization">Lecture #15: Query Planning &amp; Optimization</h2>
<ul>
<li>数据库最复杂的模块之一，论文都在这个上面做功夫</li>
</ul>
<h3 id="overview">Overview</h3>
<ul>
<li>
<p>SQL都是声明式的，没有告诉DBMS执行的过程</p>
</li>
<li>
<p>需要优化器来根据SQL告诉DBMS具体怎么执行</p>
</li>
<li>
<p>两种流派</p>
<ul>
<li>SQL+优化器</li>
<li>大数据处理框架(flink,spark)+程序员</li>
</ul>
</li>
<li>
<p>优化的两种流派</p>
<ul>
<li>Heuristics/Rules
<ul>
<li>启发式，通过查看catalog来看表的结构/有无索引，从而进行优化</li>
</ul>
</li>
<li>Cost-base Search
<ul>
<li>基于代价的：要估计每一个查询plan的变化，然后进行决策，要知道数据的情况</li>
</ul>
</li>
<li>大部分的数据库会结合这两个流派</li>
</ul>
</li>
<li>
<p><strong>Logical vs. Physical Plans</strong></p>
<ul>
<li>逻辑计划都是关系代数级别的</li>
<li>物理计划具体到怎么执行，比如算子怎么执行，是sort join还是hash join</li>
</ul>
</li>
<li>
<p>计划的优化是NP难度级别的问题，这门课就是讲的普及</p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter15-1.png" title="/img/CMU 15-445 Database Systems/chapter15-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter15-1.png" data-sub-html="<h2>例子：逻辑等价优化</h2>">
        
    </a><figcaption class="image-caption">例子：逻辑等价优化</figcaption>
    </figure>
<h3 id="logical-query-optimization">Logical Query Optimization</h3>
<ul>
<li>
<p>自己要写一些模式上面的规则，让优化器拿着规则去优化，比如JOIN怎么消除，怎么做索引下推</p>
</li>
<li>
<p>缺点：只能根据规则进行逻辑计划的转换，但是不能根据代价开销去进行优化，很死板</p>
</li>
<li>
<p>Some pattern</p>
<ul>
<li>Perform filters as early as possible (predicate pushdown).</li>
<li>Reorder predicates so that the DBMS applies the most selective one first.</li>
<li>Breakup a complex predicate and pushing it down (split conjunctive predicates)</li>
</ul>
</li>
</ul>
<h3 id="cost-estimations">Cost Estimations</h3>
<ul>
<li>
<p>最大的代价还是磁盘的I/O，这里的优化就是减少I/O</p>
</li>
<li>
<p>postgres:用的”magic”，黑魔法</p>
</li>
<li>
<p>老牌的商用数据库在优化的时候比开源的要保守和细得多，DB2就会结合事务，锁，用户数整体考虑，pg就比较激进和简单了</p>
</li>
<li>
<p><strong>Selection Statistics</strong></p>
<ul>
<li>这个就是参数，关系型数据库会对每张表做统计信息，这样你分析才有参数</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter15-2.png" title="/img/CMU 15-445 Database Systems/chapter15-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter15-2.png" data-sub-html="<h2>强制立即更新统计信息的命令</h2>">
        
    </a><figcaption class="image-caption">强制立即更新统计信息的命令</figcaption>
    </figure>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #14: Query Execution II</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter14/</link>
    <pubDate>Fri, 12 Apr 2024 21:01:51 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter14/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-14-query-execution-ii">Lecture #14: Query Execution II</h2>
<h3 id="background">Background</h3>
<ul>
<li>上节课讨论了DBMS的执行过程</li>
<li>这节课讨论DBMS在多线程下的执行过程</li>
</ul>
<h3 id="parallel-vs-distributed-databases">Parallel vs Distributed Databases</h3>
<ul>
<li>
<p>并行和分布式数据库</p>
</li>
<li>
<p><strong>Parallel DBMSs</strong></p>
<ul>
<li>资源都在一块，离得很近</li>
<li>资源通信很高速，OS内通信</li>
<li>线程间的通信高速又可靠</li>
</ul>
</li>
<li>
<p><strong>Distributed Databases</strong></p>
<ul>
<li>资源相互之间离得很远</li>
<li>资源之间的通信很慢</li>
<li>节点之间通信的代价很高且不可靠</li>
</ul>
</li>
</ul>
<h3 id="process-models">Process Models</h3>
<ul>
<li>模型：认为每个DBMS下面有多个worker，多个worker并行处理</li>
<li>这个模型针对的是多个SQL并发执行的问题，不能做个单个SQL并发处理的问题</li>
</ul>
<hr>
<ul>
<li><strong>Process per Worker</strong>
<ul>
<li>每一个worker给分配一个进程(OS级别的)</li>
<li>依赖OS对进程的调度</li>
<li>用共享内存来进行通信</li>
<li>优点：一个进程崩了不至于让整个系统宕机</li>
<li>例子：Oracle，Postgres(因为开发年代太古早)</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter14-1.png" title="/img/CMU 15-445 Database Systems/chapter14-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter14-1.png" data-sub-html="<h2>工作模型，因为进程太吃资源，后面基本都做了池化的技术</h2>">
        
    </a><figcaption class="image-caption">工作模型，因为进程太吃资源，后面基本都做了池化的技术</figcaption>
    </figure></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Thread per Worker</strong>
<ul>
<li>pthread统一出现后各大数据库也把模型换成了给worker分配线程</li>
<li>优点：线程切换代价小，内存天然共享</li>
<li>缺点：一个线程崩了整个进程跟着崩</li>
<li>例子：MySQL，IBM DB2</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter14-2.png" title="/img/CMU 15-445 Database Systems/chapter14-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter14-2.png" data-sub-html="<h2>工作模型</h2>">
        
    </a><figcaption class="image-caption">工作模型</figcaption>
    </figure></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p><strong>Scheduling</strong></p>
<ul>
<li>In conclusion, for each query plan, the DBMS has to decide where, when, and how to execute. Relevant
questions include:
<ul>
<li>How many tasks should it use?</li>
<li>How many CPU cores should it use?</li>
<li>What CPU cores should the tasks execute on?</li>
<li>Where should a task store its output?</li>
</ul>
</li>
<li>When making decisions regarding query plans, <strong>the DBMS always knows more than the OS</strong> and should be
prioritized as such.</li>
</ul>
</li>
<li>
<p>说白了就是让DBMS安排一个执行计划怎么执行，这个东西和缓存一样，不能完全依赖OS线程方面的系统调用，要定制化</p>
</li>
</ul>
<h3 id="inter-query-parallelism">Inter-Query Parallelism</h3>
<ul>
<li>多个SQL之间怎么并发执行</li>
<li>如果并发的查询都是只读的，那冲突很小</li>
<li>如果并发的查询涉及更新数据，那冲突就很多且不可避免</li>
</ul>
<h3 id="intra-query-parallelism-horizontal">Intra-Query parallelism (Horizontal)</h3>
<ul>
<li>
<p>水平切，把要处理的数据给切开，然后分给多个线程，这个切是靠Exchange算子的</p>
</li>
<li>
<p>多个线程干的事情是一一样的</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter14-3.png" title="/img/CMU 15-445 Database Systems/chapter14-3.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter14-3.png" data-sub-html="<h2>Exchange算子工作模型，并发调用</h2>">
        
    </a><figcaption class="image-caption">Exchange算子工作模型，并发调用</figcaption>
    </figure>
</li>
<li>
<p>Exchange Type #1 – <strong>Gather</strong></p>
<ul>
<li>→ Combine the results from multiple workers into a single output stream.</li>
</ul>
</li>
<li>
<p>Exchange Type #2 – <strong>Distribute</strong></p>
<ul>
<li>→ Split a single input stream into multiple output streams.</li>
</ul>
</li>
<li>
<p>Exchange Type #3 – <strong>Repartition</strong></p>
<ul>
<li>→ Shuffle multiple input streams across multiple output streams.</li>
</ul>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter14-4.png" title="/img/CMU 15-445 Database Systems/chapter14-4.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter14-4.png" data-sub-html="<h2>三个类型的工作模型</h2>">
        
    </a><figcaption class="image-caption">三个类型的工作模型</figcaption>
    </figure>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter14-5.png" title="/img/CMU 15-445 Database Systems/chapter14-5.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter14-5.png" data-sub-html="<h2>Para Hash</h2>">
        
    </a><figcaption class="image-caption">Para Hash</figcaption>
    </figure>
<h3 id="inter-operator-parallelism--vertical">Inter-Operator parallelism  (Vertical)</h3>
<ul>
<li>垂直切，让多个算子并发执行，数据在每个算子之间流动</li>
<li>Also called pipeline parallelism.</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter14-6.png" title="/img/CMU 15-445 Database Systems/chapter14-6.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter14-6.png" data-sub-html="<h2>多个算子并发</h2>">
        
    </a><figcaption class="image-caption">多个算子并发</figcaption>
    </figure>
<ul>
<li>缺点：中间一个线程处理的速度慢，其他部分线程就要等，会浪费</li>
</ul>
<h3 id="bushy-parallelism">Bushy Parallelism</h3>
<ul>
<li>上面两种并发方式的结合</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter14-7.png" title="/img/CMU 15-445 Database Systems/chapter14-7.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter14-7.png" data-sub-html="<h2>水平并发&#43;垂直并发</h2>">
        
    </a><figcaption class="image-caption">水平并发+垂直并发</figcaption>
    </figure>
<h3 id="io-parallelism">I/O Parallelism</h3>
<ul>
<li>
<p>上面的模型说的都是数据已经在内存中的并行，但是对于本课程的数据库，I/O带来的性能问题如何通过并行优化甚至比前面的并行优化还重要</p>
</li>
<li>
<p>还有上面的内存并行带来的问题可能是两个算子并发读写磁盘的不同部分，那对于机械盘来说这种随机读写也会大大降低性能，这部分也要进行优化</p>
</li>
</ul>
<hr>
<ul>
<li><strong>Split the DBMS across multiple storage devices to improve disk bandwidth latency.Many different options that have trade-offs</strong>:
<ul>
<li>→ Multiple Disks per Database</li>
<li>→ One Database per Disk</li>
<li>→ One Relation per Disk</li>
<li>→ Split Relation across Multiple Disks</li>
</ul>
</li>
<li>Some DBMSs support this natively. Others require admin to configure outside of DBMS.</li>
</ul>
<hr>
<ul>
<li><strong>Multi-Disk Parallelism</strong>
<ul>
<li>在操作系统/硬件层面让不同的DBMS文件去不同的磁盘(e.g. RAID)，这个层面对DBMS是透明的（对于他来说就像操作一个盘一样）</li>
<li>多盘并发</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter14-8.png" title="/img/CMU 15-445 Database Systems/chapter14-8.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter14-8.png" data-sub-html="<h2>RAID0(Striping)下面的多盘并发</h2>">
        
    </a><figcaption class="image-caption">RAID0(Striping)下面的多盘并发</figcaption>
    </figure></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Database Partitioning</strong>
<ul>
<li>把数据库也进行切分</li>
<li>不同的库存在不同的盘，如果有统一恢复用的log文件要记得做好共享问题</li>
<li>把单个的表进行分区，物理存储上分成多个部分，注意，这个分区对应用程序来说要是透明的，不需要关心数据如何存储的</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter14-9.png" title="/img/CMU 15-445 Database Systems/chapter14-9.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter14-9.png" data-sub-html="<h2>某一个属性特别的大且不常用就可以垂直切开分两部分存</h2>">
        
    </a><figcaption class="image-caption">某一个属性特别的大且不常用就可以垂直切开分两部分存</figcaption>
    </figure></li>
</ul>
</li>
</ul>
<h3 id="conclusion">CONCLUSION</h3>
<ul>
<li>
<p>Parallel execution is important, which is why (almost) every major DBMS supports it.</p>
</li>
<li>
<p>However, it is hard to get right.</p>
<ul>
<li>→ Coordination Overhead</li>
<li>→ Scheduling</li>
<li>→ Concurrency Issues</li>
<li>→ Resource Contention</li>
</ul>
</li>
<li>
<p>总结：并发能提示DBMS效率，但是理论简单实现难得多，要面对一大堆的问题</p>
</li>
</ul>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #13: Query Processing I</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter13/</link>
    <pubDate>Fri, 12 Apr 2024 14:56:21 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter13/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-13-query-processing-i">Lecture #13: Query Processing I</h2>
<h3 id="query-plan">Query Plan</h3>
<ul>
<li>就是前面提到的执行树</li>
<li>同一个SQL可以有很多执行计划</li>
</ul>
<h3 id="processing-models">Processing Models</h3>
<ul>
<li>Approach #1: <strong>Iterator Model</strong></li>
<li>Approach #2: <strong>Materialization Model</strong></li>
<li>Approach #3: <strong>Vectorized / Batch Model</strong></li>
</ul>
<hr>
<ul>
<li>
<p><strong>Iterator Model</strong></p>
<ul>
<li>
<p>每一个算子需要提供一个Next()的方法，父算子调用一次就吐出来一些数据，如果返回null说明数据都吐出来了（很像Python的yield），我也可以调用我的子算子的Next()方法</p>
</li>
<li>
<p>也叫“<strong>Volcano/Pipeline Model</strong>”</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter12-1.jpg" title="/img/CMU 15-445 Database Systems/chapter12-1.jpg" data-thumbnail="/img/CMU 15-445 Database Systems/chapter12-1.jpg" data-sub-html="<h2>Volcano Model计算的模型</h2>">
        
    </a><figcaption class="image-caption">Volcano Model计算的模型</figcaption>
    </figure>
</li>
<li>
<p>这个模型几乎在所有DBMS中都有使用</p>
</li>
<li>
<p>这个模型会有Block的现象，比如Join的时候左边在hash，这个时候上层会被Block</p>
</li>
<li>
<p>部分操作不适合这个模型，比如Sort，只能Block之后全吐出来</p>
</li>
<li>
<p>优点：便于操作，比如LIMIT 100的话我Next() 100次就OK</p>
</li>
<li>
<p>缺点：过多的函数调用（一次返回一个，要调用好多次）会影响性能</p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p><strong>Materialization Model</strong></p>
<ul>
<li>
<p>符合直觉的模型，一把算出来给上面</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter12-2.png" title="/img/CMU 15-445 Database Systems/chapter12-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter12-2.png" data-sub-html="<h2>这里的返回值就是数组，是下面算子的最终结果</h2>">
        
    </a><figcaption class="image-caption">这里的返回值就是数组，是下面算子的最终结果</figcaption>
    </figure>
</li>
<li>
<p>OLTP的数据库喜欢这个模型(点查询)</p>
</li>
<li>
<p>OLAP容易给表吐爆</p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Vectorized / Batch Model</strong>
<ul>
<li>前两个模型折中，Next()每次吐出来一批</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter12-3.png" title="/img/CMU 15-445 Database Systems/chapter12-3.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter12-3.png" data-sub-html="<h2>每次吐出来一批数据</h2>">
        
    </a><figcaption class="image-caption">每次吐出来一批数据</figcaption>
    </figure></li>
<li>OLAP友好，函数调用不会过多，又不会像<strong>Materialization Model</strong>那样一次返回的东西太大</li>
<li>还有个好处就是匹配硬件，现在部分CPU支持小规模并行处理事务（类似残废版CUDA），这种模型非常符合CPU的并行批处理指令</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>函数调用的方向可以根到叶子，也可以叶子到根</li>
</ul>
<h3 id="access-methods">Access Methods</h3>
<ul>
<li><strong>Sequential Scan</strong>
<ul>
<li>顺序扫描</li>
<li>顺序把页读进来，然后顺序扫描叶中的元组</li>
<li>优化
<ul>
<li>预加载</li>
<li>不再读的东西扫完就扔</li>
<li>并行化</li>
<li>Zone Maps
<ul>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter12-4.png" title="/img/CMU 15-445 Database Systems/chapter12-4.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter12-4.png" data-sub-html="<h2>给每个页做统计信息，这样算子可以不用加载到缓存池就对页做一次判断和过滤</h2>">
        
    </a><figcaption class="image-caption">给每个页做统计信息，这样算子可以不用加载到缓存池就对页做一次判断和过滤</figcaption>
    </figure></li>
<li>问题:数据冗余，而且不能存到页里面（那又该加载到缓存池了），要转门找地方存，还要同步数据</li>
</ul>
</li>
<li>晚物化：只要需要的数据，不要整个Tuple，或者只存Record ID，利用回表拿数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Index Scan</strong>
<ul>
<li>考虑的条件后面会讲</li>
<li>用什么索引要靠优化器分析</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Multi-Index Scan</strong>
<ul>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter12-5.png" title="/img/CMU 15-445 Database Systems/chapter12-5.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter12-5.png" data-sub-html="<h2>多索引扫描每一个条件取集合，根据谓词做交/并的操作</h2>">
        
    </a><figcaption class="image-caption">多索引扫描每一个条件取集合，根据谓词做交/并的操作</figcaption>
    </figure></li>
</ul>
</li>
</ul>
<h3 id="modification-queries">Modification Queries</h3>
<ul>
<li>
<p>更改的操作，逻辑会不一样</p>
<ul>
<li>不能无脑修改，要检查当前表的约束</li>
<li>索引等其他数据要同步进行维护</li>
<li>HALLOWEEN PROBLEM
<ul>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter12-6.png" title="/img/CMU 15-445 Database Systems/chapter12-6.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter12-6.png" data-sub-html="<h2>不记录之前操作过什么数据会导致部分数据被多次更新（更新完了之后没有达到预定条件被扫到再次被更新）</h2>">
        
    </a><figcaption class="image-caption">不记录之前操作过什么数据会导致部分数据被多次更新（更新完了之后没有达到预定条件被扫到再次被更新）</figcaption>
    </figure></li>
</ul>
</li>
</ul>
</li>
<li>
<p>expression tree</p>
<ul>
<li>给谓词表达式也用树的结构处理
<ul>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter12-7.png" title="/img/CMU 15-445 Database Systems/chapter12-7.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter12-7.png" data-sub-html="<h2>expression tree</h2>">
        
    </a><figcaption class="image-caption">expression tree</figcaption>
    </figure></li>
</ul>
</li>
<li>缺点：可能会重复计算浪费时间</li>
<li>解决方案：能先算出来的全算出来，像Java的JIT（比如经常跑的一段Java字节码，我直接转成二进制CPU指令，然后跑的时候直接跑CPU指令，省去JVM解析的过程）</li>
</ul>
</li>
</ul>
<h3 id="conclusion">CONCLUSION</h3>
<ul>
<li>The same query plan can be executed in multiple different ways.</li>
<li>(Most) DBMSs will want to use index scans as much as possible.</li>
<li>Expression trees are flexible but slow.JIT compilation can (sometimes) speed them up.</li>
</ul>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #11: Joins Algorithms</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter11/</link>
    <pubDate>Fri, 12 Apr 2024 00:56:12 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter11/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-11-joins-algorithms">Lecture #11: Joins Algorithms</h2>
<h3 id="introduction">Introduction</h3>
<ul>
<li>
<p>根据数据库的范式理论，设计数据库表的一个原则是不让数据冗余，所以在查找的时候JOIN的操作是少不了的</p>
</li>
<li>
<p>For binary joins, we often prefer the left table (the ”outer table” ) to be the smaller one of the two.优化SQL的一个方法，左表尽量小(<strong>这个小指的是文件页数少</strong>)，后面会说明原因</p>
</li>
</ul>
<h3 id="join-operators">Join Operators</h3>
<ul>
<li><strong>Operator Output</strong>
<ul>
<li>两个表满足JOIN条件的attributes可以组合成一个新的tuple</li>
<li>输出取决于以下几个方面
<ul>
<li>processing model</li>
<li>storage model</li>
<li>data requirements in query</li>
</ul>
</li>
<li><strong>Data</strong>
<ul>
<li><strong>Early materialization</strong>
<ul>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter11-1.png" title="/img/CMU 15-445 Database Systems/chapter11-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter11-1.png" data-sub-html="<h2>JOIN的时候需要什么属性都加上，最后直接输出</h2>">
        
    </a><figcaption class="image-caption">JOIN的时候需要什么属性都加上，最后直接输出</figcaption>
    </figure></li>
<li>可以避免子操作回表</li>
</ul>
</li>
<li><strong>Record Id</strong>
<ul>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter11-2.png" title="/img/CMU 15-445 Database Systems/chapter11-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter11-2.png" data-sub-html="<h2>属性里面放的是行id或者地址，后面需要回表拿数据</h2>">
        
    </a><figcaption class="image-caption">属性里面放的是行id或者地址，后面需要回表拿数据</figcaption>
    </figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p><strong>Cost Analysis</strong></p>
<ul>
<li>
<p>不同JOIN算法的开销</p>
</li>
<li>
<p>Assume</p>
<ul>
<li>
<p>M pages in table R, m tuples in R</p>
</li>
<li>
<p>N pages in table S, n tuples in S</p>
</li>
<li>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="n">R</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">S</span><span class="p">.</span><span class="n">cdate</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">S</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">ON</span><span class="w"> </span><span class="n">R</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">S</span><span class="p">.</span><span class="n">id</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">S</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>
<p>Cost Metric: <strong>number of IOs</strong> to compute join</p>
</li>
<li>
<p><strong>JOIN Algorithms</strong></p>
<ul>
<li>Next Loop Join</li>
<li>Sort-Merge Join</li>
<li>Hash Join</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="nested-loop-join">Nested Loop Join</h3>
<ul>
<li><strong>Native Nested Loop Join</strong></li>
<li>伪代码</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="line"><span class="cl"><span class="k">foreach</span> <span class="n">tuple</span> <span class="n">r</span> <span class="k">in</span> <span class="n">R</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">foreach</span> <span class="n">tuple</span> <span class="n">s</span> <span class="k">in</span> <span class="n">S</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">r</span> <span class="n">and</span> <span class="n">s</span> <span class="n">match</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">emit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>“stupid nested loop join”</p>
<ul>
<li><strong>一个R中的tuple需要扫S表的所有数据，对于缓存池的利用率过低，这种方法开销太大</strong></li>
<li>S每次都是先灌满缓存池，然后前面的页淘汰，如此反复</li>
</ul>
</li>
<li>
<p>Assume</p>
<ul>
<li>
<p>M pages in table R, m tuples in R</p>
</li>
<li>
<p>N pages in table S, n tuples in S</p>
</li>
</ul>
</li>
<li>
<p>Cost: $M+(m \times N)$</p>
</li>
<li>
<p>优化：高效利用缓存池，一次多加载一些页，不要一页一页加载</p>
</li>
<li>
<p><strong>Block Nested Loop Join</strong></p>
</li>
<li>
<p>伪代码</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="line"><span class="cl"><span class="k">foreach</span> <span class="n">block</span> <span class="n">B_R</span> <span class="k">in</span> <span class="n">R</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">foreach</span> <span class="n">block</span> <span class="n">B_S</span> <span class="k">in</span> <span class="n">S</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">foreach</span> <span class="n">tuple</span> <span class="n">r</span> <span class="k">in</span> <span class="n">B_R</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">foreach</span> <span class="n">tuple</span> <span class="n">s</span> <span class="k">in</span> <span class="n">B_S</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="n">r</span> <span class="n">and</span> <span class="n">s</span> <span class="n">match</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">emit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>每次不只读一页，每次R和S都读好多页进行匹配</p>
</li>
<li>
<p>Cost: $M+(\frac{M}{M\ Block\ Size} \times N)$</p>
</li>
<li>
<p>讨论block size</p>
</li>
<li>
<p>B个页的内存，一个页做输出缓存，一个页给右表，多缓存左表(给B-2个)</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="line"><span class="cl"><span class="k">foreach</span> <span class="n">B</span><span class="p">-</span><span class="m">2</span> <span class="n">blocks</span> <span class="n">B_R</span> <span class="k">in</span> <span class="n">R</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">foreach</span> <span class="n">block</span> <span class="n">B_S</span> <span class="k">in</span> <span class="n">S</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">foreach</span> <span class="n">tuple</span> <span class="n">r</span> <span class="k">in</span> <span class="n">B</span><span class="p">-</span><span class="m">2</span> <span class="n">blocks</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">foreach</span> <span class="n">tuple</span> <span class="n">s</span> <span class="k">in</span> <span class="n">B_S</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="n">r</span> <span class="n">and</span> <span class="n">s</span> <span class="n">match</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">emit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>Cost: $M+(\frac{M}{B-2}\times N)$</p>
</li>
<li>
<p>if $B-2&gt;M$, then cost: $M+N$</p>
</li>
<li>
<p>为啥nested loop join性能不行</p>
<ul>
<li>总要去遍历S表</li>
<li>为啥要遍历：<strong>没有索引等其他方案来提高查找S中属性的效率，所以只能傻瓜式的遍历</strong></li>
</ul>
</li>
<li>
<p>优化思路：提高S中查找/范围查找的速度</p>
</li>
<li>
<p><strong>Index Nested Loop Join</strong></p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="line"><span class="cl"><span class="k">foreach</span> <span class="n">tuple</span> <span class="n">r</span> <span class="k">in</span> <span class="n">R</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">foreach</span> <span class="n">tuple</span> <span class="n">S</span> <span class="k">in</span> <span class="n">Index</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">==</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">r</span> <span class="n">and</span> <span class="n">s</span> <span class="n">match</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">emit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>认为每次索引查询需要C次I/O</p>
</li>
<li>
<p>Cost: $M+(m\times C)$</p>
</li>
</ul>
<h3 id="sort-merge-join">Sort-Merge Join</h3>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter11-3.png" title="/img/CMU 15-445 Database Systems/chapter11-3.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter11-3.png" data-sub-html="<h2>先对Join的列进行排序，后面就是合并多个有序数组的思路</h2>">
        
    </a><figcaption class="image-caption">先对Join的列进行排序，后面就是合并多个有序数组的思路</figcaption>
    </figure>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter11-4.png" title="/img/CMU 15-445 Database Systems/chapter11-4.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter11-4.png" data-sub-html="<h2>匹配中可能会漏掉匹配项，必须要加上回退的功能</h2>">
        
    </a><figcaption class="image-caption">匹配中可能会漏掉匹配项，必须要加上回退的功能</figcaption>
    </figure>
<ul>
<li>
<p>Cost</p>
<ul>
<li>
<p>Sort R: $2M \times (1+\log_{B-1}\frac{M}{B})$</p>
</li>
<li>
<p>Sort S: $2N\times (1+\log_{B-1}\frac{N}{B})$</p>
</li>
<li>
<p>Merge Cost: $M+N$</p>
</li>
<li>
<p>Total Cost: $Sort + Merge$</p>
</li>
</ul>
</li>
<li>
<p>退化情况：两个连接列所有值一样，那么Merge Cost会因为回退增加到$M\times N$</p>
</li>
<li>
<p>适合的场景</p>
<ul>
<li>数据本身就有序</li>
<li>输出的结果需要排序</li>
</ul>
</li>
</ul>
<h3 id="hash-join">Hash Join</h3>
<ul>
<li>Hash table点查询比B+ Tree快
<ul>
<li>左表做hash，右表去匹配</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">build</span> <span class="nb">hash</span> <span class="n">table</span> <span class="n">HT_R</span> <span class="k">for</span> <span class="n">R</span>
</span></span><span class="line"><span class="cl"><span class="n">foreach</span> <span class="nb">tuple</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">S</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">h1</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">in</span> <span class="n">HT_R</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">output</span>
</span></span></code></pre></td></tr></table>
</div>
</div><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter11-5.png" title="/img/CMU 15-445 Database Systems/chapter11-5.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter11-5.png" data-sub-html="<h2>给左表做哈希表，右表的数据hash完成后去哈希表里面找匹配数据</h2>">
        
    </a><figcaption class="image-caption">给左表做哈希表，右表的数据hash完成后去哈希表里面找匹配数据</figcaption>
    </figure>
<ul>
<li>
<p>Hash</p>
<ul>
<li>Key:需要连接的列</li>
<li>Value
<ul>
<li>Full Tuple:放上需要的数据，不需要回表</li>
<li>Tuple Identifier:放索引，最后需要去回表拿数据</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>OPTIMIZATION</strong></p>
<ul>
<li>Create a probe filter (such as a Bloom Filter) during the build phase if the key is likely to not exist in the inner relation 加上一层过滤器先过滤掉部分没有匹配项的数据，防止在哈希表里面找半天发现没有，比如加一个布隆过滤器</li>
</ul>
</li>
<li>
<p>如果哈希表太大可能会面临内存池驱逐的问题，但是我们不想让内存池随机驱逐</p>
</li>
<li>
<p><strong>Grace Hash Join</strong></p>
<ul>
<li>
<p>1980’s东京大学搞数据库一体机的时候发明的（现在也有一体机，比如Oracle还在卖），银行和金融机构爱买</p>
</li>
<li>
<p>左表和右表都做hash，把哈希表存在硬盘里面，把硬盘里面相对应的哈希桶拿出来做nested loop join</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter11-6.png" title="/img/CMU 15-445 Database Systems/chapter11-6.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter11-6.png" data-sub-html="<h2>能连接上的行都在一个桶号里面，所以每次都加载两个哈希表里面相同桶号的桶</h2>">
        
    </a><figcaption class="image-caption">能连接上的行都在一个桶号里面，所以每次都加载两个哈希表里面相同桶号的桶</figcaption>
    </figure>
</li>
<li>
<p>如果哈希桶还是太大怎么办，再换别的哈希函数继续哈希，直到哈希出来的块够小（这个叫<strong>RECURSIVE PARTITIONING</strong>）</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter11-7.png" title="/img/CMU 15-445 Database Systems/chapter11-7.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter11-7.png" data-sub-html="<h2>RECURSIVE PARTITIONING</h2>">
        
    </a><figcaption class="image-caption">RECURSIVE PARTITIONING</figcaption>
    </figure>
</li>
</ul>
</li>
<li>
<p>Cost</p>
<ul>
<li>Partition Phash:$2(M+N)$(读到内存hash后还要写回去)</li>
<li>Probing Phash:$M+N$</li>
<li>Total:$3(M+N)$</li>
</ul>
</li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter11-8.png" title="/img/CMU 15-445 Database Systems/chapter11-8.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter11-8.png" data-sub-html="<h2>各方法开销</h2>">
        
    </a><figcaption class="image-caption">各方法开销</figcaption>
    </figure>
<ul>
<li>Sorting和Hash没有最好，要看条件选择
<ul>
<li>哈希碰撞，输出是否有序都会影响开销</li>
<li>优秀的数据库会有优化器来进行分析和选择</li>
</ul>
</li>
</ul>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #10: Sorting &amp; Aggregation Algorithms</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter10/</link>
    <pubDate>Thu, 11 Apr 2024 19:21:30 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter10/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-10-sorting--aggregation-algorithms">Lecture #10: Sorting &amp; Aggregation Algorithms</h2>
<h3 id="query-plan">Query Plan</h3>
<ul>
<li>
<p>从本节课开始将讨论DBMS的Operator Execution</p>
</li>
<li>
<p>优化器会把SQL变成一棵执行树，递归式的向上执行</p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter10-1.png" title="/img/CMU 15-445 Database Systems/chapter10-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter10-1.png" data-sub-html="<h2>执行树</h2>">
        
    </a><figcaption class="image-caption">执行树</figcaption>
    </figure>
<ul>
<li>本课DBMS的特点：内存没法一次处理全部数据，会OOM，往往需要把中间结果也给写回到磁盘，磁盘和内存要相互配合，要最大化利用连续I/O，减少随机I/O的压力</li>
</ul>
<h3 id="sorting">Sorting</h3>
<ul>
<li>
<p><strong>External merge sort</strong></p>
<ul>
<li>排的是硬盘里面的数据，而不是像往常那样排内存里面的数据</li>
<li>代表：MySQL</li>
<li>Phase #1 – Sorting: First, the algorithm sorts small chunks of data that fit in main memory, and then writes the sorted pages back to disk.</li>
<li>Phase #2 – Merge: Then, the algorithm combines the sorted runs into larger sorted runs.</li>
</ul>
</li>
<li>
<p>两种&lt;Key,Value&gt;的模式</p>
<ul>
<li>Early Materialization:&lt;Key,Tuple&gt;，直接存储的就是数据</li>
<li>Late Materialization:&lt;Key,Record id&gt;，需要回表</li>
</ul>
</li>
<li>
<p><strong>Two-way Merge Sort</strong></p>
<ul>
<li>N个页的大表，缓存池最多能承受B个页的容量</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter10-2.png" title="/img/CMU 15-445 Database Systems/chapter10-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter10-2.png" data-sub-html="<h2>把每页加载到内存后排序，然后把排序好的数据写回磁盘，最后再归并刚才写回磁盘的那些有序页</h2>">
        
    </a><figcaption class="image-caption">把每页加载到内存后排序，然后把排序好的数据写回磁盘，最后再归并刚才写回磁盘的那些有序页</figcaption>
    </figure></li>
<li>排序好的数据不是全部一把进到内存（那又该爆内存了，可以轮询着进，因为合并有序数组本来就是轮询比较的（参考力扣里面的题目））</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter10-3.png" title="/img/CMU 15-445 Database Systems/chapter10-3.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter10-3.png" data-sub-html="<h2>多个页的情况</h2>">
        
    </a><figcaption class="image-caption">多个页的情况</figcaption>
    </figure></li>
<li>优化：一次I/O不要只读一页，尽最大可能多读几页</li>
</ul>
</li>
<li>
<p><strong>General (K-way) Merge Sort</strong></p>
<ul>
<li>二路归并变成K路归并，一次比如读N/B个页，然后进行排序，Merge的轮数会少很多，这样效率会提高很多</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Using B+Trees</strong>
<ul>
<li>直接利用B+ Tree的有序性</li>
<li>要考虑聚簇还是非聚簇，因为聚簇的话关系到Early Materialization的问题，可以省去回表的过程，提高效率</li>
</ul>
</li>
</ul>
<h3 id="aggregations">Aggregations</h3>
<ul>
<li>
<p><strong>Sorting</strong></p>
<ul>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter10-4.png" title="/img/CMU 15-445 Database Systems/chapter10-4.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter10-4.png" data-sub-html="<h2>过滤，排序，去重</h2>">
        
    </a><figcaption class="image-caption">过滤，排序，去重</figcaption>
    </figure></li>
</ul>
</li>
<li>
<p><strong>Hashing</strong></p>
<ul>
<li>
<p>如果不要求有序可以用Hashing来提高效率</p>
</li>
<li>
<p><strong>External Hashing aggregations</strong></p>
</li>
<li>
<p><strong>Phase #1 – Partition</strong></p>
<ul>
<li>先给要Agg的字段做一个哈希表，然后把这个哈希表写回到磁盘里面</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter10-5.png" title="/img/CMU 15-445 Database Systems/chapter10-5.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter10-5.png" data-sub-html="<h2>把需要Agg的字段做第一次哈希，相同的值&#43;碰撞的都放在一个桶</h2>">
        
    </a><figcaption class="image-caption">把需要Agg的字段做第一次哈希，相同的值+碰撞的都放在一个桶</figcaption>
    </figure></li>
</ul>
</li>
<li>
<p><strong>Phase #2 – ReHash</strong>:把磁盘里面的哈希表再加载到内存中，读进去之后再做第二次哈希，这样就把碰撞的值也分开了，这样就生成了第二次的哈希表，也就是最终结果</p>
<ul>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter10-6.png" title="/img/CMU 15-445 Database Systems/chapter10-6.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter10-6.png" data-sub-html="<h2>二次哈希解决了哈希碰撞，也就拿到了最终结果</h2>">
        
    </a><figcaption class="image-caption">二次哈希解决了哈希碰撞，也就拿到了最终结果</figcaption>
    </figure></li>
</ul>
</li>
<li>
<p><strong>Hashing summarization</strong></p>
<ul>
<li>During the rehash phase, store pairs of the form (GroupKey→RunningVal) 如果说需要对值进行计算(count,sum等)，那么在hash的过程中也要带上其他需要的数值，这部分叫RunningVal</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter10-7.png" title="/img/CMU 15-445 Database Systems/chapter10-7.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter10-7.png" data-sub-html="<h2>带上需要的数据进行聚合类函数的计算</h2>">
        
    </a><figcaption class="image-caption">带上需要的数据进行聚合类函数的计算</figcaption>
    </figure></li>
</ul>
</li>
</ul>
</li>
<li>
<p>Sorting和Hashing没有绝对的好，要看条件，比如前置的数据有没有做了排序或者哈希，需要的结果到底要不要进行排序</p>
</li>
<li>
<p>优化的思路</p>
<ul>
<li>随机I/O尽量变成连续I/O:一次写入页的数量尽量多</li>
<li>预加载:能先加载到内存中的数据都先加载到内存中</li>
</ul>
</li>
</ul>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #09: Index Concurrency Control</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter9/</link>
    <pubDate>Thu, 11 Apr 2024 13:34:01 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter9/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-09-index-concurrency-control">Lecture #09: Index Concurrency Control</h2>
<h3 id="index-concurrency-control">Index Concurrency Control</h3>
<ul>
<li>
<p>前面讨论都默认是单线程条件下，但是对于DBMS这种主要问题在I/O上面的系统来说，肯定要上多线程，异步这些来提高效率，那么如何在这种条件下保证索引的线程安全很重要了</p>
</li>
<li>
<p>其他数据库的一些处理方法</p>
<ul>
<li>内存型NoSQL:直接单线程模式运行，比如Redis</li>
</ul>
</li>
<li>
<p>本节课主要研究<strong>Physical Correctness</strong>，关注底层设计</p>
</li>
</ul>
<h3 id="locks-vs-latches">Locks vs. Latches</h3>
<ul>
<li>和前面的课讨论的一样，一个逻辑锁，一个底层锁</li>
<li>死锁和回滚都是建立在Locks上面的</li>
<li>Latches这个锁要划分为读锁和写锁
<ul>
<li>多个线程可以同时去读一个变量，相应的读锁可以重入其他线程的读锁，但是其他线程不能写(也叫共享锁)</li>
<li>一个线程写数据的时候，其他线程不能读和写这个数据，所以写锁一般不可重入其他线程的锁(也叫独占锁)</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter9-1.png" title="/img/CMU 15-445 Database Systems/chapter9-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter9-1.png" data-sub-html="<h2>Locks和Latches的区别</h2>">
        
    </a><figcaption class="image-caption">Locks和Latches的区别</figcaption>
    </figure>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter9-1.png" title="/img/CMU 15-445 Database Systems/chapter9-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter9-1.png" data-sub-html="<h2>兼容矩阵</h2>">
        
    </a><figcaption class="image-caption">兼容矩阵</figcaption>
    </figure>
<h3 id="latch-implementations">Latch Implementations</h3>
<ul>
<li><strong>Blocking OS Mutex</strong>
<ul>
<li>simple to use(操作系统自己支持)</li>
<li>Non-scalable (about 25ns per lock/unlock invocation)，大规模使用不行，这东西效率太低</li>
<li>Example: std::mutex$\rightarrow$pthread_mutex$\rightarrow$futex</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">m</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Do something special...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">m</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>底层实现:内存中分配出来一个变量来获取锁，要锁的程序就把这个变量设置值，如果发现锁被夺取，这个线程就直接进入内核态自己sleep，如果锁被释放操作系统会试着唤醒sleep的线程
<ul>
<li>好处：竞争的线程拿不到锁直接sleep，不会额外消耗系统的资源</li>
<li>坏处：sleep和notify在操作系统层面上面很浪费资源（线程链表的调整）</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Test-and-Set Spin Latch (TAS)</strong></li>
<li>也叫自旋锁</li>
<li>Very efficient (single instruction to latch/unlatch)</li>
<li>Non-scalable, not cache friendly, not OS friendly.大规模用效率上也不行，自旋也很笨</li>
<li>Example: std::atomic&lt;T&gt;</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">atomic_flag</span> <span class="n">latch</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">while</span> <span class="p">(</span><span class="n">latch</span><span class="p">.</span><span class="n">test_and_set</span><span class="p">(</span><span class="err">…</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// Retry? Yield? Abort?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>检测和设置这一组操作必须要是原子的</p>
</li>
<li>
<p>自旋锁对于CPU的开销很大（一直空转）</p>
</li>
<li>
<p>很多语言会把TAS和Blocking结合，自旋一阵子不行就去睡一会</p>
</li>
</ul>
<hr>
<ul>
<li><strong>Atomic Instruction Example: compare-and-swap (CAS)</strong>
<ul>
<li>
<p>Atomic instruction that compares contents of a memory location M to a given value V</p>
<ul>
<li>If values are equal, installs new given value V’ in M</li>
<li>Otherwise, operation fails</li>
</ul>
</li>
<li>
<p>这个东西是CPU的一条指令，由CPU来保证原子性</p>
</li>
<li>
<p>经常作为自旋锁或者JUC的包里面的一些锁底层的实现</p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Reader-Writer Latches</strong>
<ul>
<li>Allows for concurrent readers. Must manage read/write queues to avoid starvation.</li>
<li>Can be implemented on top of spinlocks</li>
<li>Example: std::shared_mutex $\rightarrow$ pthread_rwlock</li>
</ul>
</li>
</ul>
<h3 id="hash-table-latching">Hash Table Latching</h3>
<ul>
<li>
<p>好加锁，无论是桶还是开放地址哈希，大家查找的方向是一致的，并且一次只能访问一个页/槽，这点上出不了死锁(当然HashMap的头插法可能会出，不过这个和链表的结构有关)，向其他搜索方向不一致的B+ Tree可能就会出死锁</p>
</li>
<li>
<p>如果要调整容量，一般把整个哈希表都给加上全局的写锁</p>
</li>
<li>
<p>其他情况下一般锁部分就可以了</p>
<ul>
<li>
<p><strong>Page/Block-level Latches</strong></p>
<ul>
<li>Each page/block has its own reader-writer latch that protects its entire contents.</li>
<li>Threads acquire either a read or write latch before they access a page/block</li>
<li>按块划分，加锁</li>
<li>Java的ConcurrentHashMap是这种处理方案，几个槽一个锁</li>
<li>好处：不用维护太多锁，还保证了并发性</li>
</ul>
</li>
<li>
<p><strong>Slot Latches</strong></p>
<ul>
<li>一个槽加一个锁</li>
<li>锁更细了，更能避免死锁和提高并发</li>
<li>但是维护这么多锁开销太高了</li>
</ul>
</li>
<li>
<p>还有其他方法，比如读写分离（比如go的sync.Map）</p>
</li>
</ul>
</li>
</ul>
<h3 id="btree-latching">B+Tree Latching</h3>
<ul>
<li>两方面的并发问题
<ul>
<li>节点内部的数据要做并发保护</li>
<li>节点的分裂/合并过程中要做并发保护</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p><strong>Latch Crabbing/Coupling</strong></p>
<ul>
<li>
<p>Get latch for parent，给根节点上锁</p>
</li>
<li>
<p>Get latch for child，给子节点上锁</p>
</li>
<li>
<p>Release latch for parent if “safe”，判断子节点是否“安全”，安全的话放根节点的锁</p>
</li>
<li>
<p>“safe”:A <strong>safe node</strong> is one that will not split or merge when updated.</p>
</li>
</ul>
</li>
<li>
<p>Find: Start at root and traverse down the tree</p>
<ul>
<li>Acquire R latch on child</li>
<li>Then unlatch parent</li>
<li>Repeat until we reach the leaf node</li>
</ul>
</li>
<li>
<p>Insert/Delete: Start at root and go down, obtaining W latches as needed. Once child is latched, check if it is safe:</p>
<ul>
<li>If child is safe, release all latches on ancestors</li>
</ul>
</li>
<li>
<p>问题：所有的操作都要先锁根节点，这是一个性能上面的瓶颈</p>
<ul>
<li>原因：上面的想法是悲观的，认为每次写操作都有可能会造成根节点的分裂/合并，但是实际上来说根节点变动的次数很少</li>
<li>使用乐观的想法：我认为大部分操作不会改变根节点的结构，所以我给根节点加读锁，如果说发现根节点要变动结构，这个时候从根节点重新给加写锁</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Leaf Node Scans</strong>
<ul>
<li>一般来说是顺序扫描</li>
<li>但是这样会带来一个风险:Find key &gt; 4和Find key &lt; 1扫描叶子节点的时候方向是相反的，会有死锁的风险</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter9-3.png" title="/img/CMU 15-445 Database Systems/chapter9-3.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter9-3.png" data-sub-html="<h2>方向相反造成死锁</h2>">
        
    </a><figcaption class="image-caption">方向相反造成死锁</figcaption>
    </figure></li>
<li>解决方法：<strong>制定规则</strong>，比如数据只能从大往小走，比如MySQL，之前不支持倒序遍历就和这个有关，后面又加上了倒叙索引才解决了这个问题</li>
</ul>
</li>
</ul>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #08: Tree Indexes</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter8/</link>
    <pubDate>Wed, 10 Apr 2024 15:53:39 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter8/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-08-tree-indexes">Lecture #08: Tree Indexes</h2>
<h3 id="table-indexes">Table Indexes</h3>
<ul>
<li>数据库中常常需要数据库的部分有序(这也是为什么哈希表做不成索引，因为无序)副本来提高查找的效率，这个副本一般称为索引</li>
<li>DBMS要自己维护索引和数据的一致性，还有执行SQL的时候使用什么索引</li>
</ul>
<h3 id="b-tree">B+ Tree</h3>
<ul>
<li>B+ Tree是一种自平衡搜索树，它可以将查找的复杂度控制在$O(logn)$，同时它的设计也减小了查找时磁盘的$I/O$，这对于DBMS的效率来说是十分重要的</li>
<li>几乎所有支持索引的现代DBMS都用了B+ Tree，B+ Tree和B Tree最大的区别在于B+ Tree之有叶子节点才存储了值，非叶子节点存储的是部分索引的值，而B Tree的每个节点都存储了值</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter8-1.png" title="/img/CMU 15-445 Database Systems/chapter8-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter8-1.png" data-sub-html="<h2>B&#43; Tree还借鉴了其他B Tree类数据结构的特性，比如从B-Link-Tree中学到的sibling pointers</h2>">
        
    </a><figcaption class="image-caption">B+ Tree还借鉴了其他B Tree类数据结构的特性，比如从B-Link-Tree中学到的sibling pointers</figcaption>
    </figure>
<ul>
<li>
<p>B+ Tree有以下特点</p>
<ul>
<li>它是完全平衡的（所有的叶子节点高度一致）</li>
<li>除了根节点外，每个内部节点至少为半满($\frac{M}{2}-1 \le num\ of\ keys \le M -1$)</li>
<li>每个有K个键的节点有K+1个非空子节点（指针是从两个key中间的“缝”出来的）</li>
</ul>
</li>
<li>
<p>B+ Tree的每个节点都包含一个Key-Value的数组&lt;索引值，下层的节点&gt;</p>
</li>
<li>
<p>B+ Tree的叶子节点有两种存储模式</p>
<ul>
<li>一种是存储Tuple的指针，通过这个指针去拿Tuple的数据</li>
<li>另一种是存储Tuple的数据，这样就可以直接获取，不用再去找一次Tuple的数据</li>
</ul>
</li>
<li>
<p>根据NULL在不同类型中的意义，NULL节点一般会在第一个或最后一个叶子节点里面（要看对NULL认为是无穷大的还是无穷小的）</p>
</li>
</ul>
<hr>
<ul>
<li><strong>Insertion</strong>
<ul>
<li>向下遍历树，找到插入的位置</li>
<li>如果索引有足够的空间，则直接插入</li>
<li>否则最下面的索引分裂，然后重新整合B+ Tree的结构后再插入</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Deletion</strong>
<ul>
<li>如果删除后的节点少于半满，需要合并树</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Composite Index</strong>
<ul>
<li>多个属性组成的联合索引</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="n">abc_index</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="k">c</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>我们可以使用联合索引来加快查询速度</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="k">c</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="k">table</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="k">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p><strong>Selection Conditions</strong></p>
<ul>
<li>要看联合索引的结构，是前面的字段先有序之后再排下一个字段，要想高效利用联合索引就要会最左匹配</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Duplicate Keys</strong>:重复索引的处理方法
<ul>
<li><strong>append record IDs</strong>:后面加上唯一标识符。比如主键或者(page,slot)的元组，这样就保证绝对唯一</li>
<li><strong>overflow nodes</strong>:给叶子节点再挂一个溢出节点，专门放碰撞的Key，但是增加了维护树结构的成本</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Clustered Indexes</strong>
<ul>
<li>主键B+ Tree的叶子节点对应的数据就是实际数据，这样遍历到主键的话直接就拿到数据</li>
<li>但是如果不是主键的B+ Tree的话，只能先拿到主键再去主键的B+ Tree上面找</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Index Scan Page Sorting</strong>
<ul>
<li>先扫描统计要那些主键对应的数据，再把数据做一次排序 ,然后进主键的B+ Tree一把搜出来</li>
</ul>
</li>
</ul>
<h3 id="btree-design-choices">B+Tree Design Choices</h3>
<ul>
<li><strong>Node size</strong>
<ul>
<li>磁盘越慢，B+ Tree的节点越大，这样减少I/O的压力，如果是内存，节点应该变小，因为这个时候筛选无用数据的成本已经高过磁盘中的I/O了
<ul>
<li>HDD: ~1MB</li>
<li>SSD: ~10KB</li>
<li>In-Memory: ~512B</li>
</ul>
</li>
<li>还有就是业务类型，OTAP喜欢点查询，节点小一点好，OLAP喜欢动不动扫描全表，节点大一点好</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Merge Threshold</strong>
<ul>
<li>一般来说合并拆分这种操作DBMS都是尽量拖一拖，因为这个过程开销太大了，所以不是到了阈值就马上合并</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Variable Length Keys</strong>
<ul>
<li>pointers:节点存指针</li>
<li>Variable Length Nodes:节点本身就是变长的，维护更加困难</li>
<li>Padding:数据不到规定大小，填充字节补偿(像字节对齐)</li>
<li>Key Map/Indirection:和slot很像，里面的结构加上slot-array来适应不同长度的数据</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Intra-Node Search</strong>
<ul>
<li>节点内部的数据怎么搜索
<ul>
<li><strong>Linear</strong>:线性遍历，看似低效，但是和I/O的时间比起来不算什么</li>
<li><strong>Binary</strong>:二分，复杂度降为$O(log(n))$</li>
<li><strong>Interpolation</strong>:利用数学规律/机器学习等其他方式进行推断查找</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="optimizations">Optimizations</h3>
<ul>
<li>
<p><strong>Prefix Compression</strong></p>
<ul>
<li>
<p>找前缀一样的统一存一下前缀，剩下的空间存后缀</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter8-2.png" title="/img/CMU 15-445 Database Systems/chapter8-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter8-2.png" data-sub-html="<h2>前缀压缩的例子</h2>">
        
    </a><figcaption class="image-caption">前缀压缩的例子</figcaption>
    </figure>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Deduplication</strong>
<ul>
<li>一个K，后面根据所有的V，防止K冗余</li>
<li>$(K_1,V_1),(K_1,V_2),(K_1,V_3),(K_2,V_4),(K_2,V_5) \rightarrow\ (K_1,V_1,V_2,V_3),(K_2,V_4,V_5)$</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Suffix Truncation</strong>
<ul>
<li>如果搜索的时候不要要全部数据往下走，只需要部分数据，那我存个前缀也行
<ul>
<li>比如string的like”x%”这种操作，存前缀就够了</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Bulk Insert</strong>
<ul>
<li>一次插入一批，减少树的分裂合并次数</li>
</ul>
</li>
</ul>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #07: Hash Tables</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter7/</link>
    <pubDate>Tue, 09 Apr 2024 21:11:32 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter7/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-07-hash-tables">Lecture #07: Hash Tables</h2>
<h3 id="data-structures">Data Structures</h3>
<ul>
<li>
<p>DBMS很多部分使用不同的数据结构</p>
<ul>
<li>Internal Meta-Data</li>
<li>Core Data Storage</li>
<li>Temporary Data Structures</li>
<li>Table Indices</li>
</ul>
</li>
<li>
<p>DBMS设计数据结构需要考虑两个方面</p>
<ul>
<li><strong>Data organization</strong>:数据结构应该怎么设计，什么数据应该存到那，从而保证有效的访问</li>
<li><strong>Concurrency</strong>:老话题，只要是DBMS上面的东西基本都要考虑并发安全</li>
</ul>
</li>
</ul>
<h3 id="hash-table">Hash Table</h3>
<ul>
<li>
<p>哈希表实现了一个Key $\rightarrow$ Value的关联数组，它提供了平均$O(1)$的操作复杂度（当然最差会是$O(n)$）和$O(n)$的存储复杂度，这理要注意的是$O(1)$是理论上面的，在现实中实现这个数据结构的时候要考虑常数因子的优化</p>
</li>
<li>
<p>哈希表的实现由两部分组成</p>
<ul>
<li>
<p><strong>Hash Function</strong>:如何将较大的值映射到一个较小的空间内，这里要注意碰撞率和计算耗时的关系</p>
<ul>
<li>计算越复杂，耗时越高，碰撞率越低</li>
<li>计算越简单，耗时越低，碰撞率越高</li>
<li>Hash Function理想的情况就是在计算耗时和碰撞率之间取得平衡</li>
</ul>
</li>
<li>
<p><strong>Hashing Scheme</strong>:考虑哈希冲突的时候的处理办法，在扩大哈希表减少冲突和发生冲突时处理方案的复杂性中取得平衡</p>
</li>
</ul>
</li>
</ul>
<h3 id="hash-functions">Hash Functions</h3>
<ul>
<li>
<p><strong>Hash Function</strong>接收的参数应该可以是任意类型的，然后返回一个整数，该函数的输出要是确定性的（相同的参数输出的值要一样）</p>
</li>
<li>
<p><strong>Hash Function</strong>一般不用网安那套加密安全哈希函数，因为不需要保护密钥的内容（这个东西只在DBMS内部使用，没有泄露的风险），我们只关心计算速度和碰撞率</p>
</li>
</ul>
<blockquote>
<p>The current state-of-the-art hash function is <a href="https://xxhash.com" target="_blank" rel="noopener noreffer">Facebook XXHash3</a>.</p>
</blockquote>
<h3 id="static-hashing-schemes">Static Hashing Schemes</h3>
<ul>
<li>
<p>对于一个固定容量的Hash table来说，如果容量满了再次扩容代价很大</p>
</li>
<li>
<p>一般扩容都是给扩容成原来的2倍</p>
</li>
<li>
<p>避免hash冲突是很重要的，一般我们期望元素数=槽数$\times$2</p>
</li>
</ul>
<hr>
<ul>
<li>
<p><strong>Linear Probe Hashing</strong></p>
<ul>
<li>
<p>碰到Hash冲突就把K-V存到下一个槽里面</p>
</li>
<li>
<p>如果下一个槽还碰撞就下下个槽，直到找到空位置</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter7-1.png" title="/img/CMU 15-445 Database Systems/chapter7-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter7-1.png" data-sub-html="<h2>碰撞的处理方法</h2>">
        
    </a><figcaption class="image-caption">碰撞的处理方法</figcaption>
    </figure>
</li>
<li>
<p>删除比较恶心</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter7-2.png" title="/img/CMU 15-445 Database Systems/chapter7-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter7-2.png" data-sub-html="<h2>D因为和C碰撞往下走，现在C被删了，结果查D发现D没有了，出现了错误</h2>">
        
    </a><figcaption class="image-caption">D因为和C碰撞往下走，现在C被删了，结果查D发现D没有了，出现了错误</figcaption>
    </figure>
</li>
<li>
<p>解决方案</p>
<ul>
<li>加上一个Tombstone标志，说明这个地方原来有数据，然后被删除了</li>
<li>Movement：把下边的数据往上挪，但是不能傻瓜式的向上推，hash值是对的就不能动</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Non-unique Keys</strong>:同一个键可能与多个不同的值或元组关联的情况，两种解决方案
<ul>
<li><strong>Separate Linked List</strong>:存储Value的不再是一个值，而是List&lt;V&gt;，这样就可以存储多个值了</li>
<li><strong>Redundant Keys</strong>:将Key和Value结合起来再做hash</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Optimizations</strong>
<ul>
<li><strong>Specialized hash table implementations based on the data type or size of keys</strong>:根据数据结构不同/键大小采取不同的措施，比如字符串，小的字符串我拷贝存一份，大的字符串我存指针或者哈希</li>
<li><strong>Storing metadata in a separate array</strong>:将空槽/墓碑数据集中存在一个bitmap里面，作为哈希表的头文件或者作为一个单独的哈希表，这样避免查找已经删除的键</li>
<li><strong>Maintaining versions for the hash table and its slots</strong>:在哈希表上面删除/分配内存代价很高，所以给哈希表的Value添加一个version字段，只要version不匹配就认为没有这个Value，删数据就不用释放内存了</li>
</ul>
</li>
</ul>
<blockquote>
<p>Google’s absl::flat hash map is a state-of-the-art implementation of Linear Probe Hashing.</p>
</blockquote>
<hr>
<ul>
<li><strong>Cuckoo Hashing</strong>
<ul>
<li>使用多个哈希表，每个哈希表使用的哈希函数整体一样，但是参数不同（就是设定的种子）</li>
<li>一旦发生哈希碰撞，就把原有的值使用别的哈希函数驱赶到别的哈希表中，如果被驱逐的值也发生哈希碰撞就重复上面的过程，直到没有哈希碰撞</li>
<li>使用的很少，现实中这种实现问题很大</li>
</ul>
</li>
</ul>
<h3 id="dynamic-hashing-schemes">Dynamic Hashing Schemes</h3>
<ul>
<li>
<p>如果不知道需要存储数据的量，那么就需要一个能够动态扩容的哈希表</p>
</li>
<li>
<p><strong>Chained Hashing</strong></p>
<ul>
<li>
<p>槽不再是单独的一个槽，而是变成了一个指针，指向一个“桶”，桶能存好多Value，一般也具备扩容的功能，有名的实现是Java的HashMap</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter7-3.png" title="/img/CMU 15-445 Database Systems/chapter7-3.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter7-3.png" data-sub-html="<h2>Chained Hashing模型</h2>">
        
    </a><figcaption class="image-caption"><strong>Chained Hashing</strong>模型</figcaption>
    </figure>
</li>
<li>
<p><strong>Bloom Filters</strong>:布隆过滤器，Redis有讲，用来先过滤一遍不存在的数据</p>
</li>
</ul>
</li>
<li>
<p><strong>Extendible Hashing</strong>:这个也和Java的HashMap思想很像，2的幂次方扩容，每次扩容重排桶中的数据，计算hash的时候因为是2的幂次所以可以用位运算，每次扩容就是参与运算的二进制位变多了一位</p>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter7-4.png" title="/img/CMU 15-445 Database Systems/chapter7-4.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter7-4.png" data-sub-html="<h2>扩容前</h2>">
          
      </a><figcaption class="image-caption">扩容前</figcaption>
      </figure>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter7-5.png" title="/img/CMU 15-445 Database Systems/chapter7-5.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter7-5.png" data-sub-html="<h2>扩容后</h2>">
          
      </a><figcaption class="image-caption">扩容后</figcaption>
      </figure>
</li>
<li>
<p><strong>Linear Hashing</strong></p>
<ul>
<li>
<p>之前的扩容是按照2的幂次扩容，扩容一次需要的代价很大，需要用户等待很多时间</p>
</li>
<li>
<p><strong>Linear Hashing</strong>希望扩容不要那么猛，一点一点慢慢扩容</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter7-6.png" title="/img/CMU 15-445 Database Systems/chapter7-6.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter7-6.png" data-sub-html="<h2>由size = 4扩容到size = 5，分家指针向下移动一位，分家指针上面的槽用旧哈希函数x%n，分家指针下面的槽用新哈希函数x%2n</h2>">
        
    </a><figcaption class="image-caption">由size = 4扩容到size = 5，分家指针向下移动一位，分家指针上面的槽用旧哈希函数x%n，分家指针下面的槽用新哈希函数x%2n</figcaption>
    </figure>
</li>
<li>
<p>分家指针指向原来的槽末尾再扩容就会回到0，此时一轮的扩容已经完成</p>
</li>
</ul>
</li>
</ul>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #06: Buffer Pools</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter6/</link>
    <pubDate>Mon, 08 Apr 2024 20:02:45 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter6/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-06-buffer-pools">Lecture #06: Buffer Pools</h2>
<h3 id="introduction">Introduction</h3>
<ul>
<li>DBMS需要负责管理数据在内存和磁盘之间移动，大多数情况下数据不能在磁盘中被处理，而是需要加载到内存中，处理完成后再写回磁盘，这个过程就需要Buffer Pools来进行管理，使得DBMS的其他部分可以像在内存中处理所有数据那样进行操作</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter6-1.png" title="/img/CMU 15-445 Database Systems/chapter6-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter6-1.png" data-sub-html="<h2>Buffer Pool模型</h2>">
        
    </a><figcaption class="image-caption">Buffer Pool模型</figcaption>
    </figure>
<ul>
<li>一个DBMS需要考虑下面的两个方面
<ul>
<li><strong>Spatial Control</strong>: refers to where pages are physically written on disk. The goal of spatial control is to keep pages
that are used together often as physically close together as possible on disk to possibly help with prefetching and
other optimizations.(写磁盘的时候把需要经常一起用的页尽量写到磁盘的一块地方，这样下次用也能够一把加载到Buffer Pool里面)</li>
<li><strong>Temporal Control</strong>: is deciding when to read pages into memory and when to write them to disk. Temporal control
aims to minimize the number of stalls from having to read data from disk.(何时写回磁盘，对于一些热点写数据没有必要写一次刷一次盘，完全可以写好多次刷一次磁盘，因为刷盘的代价太大了)</li>
</ul>
</li>
</ul>
<h3 id="locks-vs-latches">Locks vs. Latches</h3>
<ul>
<li>
<p>英语和概念性的问题</p>
</li>
<li>
<p><strong>Locks</strong>: A lock is a higher-level, logical primitive that protects the contents of a database (e.g., tuples, tables, databases)
from other transactions. Database systems can expose to the user which locks are being held as queries are run. Locks
need to be able to roll back changes.(逻辑上面的锁，比如行锁/表锁/库锁，不关心底层实现，用于理论上面的讨论，为了防止死锁，一般这种锁都可以回滚)</p>
</li>
<li>
<p><strong>Latches</strong>: A latch is a low-level protection primitive that the DBMS uses for the critical sections in its internal data
structures (e.g., hash tables, regions of memory). Latches are held for only the duration of the operation being made.
Latches do not need to be able to roll back changes. This is often implemented by simple language primitives like
mutexs and/or conditional variables.(Locks的具体实现，比如数据竞争的区域是哪，用互斥锁还是信号量，悲观锁还是乐观锁)</p>
</li>
</ul>
<h3 id="buffer-pool">Buffer Pool</h3>
<ul>
<li>
<p>It is organized as an array of fixed-size pages. Each array entry is called a frame. 缓存池的本质就是内存里面的一块固定的数组，这个里面的一个元素就叫frame了，但是其实和page是一个东西</p>
</li>
<li>
<p><strong>page directory</strong>:在数据库的磁盘上还维护了一个page directory，这个东西存的就是页id到页在磁盘物理位置的映射，所以说这个如果修改了必须写回到磁盘上，这样DBMS重新启动的时候才能找到，他也通常回一直在内存里面，因为你找页必须要先通过page directory去找页的物理位置</p>
</li>
<li>
<p><strong>Buffer Pool Meta-data</strong>:缓存池必须要存储一些meta-data，从而保证正确性和提高缓存池的效率，常见的一些meta-data</p>
<ul>
<li>
<p><strong>page table</strong>:这个是内存中的一个hash表，它的映射是页面id $\rightarrow$ 这个页在缓存池中的帧位置，因为页在缓存池里面的顺序和磁盘中的顺序往往不一致，所以需要page table来做这个额外的间接层，除了页在缓存池中的位置，page table还维护了其他meta-data，比如一个脏标志（说明这个页是不是脏页），引用计数器（有哪几个事务在用它），这个和page directory的一个大的区别就是他不用记在磁盘上</p>
</li>
<li>
<p><strong>dirty-flag</strong>:这个就是上面page table维护的一个页的meta-data之一，当有线程对buffer pool中的某个页面进行修改的时候这个标志会被设置，这提醒这个页在被踢出buffer pool的时候必须要刷盘</p>
</li>
<li>
<p><strong>Pin/reference counter</strong>:这个也是上面page table维护的一个页的meta-data之一，主要是记录有几个线程正在访问该页，线程必须在访问该页之前增加counter，如果counter &gt; 0，那么该页就无法被驱逐，counter不会管理并发事务那些东西，如果当前缓冲池的所有页都无法被踢，而且已经满了，就会抛出OOM(out-of-memory)的错误</p>
</li>
</ul>
</li>
<li>
<p><strong>Memory Allocation Policies</strong></p>
<ul>
<li>
<p>Memory in the database is allocated for the buffer pool according to two policies</p>
</li>
<li>
<p><strong>Global policies</strong>: 考虑所有事务，来找到分配内存的最佳决策</p>
</li>
<li>
<p><strong>local policies</strong>:做出决策的时候只考虑单个事务，即使他不适合整个工作负载，本地策略将帧分配给特定的事务，而不考虑并发事务的行为。但是，它仍然支持事务之间共享帧</p>
</li>
<li>
<p>Most systems use a combination of both global and local policies.</p>
</li>
</ul>
</li>
</ul>
<h3 id="buffer-pool-optimizations">Buffer Pool Optimizations</h3>
<ul>
<li>
<p><strong>Multiple Buffer Pools</strong></p>
<ul>
<li>DBMS可以开好多个缓冲池，比如按照类型分（索引缓冲池，数据缓冲池），同一类似使用hash再分到不同的区域，这样每个缓冲池都可以选择适合自己的存储策略，同时分成多个缓存池也避免了一个缓冲池频繁的锁竞争问题</li>
<li>Object IDs and hashing are two approaches to mapping desired pages to a buffer pool.
<ul>
<li><strong>Object IDs</strong>:维护一个id到缓存池区域的映射，这样根据页的id就能分配到对应的缓存池中，而且这个映射自己维护，你可以把分配的策略做的更细更智能，代价就是这个映射也是额外的内存开销</li>
<li><strong>hashing</strong>:对页的id做hash来确定到那块缓存池</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Pre-fetching</strong>: 根据查询计划来对预取页面进行优化，比如处理第一组页面的时候把第二组页面给预提取到缓冲池中（这个在顺序扫描的时候常用），在索引扫描的时候处理某个叶子页的时候可以把这个叶子页的下一页也预提取到缓冲池中，这都提高了效率（这个下一页都是逻辑上的，不是物理上的）</p>
</li>
<li>
<p><strong>Scan Sharing (Synchronized Scans)</strong>:尽量复用缓冲池里面的数据，比如第一个事务是SELECT ALL FROM A，第二个事务也是SELECT ALL FROM A，这个时候第一个事务把页3~6加载到缓冲池里面了，那第二个事务可以从这个地方跟着第一个事务开始扫，等把后面那些跟着第一个事务扫完之后再去扫前面的表，或者说这个时候有SELECT ALL FROM A LIMIT 100这种事务，可以直接到缓冲池里面找一张表拿100条数据就走（这也是为什么每次查询结果不一样的原因）</p>
</li>
<li>
<p><strong>Buffer Pool Bypass</strong>:全表扫描（可能加SORT），大型JOIN这种东西大概率这次查询完了之后近期不会再差，这种数据除了查询时加载到内存中查询完了就扔出去，来节约缓冲池的资源</p>
</li>
</ul>
<h3 id="buffer-replacement-policies">Buffer Replacement Policies</h3>
<ul>
<li>
<p>要求是准确+快+开销小</p>
</li>
<li>
<p><strong>COLCK</strong>:时钟轮询，如果有frame被访问过给打上标记，时钟循环看每一帧，有标记的清空标记，没有标记证明最近没人访问你，给踢出</p>
</li>
<li>
<p><strong>LRU/LRU-K</strong>:看这两篇就够了</p>
<ul>
<li>
<p><a href="https://jungle430.github.io/posts/cmu-15-445-database-systems/lru_and_lru-k/" target="_blank" rel="noopener noreffer">《LRU and LRU-K》</a></p>
</li>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/622224538" target="_blank" rel="noopener noreffer">《CMU 15-445 P1 LRU-K Replacement Policy》</a></p>
</li>
</ul>
</li>
<li>
<p><strong>localization per query</strong>:驱逐页只驱逐自己事务相关的，防止把其他事务的页给驱逐</p>
</li>
<li>
<p><strong>priority hints</strong>:给一些页上标记，告诉缓存池这页不要随便清理，比如索引的根节点，这种东西轻易不会清理</p>
</li>
<li>
<p><strong>Dirty Pages</strong>:踢出页的时候页是否是脏页对于踢出页时候的处理不一样</p>
<ul>
<li>非脏页：直接删除就行</li>
<li>脏页：要刷回磁盘，当然能写不回去就尽量先不写回去（后面会讲WAL，redo-log），一定要先写回再踢出</li>
</ul>
</li>
</ul>
<h3 id="disk-io-and-os-cache">Disk I/O and OS Cache</h3>
<ul>
<li>操作系统本身也有cache的管理，但是和DBMS要求的差的很多，所以DBMS的缓存管理都是定制化的，不依赖操作系统的调用</li>
</ul>
<h3 id="other-memory-pools">Other Memory Pools</h3>
<ul>
<li>
<p>除了缓存页还会缓存别的数据（比如热点查询数据，这里有点像NoSQL的一些功能了）</p>
<ul>
<li>
<p>Sorting + Join Buffers</p>
</li>
<li>
<p>Query Caches</p>
</li>
<li>
<p>Maintenance Buffers</p>
</li>
<li>
<p>Log Buffers</p>
</li>
<li>
<p>Dictionary Caches</p>
</li>
</ul>
</li>
</ul>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #05: Storage Models &amp; Compression</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter5/</link>
    <pubDate>Mon, 08 Apr 2024 10:31:51 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter5/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-05-storage-models--compression">Lecture #05: Storage Models &amp; Compression</h2>
<h3 id="database-workloads">DataBase WorkLoads</h3>
<ul>
<li>
<p><strong>On-Line Transaction Processing(OLTP)</strong>:Fast operations that only read/update a small amount of data each time.</p>
<ul>
<li>快速操作，事务简单，读/写数据量很小</li>
<li>通常处理的写操作多于读操作</li>
<li>例子：银行转一次钱</li>
<li>往往意味着高并发，比如支付宝，微信支付</li>
</ul>
</li>
<li>
<p><strong>On-Line Analytical Processing(OLAP):</strong> Complex queries that read of a lot of data to computer aggregates</p>
<ul>
<li>一般是公司要对某一段时间的所有数据进行统计分析的时候使用</li>
<li>事务复杂，且要读大量的数据，从现有的大量数据中分析派生出新的数据</li>
<li>典型代表：数仓，深度学习的数据收集（比如常见的深度学习模型的训练）</li>
</ul>
</li>
<li>
<p><strong>Hybrid(混合) Transaction + Analytical Processing(HTAP):</strong> OLTP+OLAP together on the same database instance</p>
<ul>
<li>希望这个数据库两种事务都能应对（兼顾）</li>
<li>很像之前讲的disk和memory的结合体（</li>
</ul>
</li>
<li>
<p>公司方案:<strong>BIFURCATED ENVIRONMENT</strong>：OLTP和OLAP分别布置</p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-1.png" title="/img/CMU 15-445 Database Systems/chapter5-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-1.png" data-sub-html="<h2>OLTP负责对用户的事务处理，在流量低的时候将数据整合到数仓里面，分析师再过来操作数仓进行数据分析</h2>">
        
    </a><figcaption class="image-caption">OLTP负责对用户的事务处理，在流量低的时候将数据整合到数仓里面，分析师再过来操作数仓进行数据分析</figcaption>
    </figure>
<ul>
<li>
<p>HTAP或许能避免上面<strong>BIFURCATED ENVIRONMENT</strong>(要准备两套数据库，而且数据还要从这两套系统中来回迁移)的问题，但是也有可能是两头都跑不好</p>
</li>
<li>
<p>行存的模型适合OLTP，列存(DSM)的模型适合OLAP</p>
</li>
<li>
<p>现在很多主流数据库也会加入列存引擎来处理OLAP的事务</p>
</li>
</ul>
<h3 id="storage-models">Storage Models</h3>
<ul>
<li>这部分主要讲数据库的数据在磁盘上面不同的物理布局，对于不同的场景，不同的布局会有不一样的效果</li>
</ul>
<hr>
<ul>
<li>
<p><strong>N-Ary Storage Model (NSM)</strong></p>
<ul>
<li>
<p><u>The DBMS stores (almost) all attributes for a single tuple contiguously in a single page</u>(一个元组里面是所有属性，连续地存储在一个页中)</p>
</li>
<li>
<p>Also known as a “<strong>row store</strong>”（国内叫“行存”）</p>
</li>
<li>
<p>非常适合OLTP的工作负载，读的东西少，但是一直在频繁的写数据，行存的模型对写数据很友好</p>
</li>
<li>
<p>NSM数据库页面大小通常是硬件页面的常数倍(m $\times$ 4KB)：Oracle(4KB),Postgres(8KB),MySQL(16KB)</p>
</li>
</ul>
</li>
<li>
<p><strong>NSM: PHYSICAL ORGANIZATION</strong></p>
<ul>
<li>
<p>无论是定长还是不定长度，这个NSM都是用的之前的slotted page的存储模型，元组就连续的存储在页里面，再加上一个slot array来做标定，header来存储头部必要的一些信息</p>
</li>
<li>
<p>DBMS区分物理元组的唯一标识：<strong>record id</strong>(page#,slot#)，注意这个<strong>record id</strong>是页标识+槽标识构造的，不是数据库主键/唯一键，一定要区分!</p>
</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-2.png" title="/img/CMU 15-445 Database Systems/chapter5-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-2.png" data-sub-html="<h2>slotted page的物理存储模型</h2>">
        
    </a><figcaption class="image-caption">slotted page的物理存储模型</figcaption>
    </figure>
<ul>
<li><strong>NSM</strong>性能上的缺点
<ul>
<li>进行OLAP的操作的时候会有很多无用的数据，浪费效率</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-3.png" title="/img/CMU 15-445 Database Systems/chapter5-3.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-3.png" data-sub-html="<h2>OLAP往往是所有行的扫描，但是只要其中的几列数据，其他列的数据是无用的，但是DBMS就要为此扫描所有页，大量的I/O造成了效率低下</h2>">
        
    </a><figcaption class="image-caption">OLAP往往是所有行的扫描，但是只要其中的几列数据，其他列的数据是无用的，但是DBMS就要为此扫描所有页，大量的I/O造成了效率低下</figcaption>
    </figure>
<ul>
<li><strong>NSM:SUMMARY</strong>
<ul>
<li><strong>Advantages</strong>
<ul>
<li>Fast inserts, updates, and deletes</li>
<li>Good for queries that need the entire tuple(OLTP)</li>
<li>Can use index-oriented physical storage for clustering</li>
</ul>
</li>
<li><strong>Disadvantages</strong>
<ul>
<li>Not good for scanning large portions of the table and/or a subset of the attributes</li>
<li>Terrible memory locality for OLAP access patterns.(数据分散到了多个页，属性列不是连续的)</li>
<li>Not ideal for compression because of multiple value domains within a single page.(压缩数据靠的是数据的相似性，同一列的数据相似性才高，但是NSM是按行存不同列的数据，每一页数据的相似性很低，很难压缩)</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p><strong>Decomposition Storage Model (DSM)</strong></p>
<ul>
<li>The DBMS stores a single attribute for all tuples contiguously in a block of data.</li>
<li>Also known as a “<strong>column store</strong>”(国内叫“列存”)</li>
<li>非常适合OLAP的工作负载，大量的读取数据，而且往往都要的是某一列属性</li>
<li>DBMS这个时候主要就负责读写的时候拆分和组合属性</li>
</ul>
</li>
<li>
<p><strong>DSM: PHYSICAL ORGANIZATION</strong></p>
<ul>
<li>
<p>Store attributes and metadata (e.g.nulls) in separate arrays of fixedlength values.(固定长度的属性最好存储，数组完美匹配)</p>
</li>
<li>
<p>唯一标识：偏移量</p>
</li>
<li>
<p>难的是处理变长属性，需要在前面在加上一个id数据来做为标识，这样其实造成了数据冗余（id存了好几次）</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-6.png" title="/img/CMU 15-445 Database Systems/chapter5-6.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-6.png" data-sub-html="<h2>属性定长和不定长的两种存储方式</h2>">
        
    </a><figcaption class="image-caption">属性定长和不定长的两种存储方式</figcaption>
    </figure>
</li>
<li>
<p>Maintain a separate file per attribute with a dedicated header area for metadata about the entire column.(一个属性一个文件，加上Header来处理元数据)</p>
</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-4.png" title="/img/CMU 15-445 Database Systems/chapter5-4.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-4.png" data-sub-html="<h2>DSM的文件结构</h2>">
        
    </a><figcaption class="image-caption">DSM的文件结构</figcaption>
    </figure>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-5.png" title="/img/CMU 15-445 Database Systems/chapter5-5.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-5.png" data-sub-html="<h2>OLAP下只需要找对应属性的页，不需要像NSM那样全页扫描</h2>">
        
    </a><figcaption class="image-caption">OLAP下只需要找对应属性的页，不需要像NSM那样全页扫描</figcaption>
    </figure>
<ul>
<li>
<p><strong>DSM:SUMMARY</strong></p>
<ul>
<li><strong>Advantages</strong>
<ul>
<li>Reduces the amount wasted I/O per query because the DBMS only reads the data that it needs.</li>
<li>Faster query processing because of increased locality and cached data reuse.（属性上面的局部性 &gt; 行的局部性）</li>
<li>Better data compression (more on this in a few slides).</li>
</ul>
</li>
<li><strong>Disadvantages</strong>
<ul>
<li>Slow for point queries, inserts, updates, and deletes because of tuple splitting/stitching/reorganization.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>OBSERVATION</strong></p>
<ul>
<li>OLAP往往也要面临JOIN这样的操作，但是DSM的存储模型在JOIN上面的操作不是很优秀</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p><strong>PAX STORAGE MODEL</strong></p>
<ul>
<li>
<p>Partition Attributes Across (PAX) is a <strong>hybrid storage model</strong> that vertically partitions attributes within a database page.</p>
</li>
<li>
<p>The goal is to get the benefit of <strong>faster processing on columnar storage while retaining</strong> the spatial locality benefits of <strong>row storage</strong>.（保留行存优势地前提下，在列处理上面提速来匹配OLAP操作）</p>
</li>
</ul>
</li>
<li>
<p><strong>PAX: PHYSICAL ORGANIZATION</strong></p>
<ul>
<li>水平地将行划分为组，然后将这组的属性进行列存</li>
<li>每个页的Header里面会标明这个页里面每一组的偏移量
<ul>
<li>如果这个文件不可变，Header就存到页脚</li>
</ul>
</li>
<li>每一组都会有自己的<strong>metadata header</strong>(比如标明那一行那个属性是null，其他有关这个组的信息)</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-7.png" title="/img/CMU 15-445 Database Systems/chapter5-7.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-7.png" data-sub-html="<h2>PAX的物理结构</h2>">
        
    </a><figcaption class="image-caption">PAX的物理结构</figcaption>
    </figure>
<h3 id="database-compression">Database Compression</h3>
<ul>
<li>
<p>When a DBMS uses compression, it is always lossless because people don’t like losing data. Any kind of lossy compression must be performed at the application level.（数据库只能做无损压缩，有损压缩只能在应用程序里面做，数据库是绝对不给做的）</p>
</li>
<li>
<p><strong>COMPRESSION GRANULARITY</strong>（压缩的力度）</p>
</li>
</ul>
<h3 id="naïve-compression">NAÏVE COMPRESSION</h3>
<ul>
<li>
<p><strong>Block-Level</strong>：压缩同一个表里面的元组块</p>
</li>
<li>
<p>使用通用的算法来压缩数据</p>
</li>
<li>
<p>压缩的范围仅限于提供的数据</p>
</li>
<li>
<p>LZO (1996), LZ4 (2011), Snappy (2011),Oracle OZIP (2014), Zstd (2015)</p>
</li>
</ul>
<p>需要考虑的因素</p>
<ul>
<li>计算的开销</li>
<li>压缩和解压的速度</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-8.png" title="/img/CMU 15-445 Database Systems/chapter5-8.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-8.png" data-sub-html="<h2>MySQL INNODB的解压过程，把压缩好的数据读到缓存池再解压</h2>">
        
    </a><figcaption class="image-caption">MySQL INNODB的解压过程，把压缩好的数据读到缓存池再解压</figcaption>
    </figure>
<ul>
<li>这个模式的一个弊端就是每次读写数据的时候都先要做解码，效率很低</li>
<li>另一个思路：能不能不解码，而是对查询的数据使用算法变换，然后操作压缩后的数据</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-9.png" title="/img/CMU 15-445 Database Systems/chapter5-9.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-9.png" data-sub-html="<h2>这个就是上面的想法，把SQL中的数据进行变换，然后直接操作压缩的数据</h2>">
        
    </a><figcaption class="image-caption">这个就是上面的想法，把SQL中的数据进行变换，然后直接操作压缩的数据</figcaption>
    </figure>
<h3 id="columnar-compression">COLUMNAR COMPRESSION</h3>
<ul>
<li>
<p><strong>Column-Level</strong>：压缩属性值的列(DSM-only)，也叫<strong>COLUMNAR COMPRESSION</strong>（柱状压缩）</p>
</li>
<li>
<p><strong>Run-length Encoding</strong></p>
<ul>
<li>将单个列中的相同值改为三元组
<ul>
<li>属性的值</li>
<li>该值在这一列的起始位置</li>
<li>该值的元素个数</li>
</ul>
</li>
<li>适合的情景是该列对属性进行智能排序，这样可以获取最大化压缩的机会</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-10.png" title="/img/CMU 15-445 Database Systems/chapter5-10.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-10.png" data-sub-html="<h2>Run-length Encoding算法演示</h2>">
        
    </a><figcaption class="image-caption">Run-length Encoding算法演示</figcaption>
    </figure>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-11.png" title="/img/CMU 15-445 Database Systems/chapter5-11.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-11.png" data-sub-html="<h2>如果只有GROUP BY的操作，那么压缩的会更好</h2>">
        
    </a><figcaption class="image-caption">如果只有GROUP BY的操作，那么压缩的会更好</figcaption>
    </figure>
<ul>
<li><strong>Bit-Packing Encoding</strong>
<ul>
<li>如果整数属性的值很小，那么二进制前面的几位就可以不要</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-12.png" title="/img/CMU 15-445 Database Systems/chapter5-12.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-12.png" data-sub-html="<h2>bit packing压缩方案</h2>">
        
    </a><figcaption class="image-caption">bit packing压缩方案</figcaption>
    </figure>
<ul>
<li><strong>PATCHING/MOSTLY ENCODING</strong>
<ul>
<li>当属性中的大多数值小于对应类型的最大值时，使用更小的数据类型来对其进行存储，对于少数数值很大的值仍然使用原来的数据类型来进行存储</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-13.png" title="/img/CMU 15-445 Database Systems/chapter5-13.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-13.png" data-sub-html="<h2>int32-&gt;int8，Header会标定一下那个数据还是用的int32</h2>">
        
    </a><figcaption class="image-caption">int32-&gt;int8，Header会标定一下那个数据还是用的int32</figcaption>
    </figure>
<ul>
<li>
<p><strong>Bit-map Encoding</strong></p>
<ul>
<li>
<p>对于一些属性，它的值就那些（比如枚举）</p>
</li>
<li>
<p>那直接用位运算存几个bit里面就完全够了</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-14.png" title="/img/CMU 15-445 Database Systems/chapter5-14.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-14.png" data-sub-html="<h2>一共只有Y和N，那直接用两位bit就够了</h2>">
        
    </a><figcaption class="image-caption">一共只有Y和N，那直接用两位bit就够了</figcaption>
    </figure>
</li>
<li>
<p>但是从上面的图上面来看这个模式没有完全压榨二进制位运算的空间（比如只能用01和10，00和11都浪费了），所以在一些情况下压缩不如不压缩</p>
</li>
</ul>
</li>
<li>
<p><strong>Delta Encoding</strong></p>
<ul>
<li>
<p>记录和上一列的差别，不记录实际数据</p>
</li>
<li>
<p>基础值内联到表里面或者单独查询，有这个基础值下面的值都能推断出来了</p>
</li>
<li>
<p>配合<strong>Run-Length-Encoding</strong>压缩效果会更好</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-15.png" title="/img/CMU 15-445 Database Systems/chapter5-15.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-15.png" data-sub-html="<h2>先Delta Encoding再Run-Length-Encoding</h2>">
        
    </a><figcaption class="image-caption">先Delta Encoding再Run-Length-Encoding</figcaption>
    </figure>
</li>
</ul>
</li>
<li>
<p><strong>DICTIONARY COMPRESSION</strong></p>
<ul>
<li>
<p>Replace frequent values with smaller fixed-length codes and then maintain a mapping (dictionary) from the codes to the original values(搞一个K-V的映射，然后把原来数据的V换成长度更小的K)</p>
</li>
<li>
<p>Most widely used native compression scheme in DBMSs.</p>
</li>
<li>
<p>理想的字典查询是希望在单点查询和范围查询上面都有良好的性能</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-16.png" title="/img/CMU 15-445 Database Systems/chapter5-16.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-16.png" data-sub-html="<h2>建一个Hash表，然后压缩原表</h2>">
        
    </a><figcaption class="image-caption">建一个Hash表，然后压缩原表</figcaption>
    </figure>
</li>
<li>
<p>字典需要有两个功能</p>
<ul>
<li>Eecode/Locate：给了Key要能编码</li>
<li>Decode/Extract：给了Value能解压成Key</li>
<li><strong>所以即使上面会用Hash这个词，但是这个结构不能靠Hash函数来实现（Hash只能正着算，不能反向算）</strong></li>
</ul>
</li>
<li>
<p>字典还要保序，不能说编完码之后你原表的数据顺序就变了，因为你要考虑范围查找这种东西</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter5-17.png" title="/img/CMU 15-445 Database Systems/chapter5-17.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter5-17.png" data-sub-html="<h2>如果保序，范围查找对SQL里面的key做一次Hash就可以操作压缩后的数据了</h2>">
        
    </a><figcaption class="image-caption">如果保序，范围查找对SQL里面的key做一次Hash就可以操作压缩后的数据了</figcaption>
    </figure>
</li>
<li>
<p>字典压缩还有一个好处就是如果查询中有DISTINCT这种关键字，那么不需要进行全表扫描，直接去字典里面扫描一遍Value就够了</p>
</li>
<li>
<p>数据结构的选择</p>
<ul>
<li>Array
<ul>
<li>一个数组包含可变长度的字符串，一个数组包含指向映射到前面数组字符串的指针</li>
<li>更新成本很高，只能用在不可变文件中</li>
</ul>
</li>
<li>Hash Table
<ul>
<li>快速，紧凑</li>
<li>无法进行范围查询和前缀查询</li>
</ul>
</li>
<li>B+ Tree
<ul>
<li>比Hash Table要慢，而且占用更多的内存</li>
<li>支持范围查询和前缀查询</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></description>
</item>
</channel>
</rss>
