<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>CMU 15-445 Database Systems - 分类 - Jungle&#39;s Blog</title>
        <link>https://Jungle430.github.io/categories/cmu-15-445-database-systems/</link>
        <description>CMU 15-445 Database Systems - 分类 - Jungle&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>junglece430@gmail.com (Jungle)</managingEditor>
            <webMaster>junglece430@gmail.com (Jungle)</webMaster><lastBuildDate>Mon, 22 Apr 2024 11:11:57 &#43;0800</lastBuildDate><atom:link href="https://Jungle430.github.io/categories/cmu-15-445-database-systems/" rel="self" type="application/rss+xml" /><item>
    <title>CMU 15-445 Lecture #21: Database Crash Recovery</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter21/</link>
    <pubDate>Mon, 22 Apr 2024 11:11:57 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter21/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-21-database-crash-recovery">Lecture #21: Database Crash Recovery</h2>
<h3 id="crash-recovery">Crash Recovery</h3>
<ul>
<li>
<p>The DBMS relies on its recovery algorithms to <strong>ensure database consistency(C), transaction atomicity(A), and durability(D)</strong> despite failures.</p>
</li>
<li>
<p>Each recovery algorithm is comprised of two parts:</p>
<ul>
<li>Actions <strong>during normal</strong> transaction processing to ensure that the DBMS can recover from a failure</li>
<li>Actions <strong>after a failure</strong> to recover the database to a state that ensures the atomicity, consistency, and durability of transactions.</li>
</ul>
</li>
<li>
<p>Check Point的问题</p>
<ul>
<li>性能问题：刷盘的时候整个DBMS都停住了</li>
<li>扫描的时候Check Point前后都要看，也很浪费效率</li>
<li>没有特别合适的刷盘频率，高了频繁小卡，低了定时大卡</li>
</ul>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Algorithms_for_Recovery_and_Isolation_Exploiting_Semantics" target="_blank" rel="noopener noreffer"><strong>Algorithms for Recovery and Isolation Exploiting Semantics(ARIES)</strong></a></p>
<ul>
<li>
<p>Developed at IBM Research in early 1990s for the DB2 DBMS</p>
</li>
<li>
<p>There are three key concepts in the ARIES recovery protocol:</p>
<ul>
<li>
<p><strong>Write Ahead Logging(WAL)</strong>: Any change is recorded in log on stable storage before the database change is written to disk <strong>(STEAL + NO-FORCE).</strong> 写盘策略</p>
</li>
<li>
<p><strong>Repeating History During Redo</strong>: On restart, retrace actions and restore database to exact state before crash.</p>
</li>
<li>
<p><strong>Logging Changes During Undo</strong>: Record undo actions to log to ensure action is not repeated in the event of repeated failures.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="wal-records">WAL Records</h3>
<ul>
<li>Every log record now includes a globally unique log sequence number (LSN).日志的序列号</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter21-1.png" title="/img/CMU 15-445 Database Systems/chapter21-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter21-1.png" data-sub-html="<h2>日志分类</h2>">
        
    </a><figcaption class="image-caption">日志分类</figcaption>
    </figure>
<ul>
<li>
<p>每个数据页会有一个<strong>pageLSN</strong>，记录这一页最新的修改</p>
</li>
<li>
<p>每个系统会有一个<strong>flushedLSN</strong>，前面的进了磁盘，后面的都在内存没有刷盘</p>
</li>
<li>
<p>脏页写回到磁盘的必要条件 $pageLST\le flushedLSN$，这个脏页之前所作的修改必须先要刷到磁盘里面去，它才能刷回到盘里面去</p>
</li>
<li>
<a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter21-2.png" title="/img/CMU 15-445 Database Systems/chapter21-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter21-2.png">
        
    </a>
</li>
<li>
<p>每次刷盘的时候要更新<strong>flushedLSN</strong></p>
</li>
</ul>
<h3 id="normal-execution">Normal Execution</h3>
<ul>
<li>
<p>情景：每个事务都会读和写数据，结果有commit和rollback</p>
</li>
<li>
<p>假设</p>
<ul>
<li>所有的log都在一页里面</li>
<li>写磁盘是原子操作</li>
<li>使用严格2PL</li>
<li>窃取式+非强制</li>
</ul>
</li>
<li>
<p>COMMIT</p>
<ul>
<li>log上面加一条COMMIT</li>
<li>COMMIT之前有关这个事务的所有日志都要刷盘，刷盘是连续写+同步</li>
<li>后面刷脏页的时候会追加一句TXN-END</li>
<li>刷完盘之后的数据在内存里面就可以干掉了</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter21-3.png" title="/img/CMU 15-445 Database Systems/chapter21-3.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter21-3.png" data-sub-html="<h2>COMMIT证明提交成功，TXN-END代表脏页被刷回去了</h2>">
        
    </a><figcaption class="image-caption">COMMIT证明提交成功，TXN-END代表脏页被刷回去了</figcaption>
    </figure></li>
</ul>
</li>
<li>
<p>ROLLBACK</p>
<ul>
<li>
<p>加上prevLSN字段：记录这个事务的上一条日志的地点（类比双链表中的prev指针）</p>
</li>
<li>
<a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter21-4.png" title="/img/CMU 15-445 Database Systems/chapter21-4.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter21-4.png">
        
    </a>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter21-5.png" title="/img/CMU 15-445 Database Systems/chapter21-5.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter21-5.png" data-sub-html="<h2>回滚就是记录相反的日志</h2>">
        
    </a><figcaption class="image-caption">回滚就是记录相反的日志</figcaption>
    </figure>
</li>
<li>
<p>具体操作：</p>
<ul>
<li>
<p>加上ABORT</p>
</li>
<li>
<p>撤销修改，同时追加对应的回滚日志</p>
</li>
<li>
<p>清理做完了加上TXN-END的标志</p>
</li>
<li>
<p>注意：清理的过程是不可能回滚的</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="checkpointing">Checkpointing</h3>
<ul>
<li>
<p>检查点的问题</p>
<ul>
<li>要停止处理新事务，同时所有正在运行的事务都要做完才能刷盘，这个对效率的影响很大</li>
<li>改进：让所有进行中的事务暂停/给所有需要刷盘的数据加锁，而不是等他们做完</li>
</ul>
</li>
<li>
<p><strong>Active Transaction Table (ATT)</strong></p>
<ul>
<li>Checkpointing的时候还在活动的事务的表</li>
<li>One entry per currently active txn.
<ul>
<li>→ txnId: Unique txn identifier.</li>
<li>→ status: The current “mode” of the txn.</li>
<li>→ lastLSN: Most recent LSN created by txn</li>
<li>Remove entry after the TXN-END record.(TXN-END才算不活动)</li>
</ul>
</li>
<li>Txn Status Codes:
<ul>
<li>R → Running</li>
<li>C → Committing</li>
<li>U → Candidate for Undo</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Dirty Page Table (DPT)</strong></p>
<ul>
<li>Checkpointing的时候的脏页</li>
<li>One entry per dirty page in the buffer pool:
<ul>
<li>→ recLSN: The LSN of the log record that first caused the page to be dirty.</li>
</ul>
</li>
</ul>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter21-6.png" title="/img/CMU 15-445 Database Systems/chapter21-6.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter21-6.png" data-sub-html="<h2>记录的时候标注更多信息</h2>">
        
    </a><figcaption class="image-caption">记录的时候标注更多信息</figcaption>
    </figure>
</li>
</ul>
<hr>
<ul>
<li><strong>Fuzzy Checkpoints</strong>
<ul>
<li>Checkpointing的时候其他事务也继续运行</li>
<li>把checkpoint从一个时间点变成一个时间段(POINT -&gt; BEGIN+END)</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter21-7.png" title="/img/CMU 15-445 Database Systems/chapter21-7.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter21-7.png" data-sub-html="<h2>BEGIN&#43;END</h2>">
        
    </a><figcaption class="image-caption">BEGIN+END</figcaption>
    </figure></li>
</ul>
</li>
</ul>
<h3 id="aries-recovery">ARIES Recovery</h3>
<ol>
<li><strong>Analysis</strong>: Read the WAL to identify dirty pages in the buffer pool and active transactions at the time of the crash. At the end of the analysis phase the ATT tells the DBMS which transactions were active at the time of the crash. The DPT tells the DBMS which dirty pages might not have made it to disk.</li>
<li><strong>Redo</strong>: Repeat all actions starting from an appropriate point in the log (even txns that will abort).</li>
<li><strong>Undo</strong>: Reverse the actions of transactions that did not commit before the crash.</li>
</ol>
<ul>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter21-8.png" title="/img/CMU 15-445 Database Systems/chapter21-8.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter21-8.png" data-sub-html="<h2>恢复的过程</h2>">
        
    </a><figcaption class="image-caption">恢复的过程</figcaption>
    </figure></li>
</ul>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #20: Database Logging</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter20/</link>
    <pubDate>Sun, 21 Apr 2024 15:08:57 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter20/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-20-database-logging">Lecture #20: Database Logging</h2>
<h3 id="crash-recovery">Crash Recovery</h3>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter20-1.png" title="/img/CMU 15-445 Database Systems/chapter20-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter20-1.png" data-sub-html="<h2>情景：数据库运行到一半没电了</h2>">
        
    </a><figcaption class="image-caption">情景：数据库运行到一半没电了</figcaption>
    </figure>
<ul>
<li>Recovery algorithms are techniques to ensure <strong>database consistency(C), transaction atomicity(A), and durability(D)</strong> <strong>despite failures(example no power)</strong></li>
<li>The key primitives that used in recovery algorithms are UNDO and REDO. Not all algorithms use both primitives.
<ul>
<li><strong>UNDO</strong>: The process of removing the effects of an incomplete or aborted transaction.</li>
<li><strong>REDO</strong>: The process of re-applying the effects of a committed transaction for durability.</li>
</ul>
</li>
</ul>
<h3 id="failure-classification">FAILURE CLASSIFICATION</h3>
<ul>
<li>
<p><strong>Type #1 – Transaction Failures</strong></p>
<ul>
<li>Logical Errors:→ Transaction cannot complete due to some internal error condition (e.g., integrity constraint violation).</li>
<li>Internal State Errors:→ DBMS must terminate an active transaction due to an error condition (e.g., deadlock).</li>
</ul>
</li>
<li>
<p><strong>Type #2 – System Failures</strong></p>
<ul>
<li>
<p>Software Failure:→ Problem with the OS or DBMS implementation (e.g., uncaught divide-by-zero exception).</p>
</li>
<li>
<p>Hardware Failure:</p>
<ul>
<li>→ The computer hosting the DBMS crashes (e.g., power plug gets pulled).</li>
<li>→ Fail-stop Assumption: Non-volatile storage contents are assumed to not be corrupted by system crash.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Type #3 – Storage Media Failures</strong></p>
<ul>
<li>Non-Repairable Hardware Failure:
<ul>
<li>→ A head crash or similar disk failure destroys all or part of non-volatile storage.</li>
<li>→ Destruction is assumed to be detectable (e.g., disk controller use checksums to detect failures).</li>
<li>The recovery protocol can’t recover from this! Database must be restored from an archived version.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>考虑：磁盘比内存慢的多，所以DBMS的模式是load到内存池后修改，最后刷盘</p>
<ul>
<li><strong>保证的点：只要commit成功，数据永远不会丢（除了硬盘爆炸），如果事务中间失败了，那么这个事务应该就和没发生一样</strong></li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter20-2.png" title="/img/CMU 15-445 Database Systems/chapter20-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter20-2.png" data-sub-html="<h2>方案选择：是否commit后要立即刷盘，刷盘的时候同一页其他未commit的事务修改的数据怎么处理(考虑回滚问题)</h2>">
        
    </a><figcaption class="image-caption">方案选择：是否commit后要立即刷盘，刷盘的时候同一页其他未commit的事务修改的数据怎么处理(考虑回滚问题)</figcaption>
    </figure>
<ul>
<li>
<p><strong>STEAL POLICY</strong></p>
<ul>
<li>STEAL: Is allowed.(别人没提交的数据我也刷)</li>
<li>NO-STEAL: Is not allowed.(别人没提交我就不能刷到磁盘)</li>
</ul>
</li>
<li>
<p><strong>FORCE POLICY</strong></p>
<ul>
<li>FORCE: Is required.(commit后立即刷)</li>
<li>NO-FORCE: Is not required.(不强制要求)</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter20-3.png" title="/img/CMU 15-445 Database Systems/chapter20-3.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter20-3.png" data-sub-html="<h2>NO-STEAL FORCE</h2>">
        
    </a><figcaption class="image-caption">NO-STEAL FORCE</figcaption>
    </figure>
<ul>
<li>NO-STEAL FORCE
<ul>
<li>优点：好实现，不需要undo和redo的操作</li>
<li>缺点：效率低，刷盘频率太高，没有undo和redo那所有的东西都要load到内存池，也很伤害效率，能够修改数据的量收到缓存池大小的限制（缓存池就用来做的数据备份，没有写进磁盘的数据需要全部暂存在缓存池）</li>
</ul>
</li>
</ul>
<h3 id="shadow-paging">Shadow Paging</h3>
<ul>
<li>
<p>具体实现：<strong>SHADOW PAGING</strong></p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter20-4.png" title="/img/CMU 15-445 Database Systems/chapter20-4.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter20-4.png" data-sub-html="<h2>把需要的数据Copy一份再改，改的时候也刷盘，commit之后改指针指向，最后清除原有页</h2>">
        
    </a><figcaption class="image-caption">把需要的数据Copy一份再改，改的时候也刷盘，commit之后改指针指向，最后清除原有页</figcaption>
    </figure>
<ul>
<li>Undo: 把本地复制出来的页全部干掉</li>
<li>Redo: 不需要，commit必须刷盘</li>
</ul>
</li>
<li>
<p>实际应用：SQLITE (PRE-2010)</p>
<ul>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter20-5.png" title="/img/CMU 15-445 Database Systems/chapter20-5.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter20-5.png" data-sub-html="<h2>在硬盘上面留原始版本(undo),commit的时候刷盘</h2>">
        
    </a><figcaption class="image-caption">在硬盘上面留原始版本(undo),commit的时候刷盘</figcaption>
    </figure></li>
</ul>
</li>
<li>
<p>缺点：对磁盘有大量的随机读写，性能不好</p>
</li>
<li>
<p>思路：随机写=&gt;顺序写：WAL</p>
</li>
</ul>
<h3 id="write-ahead-loggingwal">Write-Ahead Logging（WAL）</h3>
<ul>
<li>
<p><strong>With write-ahead logging, the DBMS records all the changes made to the database in a log file (on stable storage) before the change is made to a disk page</strong></p>
</li>
<li>
<p><strong>The log contains sufficient information to perform the necessary undo and redo actions to restore the database after a crash.</strong></p>
</li>
<li>
<p><strong>The DBMS must write to disk the log file records that correspond to changes made to a database object before it can flush that object to disk.</strong></p>
</li>
<li>
<p>Buffer Pool Policy: STEAL + NO-FORCE</p>
</li>
<li>
<p>一般是&lt;BEGIN&gt;打头，&lt;COMMIT&gt;结尾，COMMIT必须是要把所有数据都刷到磁盘里面</p>
</li>
<li>
<p>日志格式</p>
<ul>
<li>
<p>Transaction Id</p>
</li>
<li>
<p>Object Id</p>
</li>
<li>
<p>Before Value (UNDO)</p>
</li>
<li>
<p>After Value (REDO)</p>
</li>
<li>
<p>Not necessary for Before Value and After Value if using append-only MVCC</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter20-6.png" title="/img/CMU 15-445 Database Systems/chapter20-6.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter20-6.png" data-sub-html="<h2>先刷日志再刷盘，commit代表刷日志成功</h2>">
        
    </a><figcaption class="image-caption">先刷日志再刷盘，commit代表刷日志成功</figcaption>
    </figure>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter20-7.png" title="/img/CMU 15-445 Database Systems/chapter20-7.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter20-7.png" data-sub-html="<h2>crash之后靠日志恢复</h2>">
        
    </a><figcaption class="image-caption">crash之后靠日志恢复</figcaption>
    </figure>
</li>
</ul>
</li>
<li>
<p>问题：用户commit你就要把日志刷到盘里面，但是刷盘频率高了又破坏效率</p>
<ul>
<li>优化： group commit: commit的时候卡住，凑够了几个事务再一起刷</li>
</ul>
</li>
</ul>
<h3 id="logging-schemes">Logging Schemes</h3>
<ul>
<li>
<p><strong>Physical Logging:</strong></p>
<ul>
<li>
<p>Record the byte-level changes made to a specific location in the database.</p>
</li>
<li>
<p>Example: git diff</p>
</li>
<li>
<p>缺点：会被写放大(UPDATE ALL FRO A TABLE =&gt; BIG Physical Log)</p>
</li>
</ul>
</li>
<li>
<p><strong>Logical Logging:</strong></p>
<ul>
<li>SQL</li>
<li>缺点：恢复的时候慢，还有SQL自己的缺陷(NOW()函数不能重放，LIMIT不保证次次相同，备库没有主库的索引)</li>
</ul>
</li>
<li>
<p><strong>Physiological Logging</strong></p>
<ul>
<li>基础是物理日志，混合SQL，偏移量换成槽</li>
</ul>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter20-8.png" title="/img/CMU 15-445 Database Systems/chapter20-8.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter20-8.png" data-sub-html="<h2>三种日志</h2>">
        
    </a><figcaption class="image-caption">三种日志</figcaption>
    </figure>
</li>
<li>
<p>MYSQL为什么undo和redo分开：安全，还有就是undo log可以用来做mvcc</p>
</li>
</ul>
<h3 id="checkpoints">Checkpoints</h3>
<ul>
<li>
<p>Blocking / Consistent Checkpoint Protocol:</p>
<ul>
<li>→ Pause all queries.</li>
<li>→ Flush all WAL records in memory to disk.</li>
<li>→ Flush all modified pages in the buffer pool to disk.</li>
<li>→ Write a &lt;CHECKPOINT&gt; entry to WAL and flush to disk.</li>
<li>→ Resume queries</li>
</ul>
</li>
<li>
<p>日志不清理也会爆磁盘</p>
</li>
<li>
<p>crash之后你要知道从哪恢复，类比游戏存档（坐佛/坐火）</p>
</li>
<li>
<p>缓存点停住，把日志和脏页全刷回去，然后在日志里面记上一个&lt;CHECKPOINT&gt;，表示上面的数据都刷盘了</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter20-9.png" title="/img/CMU 15-445 Database Systems/chapter20-9.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter20-9.png" data-sub-html="<h2>注意CHECKPOINT上面有完全提交的和半提交的, T2用redo,T3用undo</h2>">
        
    </a><figcaption class="image-caption">注意CHECKPOINT上面有完全提交的和半提交的, T2用redo,T3用undo</figcaption>
    </figure>
</li>
<li>
<p>T1在检查点之前全刷，不用管，T2检查点前有BEGIN，检查点后COMMIT，用REDO恢复，T3检查点之前有BEGIN，检查点后没有COMMIT，用UNDO恢复</p>
</li>
</ul>
<h3 id="conclusion">CONCLUSION</h3>
<ul>
<li>Write-Ahead Logging is (almost) always the best approach to handle loss of volatile storage.</li>
<li>Use incremental updates (STEAL + NO-FORCE) with checkpoints.</li>
<li>On Recovery: undo uncommitted txns + redo committed txns.</li>
</ul>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #19: Multi-Version Concurrency Control</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter19/</link>
    <pubDate>Sun, 21 Apr 2024 10:39:27 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter19/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-19-multi-version-concurrency-control">Lecture #19: Multi-Version Concurrency Control</h2>
<h3 id="multi-version-concurrency-control">Multi-Version Concurrency Control</h3>
<ul>
<li>
<p>常常作为2PL和T/O的辅助手段</p>
</li>
<li>
<p>The DBMS maintains multiple physical versions of a single logical object in the database（维护多个历史版本（像git））</p>
<ul>
<li>
<p>When a txn writes to an object, the DBMS creates a new version of that object. 不改动，直接创建一个新的版本</p>
</li>
<li>
<p>When a txn reads an object, it reads the newest version that existed when the txn started.</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>First implementations was Rdb/VMS and InterBase at DEC in early 1980s.</p>
<p>→ Both were by Jim Starkey, co-founder of NuoDB.</p>
<p>→ DEC Rdb/VMS is now “Oracle Rdb”.</p>
<p>→ InterBase was open-sourced as Firebird.</p>
</blockquote>
<ul>
<li>
<p>解决的问题</p>
<ul>
<li>Writers do not block readers.</li>
<li>Readers do not block writers.</li>
<li>我去上面读历史版本就是了</li>
</ul>
</li>
<li>
<p>Read-only txns can read a consistent snapshot without acquiring locks. 好像在读静态数据</p>
<ul>
<li>Use timestamps to determine visibility.用时间戳来确定可见性</li>
<li>MVCC naturally supports Snapshot Isolation (SI).天然支持快照隔离读</li>
</ul>
</li>
<li>
<p>Easily support time-travel queries.可以读取某一个时刻的历史版本，和IDE退到昨天的代码很像（其他方案很难做到，会把历史数据直接给写没）</p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter19-1.png" title="/img/CMU 15-445 Database Systems/chapter19-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter19-1.png" data-sub-html="<h2>MVCC 写</h2>">
        
    </a><figcaption class="image-caption">MVCC 写</figcaption>
    </figure>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter19-2.png" title="/img/CMU 15-445 Database Systems/chapter19-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter19-2.png" data-sub-html="<h2>MVCC 读</h2>">
        
    </a><figcaption class="image-caption">MVCC 读</figcaption>
    </figure>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter19-3.png" title="/img/CMU 15-445 Database Systems/chapter19-3.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter19-3.png" data-sub-html="<h2>防止级联回滚，只读最新的commit数据</h2>">
        
    </a><figcaption class="image-caption">防止级联回滚，只读最新的commit数据</figcaption>
    </figure>
<ul>
<li>从上面的一张图可以看到T1和T2没法做到完全串行化，T2没有读到T1commit上去的数据，所以说只靠MVCC做不到完全串行化，Oracle最高隔离级别就是上面的图，快照隔离</li>
</ul>
<hr>
<ul>
<li>There are five important MVCC design considerations:
<ol>
<li>Concurrency Control Protocol</li>
<li>Version Storage</li>
<li>Garbage Collection</li>
<li>Index Management</li>
<li>Deletes</li>
</ol>
</li>
</ul>
<hr>
<ul>
<li><strong>Concurrency Control Protocol</strong>
<ul>
<li><strong>Approach #1: Timestamp Ordering</strong>: Assign txns timestamps that determine serial order.</li>
<li><strong>Approach #2: Optimistic Concurrency Control</strong>: Three-phase protocol from last class,Use private workspace for new versions.</li>
<li><strong>Approach #3: Two-Phase Locking</strong>: Txns acquire appropriate lock on physical version before they can read/write a logical tuple.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="design-consideration-version-storage">Design consideration: Version Storage</h3>
<ul>
<li><strong>Version Storage</strong>
<ul>
<li>
<p>The DBMS uses the tuples’ pointer field to create a version chain per logical tuple</p>
<ul>
<li>This allows the DBMS to find the version that is visible to a particular txn at runtime.</li>
<li>Indexes always point to the “head” of the chain.</li>
</ul>
</li>
<li>
<p><strong>Approach #1: Append-Only Storage</strong>: New versions are appended to the same table space.</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter19-4.png" title="/img/CMU 15-445 Database Systems/chapter19-4.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter19-4.png" data-sub-html="<h2>Append-Only Storage</h2>">
        
    </a><figcaption class="image-caption">Append-Only Storage</figcaption>
    </figure>
<ul>
<li>两种插法：头插法和尾插法，头插法搜索效率高（大部分txn要最新的数据）</li>
</ul>
</li>
<li>
<p><strong>Approach #2: Time-Travel Storage</strong>: Old versions are copied to separate table space.</p>
<ul>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter19-5.png" title="/img/CMU 15-445 Database Systems/chapter19-5.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter19-5.png" data-sub-html="<h2>Time-Travel Storage</h2>">
        
    </a><figcaption class="image-caption">Time-Travel Storage</figcaption>
    </figure></li>
</ul>
</li>
<li>
<p><strong>Approach #3: Delta Storage</strong>: The original values of the modified attributes are copied into a separate delta record space.</p>
<ul>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter19-6.png" title="/img/CMU 15-445 Database Systems/chapter19-6.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter19-6.png" data-sub-html="<h2>Delta Storage就是Time-Travel Storage的省空间版本，只存增量</h2>">
        
    </a><figcaption class="image-caption">Delta Storage就是Time-Travel Storage的省空间版本，只存增量</figcaption>
    </figure></li>
<li>MySQL用的就是这个方案</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="design-consideration-garbage-collection">Design consideration: Garbage Collection</h3>
<ul>
<li>
<p><strong>Garbage Collection</strong></p>
<ul>
<li>
<p>历史版本不能一直存着（那样存储空间就会被严重浪费），所以需要定期回收无用的历史版本</p>
</li>
<li>
<p>怎么判断无用？</p>
<ul>
<li>现在运行的事务都看不到这个版本了(Snapshot Isolation)</li>
<li>创建这个版本的事务回滚了</li>
</ul>
</li>
<li>
<p>两个问题</p>
<ul>
<li>怎么发现过期的版本?</li>
<li>决定何时回收才能保证内存安全?</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Approach #1: Tuple-level</strong></p>
<ul>
<li>
<p>Find old versions by examining tuples directly.</p>
</li>
<li>
<p>Background Vacuuming vs. Cooperative Cleaning</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter19-8.png" title="/img/CMU 15-445 Database Systems/chapter19-8.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter19-8.png" data-sub-html="<h2>Background Vacuuming:后台清理</h2>">
        
    </a><figcaption class="image-caption">Background Vacuuming:后台清理</figcaption>
    </figure>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter19-9.png" title="/img/CMU 15-445 Database Systems/chapter19-9.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter19-9.png" data-sub-html="<h2>用位图表面那些页被更新过，只扫被更新过的页，这样可以减少GC的压力</h2>">
        
    </a><figcaption class="image-caption">用位图表面那些页被更新过，只扫被更新过的页，这样可以减少GC的压力</figcaption>
    </figure>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter19-10.png" title="/img/CMU 15-445 Database Systems/chapter19-10.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter19-10.png" data-sub-html="<h2>Cooperative Cleaning:查询的时候顺便清理</h2>">
        
    </a><figcaption class="image-caption">Cooperative Cleaning:查询的时候顺便清理</figcaption>
    </figure>
</li>
</ul>
</li>
<li>
<p><strong>Approach #2: Transaction-level</strong></p>
<ul>
<li>Txns keep track of their old versions so the DBMS does not have to scan tuples to determine visibility</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter19-11.png" title="/img/CMU 15-445 Database Systems/chapter19-11.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter19-11.png" data-sub-html="<h2>事务记录自己改了什么，GC定时间戳去扫描事务的操作记录然后清理无用数据</h2>">
        
    </a><figcaption class="image-caption">事务记录自己改了什么，GC定时间戳去扫描事务的操作记录然后清理无用数据</figcaption>
    </figure></li>
</ul>
</li>
</ul>
<h3 id="design-consideration-index-management">Design consideration: Index Management</h3>
<ul>
<li>
<p>Primary key indexes point to version chain head</p>
</li>
<li>
<p>修改主键=先删除后插入</p>
</li>
<li>
<p>Secondary indexes</p>
<ul>
<li>
<p><strong>Approach #1: Logical Pointers:</strong> 记录数据的逻辑地址，比如主键的值</p>
</li>
<li>
<p><strong>Approach #2: Physical Pointers:</strong> 记录物理地址</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter19-12.png" title="/img/CMU 15-445 Database Systems/chapter19-12.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter19-12.png" data-sub-html="<h2>指向物理地址带来的一个严重的后果是如果版本链需要更新，那么一大批二级索引指向版本链的pointer也要更新</h2>">
        
    </a><figcaption class="image-caption">指向物理地址带来的一个严重的后果是如果版本链需要更新，那么一大批二级索引指向版本链的pointer也要更新</figcaption>
    </figure>
</li>
<li>
<p>逻辑地址就没有上面的毛病，只需要改主键索引，辅助索引就不需要变</p>
</li>
<li>
<p>还有一个折中的方案就是在物理地址索引和版本链之间加上一个表做索引到版本链的代理</p>
</li>
</ul>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter19-13.png" title="/img/CMU 15-445 Database Systems/chapter19-13.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter19-13.png" data-sub-html="<h2>删除后再插入也会出现问题</h2>">
        
    </a><figcaption class="image-caption">删除后再插入也会出现问题</figcaption>
    </figure>
</li>
<li>
<p>Delete</p>
<ul>
<li>Approach #1: Deleted Flag: Maintain a flag to indicate that the logical tuple has been deleted after the newest physical version. This can either be in the tuple header or a separate column.</li>
<li>Approach #2: Tombstone Tuple: Create an empty physical version to indicate that a logical tuple is deleted. Use a separate pool for tombstone tuples with only a special bit pattern in version chain pointer to reduce storage overhead.</li>
</ul>
</li>
<li>
<a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter19-14.png" title="/img/CMU 15-445 Database Systems/chapter19-14.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter19-14.png">
        
    </a>
</li>
</ul>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #18: Timestamp Ordering Concurrency Control</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter18/</link>
    <pubDate>Sat, 20 Apr 2024 20:07:38 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter18/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-18-timestamp-ordering-concurrency-control">Lecture #18: Timestamp Ordering Concurrency Control</h2>
<h3 id="timestamp-ordering-concurrency-control">Timestamp Ordering Concurrency Control</h3>
<ul>
<li>
<p>纯用锁很影响性能，锁是一个悲观的方法</p>
</li>
<li>
<p>乐观的方法：用时间戳</p>
</li>
<li>
<p>If $TS(T_i) &lt; TS(T_j)$, then the DBMS must ensure that the execution schedule is equivalent to the serial schedule where $T_i$appears before $T_j$ .</p>
</li>
<li>
<p>Multiple implementation strategies:</p>
<ul>
<li>→ System/Wall Clock.:不可能完全准确，一般不用</li>
<li>→ Logical Counter.:单机系统一般用这个</li>
<li>→ Hybrid.:分布式系统用这个</li>
</ul>
</li>
</ul>
<h3 id="basic-timestamp-ordering-basic-to">Basic Timestamp Ordering (BASIC T/O)</h3>
<ul>
<li>
<p>Every object X is tagged with timestamp of the last txn that successfully did read/write:时间戳也分两种</p>
<ul>
<li>→ W-TS(X) – Write timestamp on X</li>
<li>→ R-TS(X) – Read timestamp on X</li>
</ul>
</li>
<li>
<p>Check timestamps for every operation:</p>
<ul>
<li>→ If txn tries to access an object <strong>“from the future”</strong>, it aborts and restarts.(不能操作“未来”的数据)</li>
</ul>
</li>
<li>
<p><strong>BASIC T/O – READS</strong></p>
<ul>
<li>Don’t read stuff from the “future.”</li>
<li>Action: Transaction Ti wants to read object X.</li>
<li>If TS(Ti) &lt; W-TS(X), this violates the timestamp order of Ti with regard to the writer of X.
<ul>
<li>→ Abort Ti and restart it with a new TS.</li>
</ul>
</li>
<li>Else:
<ul>
<li>→ Allow Ti to read X.</li>
<li>→ Update R-TS(X) to max(R-TS(X), TS(Ti))</li>
<li>→ Make a local copy of X to ensure repeatable reads for Ti.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>BASIC T/O – WRITES</strong></p>
<ul>
<li>Can’t write if a future transaction has read or written to the object.(不能写未来读过和写过的数据)</li>
<li>Action: Transaction Ti wants to write object X.</li>
<li>If TS(Ti) &lt; R-TS(X) or TS(Ti) &lt; W-TS(X)
<ul>
<li>→ Abort and restart Ti.</li>
</ul>
</li>
<li>Else:
<ul>
<li>→ Allow Ti to write X and update W-TS(X)</li>
<li>→ Also, make a local copy of X to ensure repeatable reads.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Thomas Write Rule</strong></p>
<ul>
<li>对上述理论进行优化</li>
<li>If TS(Ti) &lt; R-TS(X) (未来有事务读了这个数据)
<ul>
<li>Abort and Restart Ti</li>
</ul>
</li>
<li>If TS(Ti) &lt; R-WS(X) (未来有事务写了这个数据，等效成我写了然后未来被覆盖掉了)
<ul>
<li>The DBMS can instead ignore the write and allow the transaction to continue instead of aborting and restarting it. This is called the Thomas Write Rule.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>BASIC T/O总结</p>
<ul>
<li>优点：无锁，无死锁</li>
<li>缺点：对于长的事务可能会饥饿（一直rollback），前面的事务一旦修改数据后回滚那么后面的事务会读到错误的数据，读数据的时候需要copy一份到本地，如果读的数据过多，那么开销会很大</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter18-1.png" title="/img/CMU 15-445 Database Systems/chapter18-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter18-1.png" data-sub-html="<h2>事务2的数据来源于事务1，事务1一旦回滚那么无法恢复事务2</h2>">
        
    </a><figcaption class="image-caption">事务2的数据来源于事务1，事务1一旦回滚那么无法恢复事务2</figcaption>
    </figure>
<h3 id="optimistic-concurrency-control-occ">Optimistic Concurrency Control (OCC)</h3>
<ul>
<li>Also based on timestamp</li>
</ul>
<hr>
<ul>
<li>
<p><u>The DBMS creates a private workspace for each txn.</u></p>
<ul>
<li>→ Any object read is copied into workspace.</li>
<li>Modifications are applied to workspace.(If data is wried, only applied to private workspace, no need to be wried to DBMS)</li>
</ul>
</li>
<li>
<p>When a txn commits, the DBMS compares workspace write set to see whether it conflicts with other txns.(提交的时候DBMS看你workspace里面写的数据，和其他事务对比看看有无冲突)</p>
</li>
<li>
<p>If there are no conflicts, the write set is installed into the “global” database.(无冲突一把全部写回到数据库里面)</p>
</li>
</ul>
<hr>
<ul>
<li><strong>OCC PHASES</strong>
<ul>
<li><strong>#1 – Read Phase:</strong> Track the read/write sets of txns and store their writes in a private workspace.</li>
<li><strong>#2 – Validation Phase:</strong> When a txn commits, check whether it conflicts with other txns.</li>
<li><strong>#3 – Write Phase:</strong> If validation succeeds, apply private changes to database. Otherwise abort and restart the txn.</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter18-2.png" title="/img/CMU 15-445 Database Systems/chapter18-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter18-2.png" data-sub-html="<h2>OCC在提交的时候才会分配时间戳</h2>">
        
    </a><figcaption class="image-caption">OCC在提交的时候才会分配时间戳</figcaption>
    </figure>
<ul>
<li>
<p><strong>OCC – READ PHASE</strong></p>
<ul>
<li>Track the read/write sets of txns and store their writes in a private workspace.</li>
<li>The DBMS copies every tuple that the txn accesses from the shared database to its workspace ensure repeatable reads.</li>
</ul>
</li>
<li>
<p><strong>OCC – VALIDATION PHASE</strong></p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter18-3.png" title="/img/CMU 15-445 Database Systems/chapter18-3.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter18-3.png" data-sub-html="<h2>VALIDATION PHASE的决策图，不能提交的时候发现后面的事务读/写了自己写了的数据（因为按照串行的理论，应该是后面的事务要读自己提交后的数据，但是自己还没提交，后面的事务读的是自己之前的数据！）</h2>">
        
    </a><figcaption class="image-caption">VALIDATION PHASE的决策图，不能提交的时候发现后面的事务读/写了自己写了的数据（因为按照串行的理论，应该是后面的事务要读自己提交后的数据，但是自己还没提交，后面的事务读的是自己之前的数据！）</figcaption>
    </figure>
<ul>
<li><strong>Approach #1: Backward Validation</strong>：和前面的历史数据做校验</li>
<li><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter18-4.png" title="/img/CMU 15-445 Database Systems/chapter18-4.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter18-4.png">
        
    </a></li>
<li><strong>Approach #2: Forward Validation</strong>：和未来的事务做校验</li>
<li><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter18-5.png" title="/img/CMU 15-445 Database Systems/chapter18-5.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter18-5.png">
        
    </a></li>
</ul>
</li>
<li>
<p><strong>OCC – WRITE PHASE</strong></p>
<ul>
<li>Serial Commits: → Use a global latch to limit a single txn to be in the Validation/Write phases at a time.(直接锁全表写，一是为了解决并发问题，二来由于写的数据都准备好了，所以写耗费的时间很短，对并发度的影响不高)</li>
</ul>
</li>
<li>
<p>OCC works well when the # of conflicts is low:</p>
<ul>
<li>→ All txns are read-only (ideal).</li>
<li>→ Txns access disjoint subsets of data.</li>
</ul>
</li>
<li>
<p>If the database is large and the workload is not skewed, then there is a low probability of conflict, so again locking is wasteful.</p>
</li>
<li>
<p>OCC问题</p>
<ul>
<li>本地Copy带来的额外开销</li>
<li>commit的时候校验的逻辑很麻烦，消耗性能</li>
<li>写的步骤是锁表的，也可能会称为性能瓶颈</li>
<li>一旦出了问题前面干的全部回退，这也是一种浪费，2PL能够执行到一半发现死锁直接让这个事务回退，损失就比OCC要小</li>
</ul>
</li>
</ul>
<h3 id="dynamic-databases-and-the-phantom-problem">Dynamic Databases and The Phantom Problem</h3>
<ul>
<li>2PL和OCC在完全串行化上面都有BUG。。。$\rightarrow$ 幻读</li>
<li>前面讨论的问题都是read和update的问题，但是没有讨论insert和delete的问题</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter18-6.png" title="/img/CMU 15-445 Database Systems/chapter18-6.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter18-6.png" data-sub-html="<h2>幻读的情景</h2>">
        
    </a><figcaption class="image-caption">幻读的情景</figcaption>
    </figure>
<ul>
<li>2PL和OCC有这个BUG的原因：我只能控制现存的数据，但是不管数据的插入/删除</li>
</ul>
<hr>
<ul>
<li>
<p><strong>THE PHANTOM PROBLEM</strong></p>
</li>
<li>
<p><strong>Approach #1: Re-Execute Scans</strong></p>
<ul>
<li>对可能产生幻读的行为(SELECT … FROM … GROUP BY …/insert/delete)进行记录，然后在提交的时候再扫描一遍检测有无并发的问题</li>
<li>缺点：这种扫描开销过大，性能上接受不了</li>
</ul>
</li>
<li>
<p><strong>Approach #2: Predicate Locking</strong></p>
<ul>
<li>
<p>最早由System R发明</p>
</li>
<li>
<p>Shared lock on the predicate in a WHERE clause of a SELECT query.</p>
</li>
<li>
<p>Exclusive lock on the predicate in a WHERE clause of any UPDATE, INSERT, or DELETE query</p>
</li>
<li>
<p>It is rarely implemented in systems; an example of a system that uses it is HyPer (precision locking).</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter18-7.jpg" title="/img/CMU 15-445 Database Systems/chapter18-7.jpg" data-thumbnail="/img/CMU 15-445 Database Systems/chapter18-7.jpg" data-sub-html="<h2>谓词锁控制数据竞争</h2>">
        
    </a><figcaption class="image-caption">谓词锁控制数据竞争</figcaption>
    </figure>
</li>
</ul>
</li>
<li>
<p><strong>Approach #3: Index Locking</strong></p>
<ul>
<li>有索引给索引上锁，没索引就要加大的列锁/表锁了</li>
</ul>
</li>
<li>
<p>MySQL的解决方案：间隙锁</p>
</li>
</ul>
<h3 id="isolation-levels">Isolation Levels</h3>
<ul>
<li>
<p>数据库很难做到完全串行，而且很多业务也不需要完全串行，所以有不同的隔离级别</p>
</li>
<li>
<p><strong>Isolation Levels (Strongest to Weakest):</strong></p>
<ul>
<li>
<p><strong>SERIALIZABLE</strong>: No Phantoms, all reads repeatable, and no dirty reads.</p>
<ul>
<li>Possible implementation: Index locks + Strict 2PL.</li>
</ul>
</li>
<li>
<p><strong>REPEATABLE READS</strong>: Phantoms may happen.</p>
<ul>
<li>Possible implementation: Strict 2PL.</li>
</ul>
</li>
<li>
<p><strong>READ-COMMITTED</strong>: Phantoms and unrepeatable reads may happen.</p>
<ul>
<li>Possible implementation: Strict 2PL for exclusive locks, immediate release of the shared lock after a read.</li>
</ul>
</li>
<li>
<p><strong>READ-UNCOMMITTED</strong>: All anomalies may happen.</p>
<ul>
<li>Possible implementation: Strict 2PL for exclusive locks, no shared locks for reads.</li>
</ul>
</li>
</ul>
</li>
<li>
<a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter18-8.png" title="/img/CMU 15-445 Database Systems/chapter18-8.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter18-8.png">
        
    </a>
</li>
<li>
<a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter18-9.png" title="/img/CMU 15-445 Database Systems/chapter18-9.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter18-9.png">
        
    </a>
</li>
<li>
<p>如果显式声明一个表是READ ONLY的话，那么数据库会进行优化（不加锁），还有的数据库会自动检测，如果没有写的操作会自动优化</p>
</li>
</ul>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #17: Two-Phase Locking</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter17/</link>
    <pubDate>Fri, 19 Apr 2024 17:58:06 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter17/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-17-two-phase-locking">Lecture #17: Two-Phase Locking</h2>
<h3 id="transaction-locks">Transaction Locks</h3>
<ul>
<li>
<p>在操作数据的时候通过DBMS的锁管理器给数据上一把锁，这样就可以避免并发的数据竞争问题</p>
</li>
<li>
<p>但是这个锁怎么加怎么解的方案需要设计</p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter17-1.png" title="/img/CMU 15-445 Database Systems/chapter17-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter17-1.png" data-sub-html="<h2>利用锁保证数据安全</h2>">
        
    </a><figcaption class="image-caption">利用锁保证数据安全</figcaption>
    </figure>
<ul>
<li>
<p><strong>Lock Types</strong></p>
<ul>
<li><strong>S-LOCK</strong>: Shared locks for reading(Reading Lock)</li>
<li><strong>X-LOCK</strong>: Exclusive locks for writing(Writing Lock)</li>
</ul>
</li>
<li>
<p>仅仅W(R)的时候上锁，修改完了解锁是无法修复串行化带来的问题，因为这个操作在一个事务里面只是一段，没有锁这个事务</p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter17-2.png" title="/img/CMU 15-445 Database Systems/chapter17-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter17-2.png" data-sub-html="<h2>lock -&gt; W(R) -&gt; unlock下的串行问题</h2>">
        
    </a><figcaption class="image-caption">lock -&gt; W(R) -&gt; unlock下的串行问题</figcaption>
    </figure>
<h3 id="two-phase-locking2pl">Two-Phase Locking(2PL)</h3>
<ul>
<li>这个就是后面的研究人员为了避免上面加锁还是没有解决并发问题提出来的一个理论，这个加锁的理论和上面最大的不同就是不用预先知道整个事务的全貌（前面的加锁方案好多都是事后诸葛亮，但是放在真实场景下你又不可能回滚去干这玩意）</li>
<li>2PL分为两个阶段
<ul>
<li><strong>Phase #1– Growing</strong>: In the growing phase, each transaction requests the locks that it needs from the DBMS’s lock manager. The lock manager grants/denies these lock requests.</li>
<li><strong>Phase #2– Shrinking</strong>: Transactions enter the shrinking phase immediately after they release their first
lock. In the shrinking phase, transactions are only allowed to release locks. They are not allowed to acquire
new ones.</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter17-3.png" title="/img/CMU 15-445 Database Systems/chapter17-3.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter17-3.png" data-sub-html="<h2>2PL Two Phases</h2>">
        
    </a><figcaption class="image-caption">2PL Two Phases</figcaption>
    </figure>
<ul>
<li>2PL的问题: <strong>cascading aborts</strong></li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter17-4.png" title="/img/CMU 15-445 Database Systems/chapter17-4.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter17-4.png" data-sub-html="<h2>Shrinking阶段如果Rollback，会造成其他事务读到了你上面修改过但未commit的数据</h2>">
        
    </a><figcaption class="image-caption">Shrinking阶段如果Rollback，会造成其他事务读到了你上面修改过但未commit的数据</figcaption>
    </figure>
<ul>
<li>Solution: <strong>Strong Strict 2PL (aka Rigorous 2PL)</strong></li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter17-5.png" title="/img/CMU 15-445 Database Systems/chapter17-5.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter17-5.png" data-sub-html="<h2>Strong Strict 2PL解决了cascading aborts问题</h2>">
        
    </a><figcaption class="image-caption">Strong Strict 2PL解决了cascading aborts问题</figcaption>
    </figure>
<hr>
<h3 id="deadlock-handling">Deadlock Handling</h3>
<ul>
<li>2PL的另一个问题: <strong>Dead-Locks</strong></li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter17-6.png" title="/img/CMU 15-445 Database Systems/chapter17-6.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter17-6.png" data-sub-html="<h2>Strong Strict 2PL解决不了Dead-Lock的问题，出来环锁基本就解不开了</h2>">
        
    </a><figcaption class="image-caption">Strong Strict 2PL解决不了Dead-Lock的问题，出来环锁基本就解不开了</figcaption>
    </figure>
<ul>
<li>
<p>Two ways of dealing with deadlocks:</p>
<ul>
<li>
<p>→ Approach #1: <strong>Deadlock Detection</strong>:DBMS会维护一个waits-for graph来描述所有并发的事务谁在等谁的锁</p>
<ul>
<li>Nodes are transactions</li>
<li>Edge from $T_i$ to $T_j$ if $T_i$ is waiting for $T_j$ to release a lock.</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter17-7.png" title="/img/CMU 15-445 Database Systems/chapter17-7.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter17-7.png" data-sub-html="<h2>The system periodically checks for cycles in waits-for graph and then decides how to break it.</h2>">
        
    </a><figcaption class="image-caption">The system periodically checks for cycles in waits-for graph and then decides how to break it.</figcaption>
    </figure></li>
<li>When the DBMS detects a deadlock, it will <strong>select a “victim” transaction to rollback(rollback or restart) to break the cycle.</strong></li>
<li>权衡: 检测周期和死锁解开时间反相关，和开销正相关，还有就是干掉那个事务(执行时间，young还是old，执行了几条SQL，加了几个锁)</li>
<li><strong>Deadlock handling: rollback length</strong>
<ul>
<li>Approach #1: <strong>Completely</strong> → Rollback entire txn and tell the application it was aborted.</li>
<li>Approach #2: <strong>Partial (Savepoints)</strong> → DBMS rolls back a portion of a txn (to break deadlock) and then attempts to re-execute the undone queries.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>→ Approach #2: <strong>Deadlock Prevention</strong></p>
<ul>
<li>
<p>给每个事务加上时间戳，越靠前的事务越老，越靠后的事务越年轻</p>
</li>
<li>
<p>Older Timestamp = Higher Priority (e.g., T1 &gt; T2)</p>
</li>
<li>
<p><strong>Wait-Die (“Old Waits for Young”)</strong>:</p>
<ul>
<li>If requesting txn has higher priority than holding txn, then requesting txn waits for holding txn. (老事务碰到年轻的事务占有锁，就等到年轻的事务解锁)</li>
<li>Otherwise requesting txn aborts.(反之年轻的事务等老事务的锁，直接rollback自杀)</li>
</ul>
</li>
<li>
<p><strong>Wound-Wait (“Young Waits for Old”)</strong></p>
<ul>
<li>If requesting txn has higher priority than holding txn, then holding txn aborts and releases lock(老的事务要锁，发现整个锁被年轻的事务持有，直接rollback年轻的事务然后抢锁)</li>
<li>Otherwise requesting txn waits.(年轻的事务发现锁在老的事务哪里，那就等老的事务解锁)</li>
</ul>
</li>
<li>
<p>这个主要的思路就是解决了构成死锁条件里面“持有并等待”的条件，冲突了直接开抢</p>
</li>
<li>
<p>注意: restart的txn的时间戳用上次的时间戳，不然可能会造成饥饿</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="lock-granularities">Lock Granularities</h3>
<ul>
<li>
<p>获取锁的时候是获取属性锁，行锁，表锁，还是库锁？整个需要DBMS来负责，需要保证你加锁的数量尽可能小(10亿行锁 vs 一张表锁)，也需要考虑对并发度的影响</p>
</li>
<li>
<p><strong>Intention Lock</strong>:高层级的锁会有标记来判断下面有没有加锁的（比如表锁会记录下面的行有没有加锁的），节省了向下检索的效率</p>
<ul>
<li>意向锁也有S锁和X锁</li>
</ul>
</li>
<li>
<p>分层的锁在实际工程中相当好用</p>
</li>
<li>
<p><strong>LOCK ESCALATION</strong></p>
<ul>
<li>如果下层的锁过多了，那么DBMS就会自动升级成高层的锁（怎么和JVM的锁升级机制的思想很像？）</li>
</ul>
</li>
<li>
<p>一般加锁都是DBMS自动负责的，但是用户可以用SQL手动来加锁</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-mysql" data-lang="mysql"><span class="line"><span class="cl"><span class="k">LOCK</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="o">&lt;</span><span class="k">table</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="n">mode</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="o">&lt;</span><span class="k">table</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="o">&lt;</span><span class="n">qualification</span><span class="o">&gt;</span><span class="w"> </span><span class="k">FOR</span><span class="w"> </span><span class="k">UPDATE</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">#这样告诉了MYSQL这个不加读锁，加写锁(后面要UPDATE)
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="conclusion">CONCLUSION</h3>
<ul>
<li>
<p>2PL is used in almost every DBMS.</p>
</li>
<li>
<p>Automatically generates correct interleaving:</p>
<ul>
<li>Locks + protocol (2PL, SS2PL &hellip;)</li>
<li>Deadlock detection + handling</li>
<li>Deadlock prevention</li>
</ul>
</li>
</ul>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #16: Concurrency Control Theory</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter16/</link>
    <pubDate>Mon, 15 Apr 2024 16:04:09 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter16/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-16-concurrency-control-theory">Lecture #16: Concurrency Control Theory</h2>
<h3 id="motivation">Motivation</h3>
<ul>
<li>Lost Update Problem (Concurrency Control):数据竞争</li>
<li>Durability Problem (Recovery):故障恢复</li>
</ul>
<h3 id="transactions">Transactions</h3>
<ul>
<li>
<p>特点：ACID</p>
</li>
<li>
<p>Atomicity: Atomicity ensures that either all actions in the transaction happen, or none happen.</p>
</li>
<li>
<p>Consistency: If each transaction is consistent and the database is consistent at the beginning of the transaction, then the database is guaranteed to be consistent when the transaction completes. Data is consistent if it satisfies all validation rules such as constraints, cascades and triggers.</p>
</li>
<li>
<p>Isolation: Isolation means that when a transaction executes, it should have the illusion that it is isolated from other transactions. Isolation ensures that concurrent execution of transactions should have the same resulting database state as a sequential execution of the transactions.</p>
</li>
<li>
<p>Durability: If a transaction commits, then its effects on the database should persist.</p>
</li>
</ul>
<h3 id="acid-atomicity">ACID: Atomicity</h3>
<ul>
<li>
<p>Approach #1: Logging:常用的方法就是记日至，典型的就是undo log，日志也能提交性能（异步刷磁盘）</p>
</li>
<li>
<p>Approach #2: Shadow Paging:备份自己改的那些页</p>
</li>
</ul>
<h3 id="acid-consistency">ACID: Consistency</h3>
<ul>
<li>后面的事务能看见前面事务的变动</li>
<li>业务的一致性是后端程序员保证的</li>
</ul>
<h3 id="acid-isolation">ACID: Isolation</h3>
<ul>
<li>好像就我一个人在用数据库</li>
<li>但是实际上是好多txn在一起跑</li>
<li>这边也是两大流派
<ul>
<li>悲观控制</li>
<li>乐观控制+回滚</li>
</ul>
</li>
<li>三种冲突
<ul>
<li>R-W</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter16-1.png" title="/img/CMU 15-445 Database Systems/chapter16-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter16-1.png" data-sub-html="<h2>R-W也叫不可重复读</h2>">
        
    </a><figcaption class="image-caption">R-W也叫不可重复读</figcaption>
    </figure></li>
<li>W-R</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter16-2.png" title="/img/CMU 15-445 Database Systems/chapter16-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter16-2.png" data-sub-html="<h2>W-R也叫脏读</h2>">
        
    </a><figcaption class="image-caption">W-R也叫脏读</figcaption>
    </figure></li>
<li>W-W</li>
</ul>
</li>
</ul>
<h3 id="acid-durability">ACID: Durability</h3>
<ul>
<li>一旦commit，必须保证持久化到磁盘上面</li>
</ul>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #15: Query Planning &amp; Optimization</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter15/</link>
    <pubDate>Mon, 15 Apr 2024 12:47:46 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter15/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-15-query-planning--optimization">Lecture #15: Query Planning &amp; Optimization</h2>
<ul>
<li>数据库最复杂的模块之一，论文都在这个上面做功夫</li>
</ul>
<h3 id="overview">Overview</h3>
<ul>
<li>
<p>SQL都是声明式的，没有告诉DBMS执行的过程</p>
</li>
<li>
<p>需要优化器来根据SQL告诉DBMS具体怎么执行</p>
</li>
<li>
<p>两种流派</p>
<ul>
<li>SQL+优化器</li>
<li>大数据处理框架(flink,spark)+程序员</li>
</ul>
</li>
<li>
<p>优化的两种流派</p>
<ul>
<li>Heuristics/Rules
<ul>
<li>启发式，通过查看catalog来看表的结构/有无索引，从而进行优化</li>
</ul>
</li>
<li>Cost-base Search
<ul>
<li>基于代价的：要估计每一个查询plan的变化，然后进行决策，要知道数据的情况</li>
</ul>
</li>
<li>大部分的数据库会结合这两个流派</li>
</ul>
</li>
<li>
<p><strong>Logical vs. Physical Plans</strong></p>
<ul>
<li>逻辑计划都是关系代数级别的</li>
<li>物理计划具体到怎么执行，比如算子怎么执行，是sort join还是hash join</li>
</ul>
</li>
<li>
<p>计划的优化是NP难度级别的问题，这门课就是讲的普及</p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter15-1.png" title="/img/CMU 15-445 Database Systems/chapter15-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter15-1.png" data-sub-html="<h2>例子：逻辑等价优化</h2>">
        
    </a><figcaption class="image-caption">例子：逻辑等价优化</figcaption>
    </figure>
<h3 id="logical-query-optimization">Logical Query Optimization</h3>
<ul>
<li>
<p>自己要写一些模式上面的规则，让优化器拿着规则去优化，比如JOIN怎么消除，怎么做索引下推</p>
</li>
<li>
<p>缺点：只能根据规则进行逻辑计划的转换，但是不能根据代价开销去进行优化，很死板</p>
</li>
<li>
<p>Some pattern</p>
<ul>
<li>Perform filters as early as possible (predicate pushdown).</li>
<li>Reorder predicates so that the DBMS applies the most selective one first.</li>
<li>Breakup a complex predicate and pushing it down (split conjunctive predicates)</li>
</ul>
</li>
</ul>
<h3 id="cost-estimations">Cost Estimations</h3>
<ul>
<li>
<p>最大的代价还是磁盘的I/O，这里的优化就是减少I/O</p>
</li>
<li>
<p>postgres:用的”magic”，黑魔法</p>
</li>
<li>
<p>老牌的商用数据库在优化的时候比开源的要保守和细得多，DB2就会结合事务，锁，用户数整体考虑，pg就比较激进和简单了</p>
</li>
<li>
<p><strong>Selection Statistics</strong></p>
<ul>
<li>这个就是参数，关系型数据库会对每张表做统计信息，这样你分析才有参数</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter15-2.png" title="/img/CMU 15-445 Database Systems/chapter15-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter15-2.png" data-sub-html="<h2>强制立即更新统计信息的命令</h2>">
        
    </a><figcaption class="image-caption">强制立即更新统计信息的命令</figcaption>
    </figure>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #14: Query Execution II</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter14/</link>
    <pubDate>Fri, 12 Apr 2024 21:01:51 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter14/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-14-query-execution-ii">Lecture #14: Query Execution II</h2>
<h3 id="background">Background</h3>
<ul>
<li>上节课讨论了DBMS的执行过程</li>
<li>这节课讨论DBMS在多线程下的执行过程</li>
</ul>
<h3 id="parallel-vs-distributed-databases">Parallel vs Distributed Databases</h3>
<ul>
<li>
<p>并行和分布式数据库</p>
</li>
<li>
<p><strong>Parallel DBMSs</strong></p>
<ul>
<li>资源都在一块，离得很近</li>
<li>资源通信很高速，OS内通信</li>
<li>线程间的通信高速又可靠</li>
</ul>
</li>
<li>
<p><strong>Distributed Databases</strong></p>
<ul>
<li>资源相互之间离得很远</li>
<li>资源之间的通信很慢</li>
<li>节点之间通信的代价很高且不可靠</li>
</ul>
</li>
</ul>
<h3 id="process-models">Process Models</h3>
<ul>
<li>模型：认为每个DBMS下面有多个worker，多个worker并行处理</li>
<li>这个模型针对的是多个SQL并发执行的问题，不能做个单个SQL并发处理的问题</li>
</ul>
<hr>
<ul>
<li><strong>Process per Worker</strong>
<ul>
<li>每一个worker给分配一个进程(OS级别的)</li>
<li>依赖OS对进程的调度</li>
<li>用共享内存来进行通信</li>
<li>优点：一个进程崩了不至于让整个系统宕机</li>
<li>例子：Oracle，Postgres(因为开发年代太古早)</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter14-1.png" title="/img/CMU 15-445 Database Systems/chapter14-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter14-1.png" data-sub-html="<h2>工作模型，因为进程太吃资源，后面基本都做了池化的技术</h2>">
        
    </a><figcaption class="image-caption">工作模型，因为进程太吃资源，后面基本都做了池化的技术</figcaption>
    </figure></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Thread per Worker</strong>
<ul>
<li>pthread统一出现后各大数据库也把模型换成了给worker分配线程</li>
<li>优点：线程切换代价小，内存天然共享</li>
<li>缺点：一个线程崩了整个进程跟着崩</li>
<li>例子：MySQL，IBM DB2</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter14-2.png" title="/img/CMU 15-445 Database Systems/chapter14-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter14-2.png" data-sub-html="<h2>工作模型</h2>">
        
    </a><figcaption class="image-caption">工作模型</figcaption>
    </figure></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p><strong>Scheduling</strong></p>
<ul>
<li>In conclusion, for each query plan, the DBMS has to decide where, when, and how to execute. Relevant
questions include:
<ul>
<li>How many tasks should it use?</li>
<li>How many CPU cores should it use?</li>
<li>What CPU cores should the tasks execute on?</li>
<li>Where should a task store its output?</li>
</ul>
</li>
<li>When making decisions regarding query plans, <strong>the DBMS always knows more than the OS</strong> and should be
prioritized as such.</li>
</ul>
</li>
<li>
<p>说白了就是让DBMS安排一个执行计划怎么执行，这个东西和缓存一样，不能完全依赖OS线程方面的系统调用，要定制化</p>
</li>
</ul>
<h3 id="inter-query-parallelism">Inter-Query Parallelism</h3>
<ul>
<li>多个SQL之间怎么并发执行</li>
<li>如果并发的查询都是只读的，那冲突很小</li>
<li>如果并发的查询涉及更新数据，那冲突就很多且不可避免</li>
</ul>
<h3 id="intra-query-parallelism-horizontal">Intra-Query parallelism (Horizontal)</h3>
<ul>
<li>
<p>水平切，把要处理的数据给切开，然后分给多个线程，这个切是靠Exchange算子的</p>
</li>
<li>
<p>多个线程干的事情是一一样的</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter14-3.png" title="/img/CMU 15-445 Database Systems/chapter14-3.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter14-3.png" data-sub-html="<h2>Exchange算子工作模型，并发调用</h2>">
        
    </a><figcaption class="image-caption">Exchange算子工作模型，并发调用</figcaption>
    </figure>
</li>
<li>
<p>Exchange Type #1 – <strong>Gather</strong></p>
<ul>
<li>→ Combine the results from multiple workers into a single output stream.</li>
</ul>
</li>
<li>
<p>Exchange Type #2 – <strong>Distribute</strong></p>
<ul>
<li>→ Split a single input stream into multiple output streams.</li>
</ul>
</li>
<li>
<p>Exchange Type #3 – <strong>Repartition</strong></p>
<ul>
<li>→ Shuffle multiple input streams across multiple output streams.</li>
</ul>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter14-4.png" title="/img/CMU 15-445 Database Systems/chapter14-4.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter14-4.png" data-sub-html="<h2>三个类型的工作模型</h2>">
        
    </a><figcaption class="image-caption">三个类型的工作模型</figcaption>
    </figure>
</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter14-5.png" title="/img/CMU 15-445 Database Systems/chapter14-5.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter14-5.png" data-sub-html="<h2>Para Hash</h2>">
        
    </a><figcaption class="image-caption">Para Hash</figcaption>
    </figure>
<h3 id="inter-operator-parallelism--vertical">Inter-Operator parallelism  (Vertical)</h3>
<ul>
<li>垂直切，让多个算子并发执行，数据在每个算子之间流动</li>
<li>Also called pipeline parallelism.</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter14-6.png" title="/img/CMU 15-445 Database Systems/chapter14-6.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter14-6.png" data-sub-html="<h2>多个算子并发</h2>">
        
    </a><figcaption class="image-caption">多个算子并发</figcaption>
    </figure>
<ul>
<li>缺点：中间一个线程处理的速度慢，其他部分线程就要等，会浪费</li>
</ul>
<h3 id="bushy-parallelism">Bushy Parallelism</h3>
<ul>
<li>上面两种并发方式的结合</li>
</ul>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter14-7.png" title="/img/CMU 15-445 Database Systems/chapter14-7.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter14-7.png" data-sub-html="<h2>水平并发&#43;垂直并发</h2>">
        
    </a><figcaption class="image-caption">水平并发+垂直并发</figcaption>
    </figure>
<h3 id="io-parallelism">I/O Parallelism</h3>
<ul>
<li>
<p>上面的模型说的都是数据已经在内存中的并行，但是对于本课程的数据库，I/O带来的性能问题如何通过并行优化甚至比前面的并行优化还重要</p>
</li>
<li>
<p>还有上面的内存并行带来的问题可能是两个算子并发读写磁盘的不同部分，那对于机械盘来说这种随机读写也会大大降低性能，这部分也要进行优化</p>
</li>
</ul>
<hr>
<ul>
<li><strong>Split the DBMS across multiple storage devices to improve disk bandwidth latency.Many different options that have trade-offs</strong>:
<ul>
<li>→ Multiple Disks per Database</li>
<li>→ One Database per Disk</li>
<li>→ One Relation per Disk</li>
<li>→ Split Relation across Multiple Disks</li>
</ul>
</li>
<li>Some DBMSs support this natively. Others require admin to configure outside of DBMS.</li>
</ul>
<hr>
<ul>
<li><strong>Multi-Disk Parallelism</strong>
<ul>
<li>在操作系统/硬件层面让不同的DBMS文件去不同的磁盘(e.g. RAID)，这个层面对DBMS是透明的（对于他来说就像操作一个盘一样）</li>
<li>多盘并发</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter14-8.png" title="/img/CMU 15-445 Database Systems/chapter14-8.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter14-8.png" data-sub-html="<h2>RAID0(Striping)下面的多盘并发</h2>">
        
    </a><figcaption class="image-caption">RAID0(Striping)下面的多盘并发</figcaption>
    </figure></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Database Partitioning</strong>
<ul>
<li>把数据库也进行切分</li>
<li>不同的库存在不同的盘，如果有统一恢复用的log文件要记得做好共享问题</li>
<li>把单个的表进行分区，物理存储上分成多个部分，注意，这个分区对应用程序来说要是透明的，不需要关心数据如何存储的</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter14-9.png" title="/img/CMU 15-445 Database Systems/chapter14-9.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter14-9.png" data-sub-html="<h2>某一个属性特别的大且不常用就可以垂直切开分两部分存</h2>">
        
    </a><figcaption class="image-caption">某一个属性特别的大且不常用就可以垂直切开分两部分存</figcaption>
    </figure></li>
</ul>
</li>
</ul>
<h3 id="conclusion">CONCLUSION</h3>
<ul>
<li>
<p>Parallel execution is important, which is why (almost) every major DBMS supports it.</p>
</li>
<li>
<p>However, it is hard to get right.</p>
<ul>
<li>→ Coordination Overhead</li>
<li>→ Scheduling</li>
<li>→ Concurrency Issues</li>
<li>→ Resource Contention</li>
</ul>
</li>
<li>
<p>总结：并发能提示DBMS效率，但是理论简单实现难得多，要面对一大堆的问题</p>
</li>
</ul>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #13: Query Processing I</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter13/</link>
    <pubDate>Fri, 12 Apr 2024 14:56:21 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter13/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-13-query-processing-i">Lecture #13: Query Processing I</h2>
<h3 id="query-plan">Query Plan</h3>
<ul>
<li>就是前面提到的执行树</li>
<li>同一个SQL可以有很多执行计划</li>
</ul>
<h3 id="processing-models">Processing Models</h3>
<ul>
<li>Approach #1: <strong>Iterator Model</strong></li>
<li>Approach #2: <strong>Materialization Model</strong></li>
<li>Approach #3: <strong>Vectorized / Batch Model</strong></li>
</ul>
<hr>
<ul>
<li>
<p><strong>Iterator Model</strong></p>
<ul>
<li>
<p>每一个算子需要提供一个Next()的方法，父算子调用一次就吐出来一些数据，如果返回null说明数据都吐出来了（很像Python的yield），我也可以调用我的子算子的Next()方法</p>
</li>
<li>
<p>也叫“<strong>Volcano/Pipeline Model</strong>”</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter12-1.jpg" title="/img/CMU 15-445 Database Systems/chapter12-1.jpg" data-thumbnail="/img/CMU 15-445 Database Systems/chapter12-1.jpg" data-sub-html="<h2>Volcano Model计算的模型</h2>">
        
    </a><figcaption class="image-caption">Volcano Model计算的模型</figcaption>
    </figure>
</li>
<li>
<p>这个模型几乎在所有DBMS中都有使用</p>
</li>
<li>
<p>这个模型会有Block的现象，比如Join的时候左边在hash，这个时候上层会被Block</p>
</li>
<li>
<p>部分操作不适合这个模型，比如Sort，只能Block之后全吐出来</p>
</li>
<li>
<p>优点：便于操作，比如LIMIT 100的话我Next() 100次就OK</p>
</li>
<li>
<p>缺点：过多的函数调用（一次返回一个，要调用好多次）会影响性能</p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p><strong>Materialization Model</strong></p>
<ul>
<li>
<p>符合直觉的模型，一把算出来给上面</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter12-2.png" title="/img/CMU 15-445 Database Systems/chapter12-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter12-2.png" data-sub-html="<h2>这里的返回值就是数组，是下面算子的最终结果</h2>">
        
    </a><figcaption class="image-caption">这里的返回值就是数组，是下面算子的最终结果</figcaption>
    </figure>
</li>
<li>
<p>OLTP的数据库喜欢这个模型(点查询)</p>
</li>
<li>
<p>OLAP容易给表吐爆</p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Vectorized / Batch Model</strong>
<ul>
<li>前两个模型折中，Next()每次吐出来一批</li>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter12-3.png" title="/img/CMU 15-445 Database Systems/chapter12-3.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter12-3.png" data-sub-html="<h2>每次吐出来一批数据</h2>">
        
    </a><figcaption class="image-caption">每次吐出来一批数据</figcaption>
    </figure></li>
<li>OLAP友好，函数调用不会过多，又不会像<strong>Materialization Model</strong>那样一次返回的东西太大</li>
<li>还有个好处就是匹配硬件，现在部分CPU支持小规模并行处理事务（类似残废版CUDA），这种模型非常符合CPU的并行批处理指令</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>函数调用的方向可以根到叶子，也可以叶子到根</li>
</ul>
<h3 id="access-methods">Access Methods</h3>
<ul>
<li><strong>Sequential Scan</strong>
<ul>
<li>顺序扫描</li>
<li>顺序把页读进来，然后顺序扫描叶中的元组</li>
<li>优化
<ul>
<li>预加载</li>
<li>不再读的东西扫完就扔</li>
<li>并行化</li>
<li>Zone Maps
<ul>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter12-4.png" title="/img/CMU 15-445 Database Systems/chapter12-4.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter12-4.png" data-sub-html="<h2>给每个页做统计信息，这样算子可以不用加载到缓存池就对页做一次判断和过滤</h2>">
        
    </a><figcaption class="image-caption">给每个页做统计信息，这样算子可以不用加载到缓存池就对页做一次判断和过滤</figcaption>
    </figure></li>
<li>问题:数据冗余，而且不能存到页里面（那又该加载到缓存池了），要转门找地方存，还要同步数据</li>
</ul>
</li>
<li>晚物化：只要需要的数据，不要整个Tuple，或者只存Record ID，利用回表拿数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Index Scan</strong>
<ul>
<li>考虑的条件后面会讲</li>
<li>用什么索引要靠优化器分析</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>Multi-Index Scan</strong>
<ul>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter12-5.png" title="/img/CMU 15-445 Database Systems/chapter12-5.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter12-5.png" data-sub-html="<h2>多索引扫描每一个条件取集合，根据谓词做交/并的操作</h2>">
        
    </a><figcaption class="image-caption">多索引扫描每一个条件取集合，根据谓词做交/并的操作</figcaption>
    </figure></li>
</ul>
</li>
</ul>
<h3 id="modification-queries">Modification Queries</h3>
<ul>
<li>
<p>更改的操作，逻辑会不一样</p>
<ul>
<li>不能无脑修改，要检查当前表的约束</li>
<li>索引等其他数据要同步进行维护</li>
<li>HALLOWEEN PROBLEM
<ul>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter12-6.png" title="/img/CMU 15-445 Database Systems/chapter12-6.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter12-6.png" data-sub-html="<h2>不记录之前操作过什么数据会导致部分数据被多次更新（更新完了之后没有达到预定条件被扫到再次被更新）</h2>">
        
    </a><figcaption class="image-caption">不记录之前操作过什么数据会导致部分数据被多次更新（更新完了之后没有达到预定条件被扫到再次被更新）</figcaption>
    </figure></li>
</ul>
</li>
</ul>
</li>
<li>
<p>expression tree</p>
<ul>
<li>给谓词表达式也用树的结构处理
<ul>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter12-7.png" title="/img/CMU 15-445 Database Systems/chapter12-7.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter12-7.png" data-sub-html="<h2>expression tree</h2>">
        
    </a><figcaption class="image-caption">expression tree</figcaption>
    </figure></li>
</ul>
</li>
<li>缺点：可能会重复计算浪费时间</li>
<li>解决方案：能先算出来的全算出来，像Java的JIT（比如经常跑的一段Java字节码，我直接转成二进制CPU指令，然后跑的时候直接跑CPU指令，省去JVM解析的过程）</li>
</ul>
</li>
</ul>
<h3 id="conclusion">CONCLUSION</h3>
<ul>
<li>The same query plan can be executed in multiple different ways.</li>
<li>(Most) DBMSs will want to use index scans as much as possible.</li>
<li>Expression trees are flexible but slow.JIT compilation can (sometimes) speed them up.</li>
</ul>
]]></description>
</item>
<item>
    <title>CMU 15-445 Lecture #11: Joins Algorithms</title>
    <link>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter11/</link>
    <pubDate>Fri, 12 Apr 2024 00:56:12 &#43;0800</pubDate><author>junglece430@gmail.com (Jungle)</author><guid>https://Jungle430.github.io/posts/cmu-15-445-database-systems/chapter11/</guid>
    <description><![CDATA[<h1 id="cmu-15-445-database-systems">CMU 15-445 Database Systems</h1>
<h2 id="lecture-11-joins-algorithms">Lecture #11: Joins Algorithms</h2>
<h3 id="introduction">Introduction</h3>
<ul>
<li>
<p>根据数据库的范式理论，设计数据库表的一个原则是不让数据冗余，所以在查找的时候JOIN的操作是少不了的</p>
</li>
<li>
<p>For binary joins, we often prefer the left table (the ”outer table” ) to be the smaller one of the two.优化SQL的一个方法，左表尽量小(<strong>这个小指的是文件页数少</strong>)，后面会说明原因</p>
</li>
</ul>
<h3 id="join-operators">Join Operators</h3>
<ul>
<li><strong>Operator Output</strong>
<ul>
<li>两个表满足JOIN条件的attributes可以组合成一个新的tuple</li>
<li>输出取决于以下几个方面
<ul>
<li>processing model</li>
<li>storage model</li>
<li>data requirements in query</li>
</ul>
</li>
<li><strong>Data</strong>
<ul>
<li><strong>Early materialization</strong>
<ul>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter11-1.png" title="/img/CMU 15-445 Database Systems/chapter11-1.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter11-1.png" data-sub-html="<h2>JOIN的时候需要什么属性都加上，最后直接输出</h2>">
        
    </a><figcaption class="image-caption">JOIN的时候需要什么属性都加上，最后直接输出</figcaption>
    </figure></li>
<li>可以避免子操作回表</li>
</ul>
</li>
<li><strong>Record Id</strong>
<ul>
<li><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter11-2.png" title="/img/CMU 15-445 Database Systems/chapter11-2.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter11-2.png" data-sub-html="<h2>属性里面放的是行id或者地址，后面需要回表拿数据</h2>">
        
    </a><figcaption class="image-caption">属性里面放的是行id或者地址，后面需要回表拿数据</figcaption>
    </figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p><strong>Cost Analysis</strong></p>
<ul>
<li>
<p>不同JOIN算法的开销</p>
</li>
<li>
<p>Assume</p>
<ul>
<li>
<p>M pages in table R, m tuples in R</p>
</li>
<li>
<p>N pages in table S, n tuples in S</p>
</li>
<li>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="n">R</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">S</span><span class="p">.</span><span class="n">cdate</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">S</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">ON</span><span class="w"> </span><span class="n">R</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">S</span><span class="p">.</span><span class="n">id</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">S</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>
<p>Cost Metric: <strong>number of IOs</strong> to compute join</p>
</li>
<li>
<p><strong>JOIN Algorithms</strong></p>
<ul>
<li>Next Loop Join</li>
<li>Sort-Merge Join</li>
<li>Hash Join</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="nested-loop-join">Nested Loop Join</h3>
<ul>
<li><strong>Native Nested Loop Join</strong></li>
<li>伪代码</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="line"><span class="cl"><span class="k">foreach</span> <span class="n">tuple</span> <span class="n">r</span> <span class="k">in</span> <span class="n">R</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">foreach</span> <span class="n">tuple</span> <span class="n">s</span> <span class="k">in</span> <span class="n">S</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">r</span> <span class="n">and</span> <span class="n">s</span> <span class="n">match</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">emit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>“stupid nested loop join”</p>
<ul>
<li><strong>一个R中的tuple需要扫S表的所有数据，对于缓存池的利用率过低，这种方法开销太大</strong></li>
<li>S每次都是先灌满缓存池，然后前面的页淘汰，如此反复</li>
</ul>
</li>
<li>
<p>Assume</p>
<ul>
<li>
<p>M pages in table R, m tuples in R</p>
</li>
<li>
<p>N pages in table S, n tuples in S</p>
</li>
</ul>
</li>
<li>
<p>Cost: $M+(m \times N)$</p>
</li>
<li>
<p>优化：高效利用缓存池，一次多加载一些页，不要一页一页加载</p>
</li>
<li>
<p><strong>Block Nested Loop Join</strong></p>
</li>
<li>
<p>伪代码</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="line"><span class="cl"><span class="k">foreach</span> <span class="n">block</span> <span class="n">B_R</span> <span class="k">in</span> <span class="n">R</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">foreach</span> <span class="n">block</span> <span class="n">B_S</span> <span class="k">in</span> <span class="n">S</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">foreach</span> <span class="n">tuple</span> <span class="n">r</span> <span class="k">in</span> <span class="n">B_R</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">foreach</span> <span class="n">tuple</span> <span class="n">s</span> <span class="k">in</span> <span class="n">B_S</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="n">r</span> <span class="n">and</span> <span class="n">s</span> <span class="n">match</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">emit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>每次不只读一页，每次R和S都读好多页进行匹配</p>
</li>
<li>
<p>Cost: $M+(\frac{M}{M\ Block\ Size} \times N)$</p>
</li>
<li>
<p>讨论block size</p>
</li>
<li>
<p>B个页的内存，一个页做输出缓存，一个页给右表，多缓存左表(给B-2个)</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="line"><span class="cl"><span class="k">foreach</span> <span class="n">B</span><span class="p">-</span><span class="m">2</span> <span class="n">blocks</span> <span class="n">B_R</span> <span class="k">in</span> <span class="n">R</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">foreach</span> <span class="n">block</span> <span class="n">B_S</span> <span class="k">in</span> <span class="n">S</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">foreach</span> <span class="n">tuple</span> <span class="n">r</span> <span class="k">in</span> <span class="n">B</span><span class="p">-</span><span class="m">2</span> <span class="n">blocks</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">foreach</span> <span class="n">tuple</span> <span class="n">s</span> <span class="k">in</span> <span class="n">B_S</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="n">r</span> <span class="n">and</span> <span class="n">s</span> <span class="n">match</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">emit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>Cost: $M+(\frac{M}{B-2}\times N)$</p>
</li>
<li>
<p>if $B-2&gt;M$, then cost: $M+N$</p>
</li>
<li>
<p>为啥nested loop join性能不行</p>
<ul>
<li>总要去遍历S表</li>
<li>为啥要遍历：<strong>没有索引等其他方案来提高查找S中属性的效率，所以只能傻瓜式的遍历</strong></li>
</ul>
</li>
<li>
<p>优化思路：提高S中查找/范围查找的速度</p>
</li>
<li>
<p><strong>Index Nested Loop Join</strong></p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="line"><span class="cl"><span class="k">foreach</span> <span class="n">tuple</span> <span class="n">r</span> <span class="k">in</span> <span class="n">R</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">foreach</span> <span class="n">tuple</span> <span class="n">S</span> <span class="k">in</span> <span class="n">Index</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">==</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">r</span> <span class="n">and</span> <span class="n">s</span> <span class="n">match</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">emit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>认为每次索引查询需要C次I/O</p>
</li>
<li>
<p>Cost: $M+(m\times C)$</p>
</li>
</ul>
<h3 id="sort-merge-join">Sort-Merge Join</h3>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter11-3.png" title="/img/CMU 15-445 Database Systems/chapter11-3.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter11-3.png" data-sub-html="<h2>先对Join的列进行排序，后面就是合并多个有序数组的思路</h2>">
        
    </a><figcaption class="image-caption">先对Join的列进行排序，后面就是合并多个有序数组的思路</figcaption>
    </figure>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter11-4.png" title="/img/CMU 15-445 Database Systems/chapter11-4.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter11-4.png" data-sub-html="<h2>匹配中可能会漏掉匹配项，必须要加上回退的功能</h2>">
        
    </a><figcaption class="image-caption">匹配中可能会漏掉匹配项，必须要加上回退的功能</figcaption>
    </figure>
<ul>
<li>
<p>Cost</p>
<ul>
<li>
<p>Sort R: $2M \times (1+\log_{B-1}\frac{M}{B})$</p>
</li>
<li>
<p>Sort S: $2N\times (1+\log_{B-1}\frac{N}{B})$</p>
</li>
<li>
<p>Merge Cost: $M+N$</p>
</li>
<li>
<p>Total Cost: $Sort + Merge$</p>
</li>
</ul>
</li>
<li>
<p>退化情况：两个连接列所有值一样，那么Merge Cost会因为回退增加到$M\times N$</p>
</li>
<li>
<p>适合的场景</p>
<ul>
<li>数据本身就有序</li>
<li>输出的结果需要排序</li>
</ul>
</li>
</ul>
<h3 id="hash-join">Hash Join</h3>
<ul>
<li>Hash table点查询比B+ Tree快
<ul>
<li>左表做hash，右表去匹配</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">build</span> <span class="nb">hash</span> <span class="n">table</span> <span class="n">HT_R</span> <span class="k">for</span> <span class="n">R</span>
</span></span><span class="line"><span class="cl"><span class="n">foreach</span> <span class="nb">tuple</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">S</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">h1</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">in</span> <span class="n">HT_R</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">output</span>
</span></span></code></pre></td></tr></table>
</div>
</div><figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter11-5.png" title="/img/CMU 15-445 Database Systems/chapter11-5.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter11-5.png" data-sub-html="<h2>给左表做哈希表，右表的数据hash完成后去哈希表里面找匹配数据</h2>">
        
    </a><figcaption class="image-caption">给左表做哈希表，右表的数据hash完成后去哈希表里面找匹配数据</figcaption>
    </figure>
<ul>
<li>
<p>Hash</p>
<ul>
<li>Key:需要连接的列</li>
<li>Value
<ul>
<li>Full Tuple:放上需要的数据，不需要回表</li>
<li>Tuple Identifier:放索引，最后需要去回表拿数据</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>OPTIMIZATION</strong></p>
<ul>
<li>Create a probe filter (such as a Bloom Filter) during the build phase if the key is likely to not exist in the inner relation 加上一层过滤器先过滤掉部分没有匹配项的数据，防止在哈希表里面找半天发现没有，比如加一个布隆过滤器</li>
</ul>
</li>
<li>
<p>如果哈希表太大可能会面临内存池驱逐的问题，但是我们不想让内存池随机驱逐</p>
</li>
<li>
<p><strong>Grace Hash Join</strong></p>
<ul>
<li>
<p>1980’s东京大学搞数据库一体机的时候发明的（现在也有一体机，比如Oracle还在卖），银行和金融机构爱买</p>
</li>
<li>
<p>左表和右表都做hash，把哈希表存在硬盘里面，把硬盘里面相对应的哈希桶拿出来做nested loop join</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter11-6.png" title="/img/CMU 15-445 Database Systems/chapter11-6.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter11-6.png" data-sub-html="<h2>能连接上的行都在一个桶号里面，所以每次都加载两个哈希表里面相同桶号的桶</h2>">
        
    </a><figcaption class="image-caption">能连接上的行都在一个桶号里面，所以每次都加载两个哈希表里面相同桶号的桶</figcaption>
    </figure>
</li>
<li>
<p>如果哈希桶还是太大怎么办，再换别的哈希函数继续哈希，直到哈希出来的块够小（这个叫<strong>RECURSIVE PARTITIONING</strong>）</p>
</li>
<li>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter11-7.png" title="/img/CMU 15-445 Database Systems/chapter11-7.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter11-7.png" data-sub-html="<h2>RECURSIVE PARTITIONING</h2>">
        
    </a><figcaption class="image-caption">RECURSIVE PARTITIONING</figcaption>
    </figure>
</li>
</ul>
</li>
<li>
<p>Cost</p>
<ul>
<li>Partition Phash:$2(M+N)$(读到内存hash后还要写回去)</li>
<li>Probing Phash:$M+N$</li>
<li>Total:$3(M+N)$</li>
</ul>
</li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<figure><a class="lightgallery" href="/img/CMU%2015-445%20Database%20Systems/chapter11-8.png" title="/img/CMU 15-445 Database Systems/chapter11-8.png" data-thumbnail="/img/CMU 15-445 Database Systems/chapter11-8.png" data-sub-html="<h2>各方法开销</h2>">
        
    </a><figcaption class="image-caption">各方法开销</figcaption>
    </figure>
<ul>
<li>Sorting和Hash没有最好，要看条件选择
<ul>
<li>哈希碰撞，输出是否有序都会影响开销</li>
<li>优秀的数据库会有优化器来进行分析和选择</li>
</ul>
</li>
</ul>
]]></description>
</item>
</channel>
</rss>
